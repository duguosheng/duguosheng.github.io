<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小兄弟点进来呀]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%82%B9%E8%BF%9B%E6%9D%A5%E5%91%80%2F</url>
    <content type="text"><![CDATA[哈哈，常晔大沙雕]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>haha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__call__方法]]></title>
    <url>%2F2019%2F09%2F17%2Fcall-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中，如果在创建类的时候写了__call__()方法， 那么该类实例化出实例后， 实例名()就是调用__call__()方法。 123456789101112class SalaryAccount: """工资计算类""" def __call__(self, salary): print("发工资") year_salary = salary*12 day_salary = salary//22.5 hour_salary = day_salary//8 return dict(year_salary=year_salary, month_salary=salary, day_salary=day_salary, hour_salary=hour_salary)s = SalaryAccount()print(s(3000)) 执行结果 12发工资&#123;'year_salary': 36000, 'month_salary': 3000, 'day_salary': 133.0, 'hour_salary': 16.0&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp网络编程]]></title>
    <url>%2F2019%2F09%2F16%2Ftcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP百度百科 简介 TCP通信需要经过创建链接，数据传送，终止连接三个步骤 通信双方都必须先建立连接才能进行通讯，双方都要为连接分配必要的系统内核资源，以管理连接的状态和传输 TCP的连接是一对一的，因此，基于广播的应用程序应使用UDP，]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[udp网络编程]]></title>
    <url>%2F2019%2F09%2F15%2Fudp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP百度百科 创建udp套接字123import socketudp_socket = socket.socket(socket.AF_INET, socket.DGRAM) 发送数据使用sendto()方法 123send_data = input("please input:")# 发送的数据(utf-8编码) (ip地址, 端口)udp_socket.sendto(send_data.encode("utf-8"), ("X.X.X.X", port)) # 如果发送方未绑定端口，系统会随机分配1024-65535 获取端口1234# 创建元组，ip地址和端口号local_addr = ("", 7788) # ip地址一般不用写，表示本机的任意一个ip# 绑定udp_socket.bind(local_addr) 程序实例123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef send_msg(udp_socket): """发送数据""" dest_ip = input("请输入对方的ip：") dest_port = input("请输入对方的port：") send_data = input("请输入发送的消息：") udp_socket.sendto(send_data.encode("utf-8"), (dest_ip, int(dest_port)))def recv_msg(udp_socket): """接收数据""" # 接收数据,1024是本次接收的最大字节数，如果未接收到会进入阻塞状态 recv_data = udp_socket.recvfrom(1024) # 会接收到数据和发送方的ip地址和端口 recv_msge = recv_data[0] send_addr = recv_data[1] # 打印接收到的数据, 需要指定解码，如果是windows发送，应当使用gbk解码 print("接收到的数据是：%s 来源于：%s" % (recv_msge.decode("utf-8"), str(send_addr)))def main(): # 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定信息 udp_socket.bind(("", 7788)) while True: print("0退出，1发送，2接收") option = input("请输入指令：") if option == "0": break elif option == "1": # 发送 send_msg(udp_socket) elif option == "2": # 接收并显示 recv_msg(udp_socket) else: print("输入错误，请重新输入")if __name__ == "__main__": main() socket套接字是全双工工作模式，即可以同时收发]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络的一些基本概念]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[ip地址的分类ipv4(百度百科) internet protocol version 4指互联网协议的第四种版本，ipv1，ipv2，ipv3是实验版本 特点： 由四组数字组成：如127.168.8.32，其中每组最大值是255ipv6 internet protocol version 6指第六种版本，ipv5是实验版本 表示方法：(引自百度百科) 冒分十六进制表示法 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789这种表示法中，每个X的前导0是可以省略的，例如：2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A 0位压缩表示法 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为::。但为保证地址解析的唯一性，地址中::只能出现一次，例如：FF01:0:0:0:0:0:0:1101 → FF01::1101，0:0:0:0:0:0:0:1 → ::1，0:0:0:0:0:0:0:0 → :: 内嵌IPv4地址表示法 为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用 端口 ip用来标识主机，端口(port)用来指定数据传输的主机程序 知名端口(Well Known Ports) 知名端口是众所周知的端口号，范围从0到1023，如： 80端口分配给HTTP服务 21端口分配给FTP服务动态端口(Dynamic Ports) 动态端口范围是1024-65535 之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配 动态分配：程序需要网络通信时，它向主机申请一个端口，主机从可用的端口中为它分配一个，当这个程序关闭时，同时也就释放了它所占用的端口 套接字(socket) 网络套接字是IP地址与端口的组合。套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信. 在python中使用socket 在python中使用socket模块即可12import socketsocket.socket(AddressFamily, Type) 参数说明 AddressFamily: 可以选择AF_INET(用于Internet进程间通讯)或者AF_UNIX(用于同一台机器进程间通讯)，实际工作中常用AF_INETType: 套接字类型，可以是SOCK_STREAM(流式套接字，主要用于TCP协议)，或者SOCK_DGRAM(数据报套接字，主要用于UDP协议) 创建一个tcp套接字12345678910import socket# 创建tcp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 使用套接字的功能... ...# 关闭套接字s.close() 可以发现，它的基本流程与文件的操作大致相同 创建一个udp套接字123456789101112131415161718import socket def main(): """测试udp发送数据""" # 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 接收要发送的数据 send_data = input("请输入发送的数据：") # 发送数据 使用utf-8编码，后接元组(ip地址，端口) udp_socket.sendto(send_data.encode("utf-8"), ("192.168.32.32", 8080)) # 关闭套接字 udp_socket.close()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@property装饰器]]></title>
    <url>%2F2019%2F09%2F11%2Fproperty%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[功能 @property装饰器可以让方法像属性一样进行调用 演示不使用@property装饰器1234567891011121314class Person(object): def __init__(self, age): self.__age = age def set_age(self, age): self.__age = age def get_age(self): return self.__agejack = Person(18)print(jack.get_age())jack.set_age(20)print(jack.get_age()) 运行结果121820 使用装饰器12345678910111213141516171819class Person: def __init__(self, age): self.__age = age @property def age(self): return self.__age # 注意这里是age.setter @age.setter def age(self, age): self.__age = agejack = Person(18)# 像属性一样调用方法print(jack.age)# 像属性一样调用方法jack.age = 20print(jack.age) 运行结果121820]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
        <tag>property装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval()函数]]></title>
    <url>%2F2019%2F09%2F10%2Feval-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[功能描述123456789101112131415# 数学计算input: eval("1+1")output: 2# 字符串重复input: eval("'*' * 10")output: **********# 将字符串转化为列表input: type(eval("[1, 2, 3, 4]"))output: list# 将字符串转换为字典input: type(eval("&#123;'name': 'xiaoming', 'age': 18&#125;"))output: dict 演示案例：计算器1print(eval(input("请输入计算式: "))) 执行12请输入计算式: 5+2*5**255 不要滥用eval 使用eval()直接转换输入结果可能导致安全漏洞，如上例中用户输入__import__(&#39;os&#39;).system(&#39;ls&#39;) 等价于 12import osos.system("ls") 运行 1234请输入计算式: __import__('os').system('ls')test1.pytest2.py0 输出了当前目录下文件列表，同理也可执行其他增删改的终端命令，很不安全 执行成功，返回0 执行失败，返回错误信息]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>eval</tag>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的文件操作]]></title>
    <url>%2F2019%2F09%2F09%2Fpython%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件基本操作操作文件的函数/方法 函数/方法 功能 open 打开文件，并返回操作对象 read 将文件读取到内存 write 将指定内容写入文件 close 关闭文件 read write close三者都要通过文件对象来进行调用 read方法 open()第一个参数是要打开的文件名(区分大小写) 打开后操作完成要使用close()关闭，否则会消耗系统资源，影响后续对文件的访问 通常先编写打开和关闭文件代码，在编写中间的读写操作 1234567# 打开file = open("文件名")# 读取text = file.read()print(text)# 关闭file.close() 关于文件指针 python中读取完内容后会将指针移动到读取内容的末尾，默认是文件末尾 连续两次读取文件，由于第一次读完指针已经在末尾，因而第二次读不到内容 打开文件的方式 open()默认以只读打开 1file = open("文件名", "访问方式") 访问方式 说明 r 只读，指针在文件开头，不存在会抛出异常 w 只写，若文件存在则覆盖，不存在则创建 a 追加，文件存在，指针就放在文件末尾，不存在，抛出异常 r+ 读写，文件指针在开头，若不存在，抛出异常 w+ 读写，文件存在则覆盖，不存在就创建 a+ 读写，文件存在则指针放在末尾，文件不存在，创建新文件 使用读写方式打开，会影响文件读写效率，开发中更多的是以只读，只写的方式打开 按行读取 read()方法默认读取全部，读取大文件对于系统内存占用会非常严重 readLine方法 一次读取一行，方法执行后，指针向下移动一行 读取大文件123456789101112131415file = open("test")while True: # 读取一行 text = file.readLine() #判断是否读取到内容 if not text: break #每读到一行末尾已经有"\n" print(text, end="") # 关闭文件file.close() 复制文件1234567891011file_r = open("test")file_w = open("test_copy")while True: text = file_r.readLine() if not text: break file_w.write(text)file_r.close()file_w.close() 执行后打开file_w文件，发现已经复制了file_r的内容 文件/目录的常用管理操作文件操作 方法 说明 示例 rename 重命名文件 os.rename(“源文件名”, “目标文件名”) remove 删除文件 os.remove(“文件名”) 目录操作12# 导入os模块import os 方法 说明 示例 listdir 目录列表 os.listdir(“目录名”) mkdir 创建目录 os.mkdir(“目录名”) rmdir 删除目录 os.rmdir(“目录名”) getcwd 获取当前目录 os.getcwd() chdir 修改工作目录 os.chdir(“目标目录”) path.isdir 判断是否为目录 os.path.isdir(“文件路径”) python编码 python2默认使用ascii编码，不支持中文 python3默认使用utf-8编码，支持中文 改变python2的编码格式，使支持中文，将下句代码写在文件开头1# *-* coding:utf-8 *-* 或者 1# coding = utf-8 另外，使用python2输出中文时，会出现乱码，这是因为解释器会一个字节一个字节的输出，而中文一般是三个字节 12345678#!/usr/bin/python2# *-* coding: utf-8 *-*my_str = "hello, 你好"print(my_str)for letter in my_str: print(letter) 运行结果 12345678910111213hello, 你好hello,�� 输出乱码 解决方法：定义字符串时，前面加上字母u，说明这是utf-8格式的字符串 1my_str = u"hello, 你好" 再次运行 12345678910hello, 你好hello,你好 不再乱码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的模块和包]]></title>
    <url>%2F2019%2F09%2F06%2Fpython%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[模块每一个以py结尾的python源代码文件都是一个模块 模块导入import导入格式 不推荐格式：将几个模块放在一行 1import 模块名1, 模块名2 推荐:每个模块单独占一行 12import 模块名1import 模块名2 导入之后可以通过模块名.的方式使用模块提供的工具：全局变量，类，函数 使用as指定模块别名 如果模块名字太长就可以使用as来指定别名，方便实用1import 模块名 as 模块别名 模块别名应该符合大驼峰命名法 from…import导入 如果希望从某一个模块中，导入部分工具，就可以使用这种方式 语法格式12# 从模块导入某一个工具from 模块名 import 工具名 导入之后不需要通过模块名.就可以直接使用模块的工具如果两个模块存在同名的函数，那么后导入模块的函数，会覆盖掉先导入的函数 可以通过as别名的方式调用前面导入的函数12345from pkg1 import test as pkg1_test #给test()函数起别名from pkg2 import test # pkg1和pkg2中同时含有test()方法pkg1_test() #调用pkg1的test()test() #调用pkg2的test() 导入全部 语法12# 从 模块 导入 所有工具from 模块名 import * 不推荐使用，因为函数重名不好排查 python导入模块的顺序 搜索当前目录指定模块名的文件，如果有就直接导入 如果没有，再搜索系统目录 在开发时创建文件，命名不要和系统模块文件重名，否则调用系统方法时会因为当前目录下存在该模块而不去搜索系统目录，使程序无法正确执行 使用内置方法__file__可查看文件完整路径1print(模块名.__file__) 关于模块导入 在导入模块时，文件中没有缩进的代码都会被执行一遍12# 这是test1模块中的内容print("这是模块一") 123# 这是test2模块中的内容import test1print("这是模块二") 在模块test2中run，执行结果12这是模块一这是模块二 而有时开发中开发者要做一些测试，写的一些代码只希望在本文件内执行而不想在被导入时执行 __name__属性 __name__属性可以做到，测试模块的代码只在测试时执行，在被导入时不执行 __name__属性是python的一个内置属性，记录着一个字符串 如果是被其他文件导入的，则记录的是模块名 如果是当前执行的程序，__name__是__main__12# 模块test1中print(__name__) 123# 模块test2中import test1print(__name__) 在test2中run，运行结果 12test1__main__ 所以在测试时可以通过__name__来实现代码仅在测试时执行 123# 模块test1中if __name__ == "__main__": print("这是模块一") 123# 模块test2中import test1print("这是模块二") 在模块test2中run，运行结果 1这是模块二 编写代码格式 1234567891011.........# 文件末尾，编写本地测试代码def main(): ... pass if __name__ == "__main__": main() 包 包是一个包含多个模块的特殊目录 目录下有一个特殊的文件__init__.py 包的命名和变量一致，使用小写字母和_，如this_is_a_pkg 可以使用import 包名的方式，一次性导入包中所有的模块 在pycharm中鼠标停在工程名上点击鼠标右键 选择new –&gt; Python Package可以建立包并自动创建__init__.py空文件 或选择new –&gt; Directory创建文件目录，再自行创建__init__.py文件 __init__.py文件 包中可以对外界使用的模块，需要在__init__.py中写出列表123# 从 当前目录 导入 模块列表from . import 模块名称1from . import 模块名称2 发布模块包的步骤发布包 创建setup.py文件1234567891011from distutils.core import setupsetup(name="pkg_name", # 包名 version="1.0", # 版本 description="some text", # 描述信息 long_description="完整的发送和接收消息模块", # 完整描述信息 author="itheima", # 作者 author_email="abc.com", # 作者邮箱 url="www.abc.com", # 主页 py_modules=["包名.模块名1", #要分享的模块 "包名.模块名2"]) 有关字典参数的详细信息，可以参阅官方网站 构建模块 1python3 setup.py build 生成发布压缩包 1python3 setup.py sdist 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！ 下载包 安装模块 12tar -zxvf 压缩包名.tar.gz sudo python3 setup.py install 卸载模块直接从安装目录下，把安装模块的目录删除就可以 12cd /usr/local/lib/python3.7/dist-packages/sudo rm -r 包名* 可以使用pip安装第三方模块 1234567# 将第三方模块安装到python2.x环境sudo pip install 模块sudo pip uninstall 模块# 将第三方模块安装到python3.x环境sudo pip3 install 模块sudo pip3 uninstall 模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的异常]]></title>
    <url>%2F2019%2F09%2F06%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[程序开发时很难将所有特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件集中处理，从而保证程序的稳定性和健壮性 捕获异常简单捕获 格式1234try: 尝试执行的代码except: 出现错误的处理 执行后会继续执行下方的代码 123456try: num = int(input("请输入一个整数: "))except: print("请输入正确的整数")print("继续执行了下方代码") 执行程序：用户输入了aaa，无法转化为整数 请输入一个整数: aaa 执行结果12请输入正确的整数继续执行了下方代码 错误类型捕获 针对不同类型的异常，作出不同的相应 123456789101112try: #尝试执行的代码 passexcept 错误类型1: #针对类型1处理 passexcept (错误类型2, 错误类型3): #针对类型2和3处理 pass# 捕获未知错误，可以改变result的名字except Exception as result: print("未知错误 %s" % result) 获取错误类型：出错时，控制台提示的最后一行就是错误类型，找到错误类型就可针对不同的错误进行不同的操作 123num = int(input("请输入一个整数: "))result = 10/numprint(result) 执行程序，用户输入0 请输入一个整数: 0 执行结果1234Traceback (most recent call last): File "/home/duguosheng/PycharmProjects/190902/d2_excpt.py", line 3, in &lt;module&gt; result = 10/numZeroDivisionError: division by zero 则ZeroDivisionError就是输入零时的错误类型，同理可得，输入字母时的错误类型是ValueError 针对不同错误类型的处理 12345678try: num = int(input("请输入一个整数: ")) result = 10 / num print(result)except ZeroDivisionError: print("请不要输入0作为除数")except ValueError: print("请输入数字") 捕获未知异常:假设未能预计到输入零的情况 123456789try: num = int(input("请输入一个整数: ")) result = 10 / num print(result)except ValueError: print("请输入数字")# 捕获未知异常except Exception as result: print("未知错误 %s" % result) 用户输入0 请输入一个整数: 0 执行结果1未知错误 division by zero 异常捕获完整语法1234567891011121314try: passexcept 错误类型1: passexcept (错误类型2, 错误类型3): passexcept Exception as result: print(result)else: #没有异常才会执行的代码 passfinally: #无论是否有异常，都会执行的代码 pass 异常的传递 当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方 如果传递到主程序，仍然没有异常处理，程序才会终止 开发中可以在主函数中增加异常捕获，这样就可以大大减少异常捕获代码，使代码整洁 12345678910def test1(): return 10/int(input("请输入一个整数： "))def test2(): return test1()#只在主函数中增加异常捕获try: print(test2())except Exception as result: print("未知错误 %s" % result) 输入0 请输入一个整数： 0 执行结果 1未知错误 division by zero 成功捕获异常并处理 主动抛出异常 当前函数只负责某项功能，主动抛出异常后，让其他函数再处理 主动抛出异常的方法 创建一个Exception对象 使用raise关键字抛出异常对象 实例 1234567891011121314def test(): num = int(input("请输入一个整数： ")) if num &gt; 0: return 10/num #主动抛出异常 exception = Exception("请不要输入0") raise exception#只在主函数中增加异常捕获try: print(test())except Exception as result: print(result) 输入0 请输入一个整数： 0 执行结果1请不要输入0]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式是为了可重用代码，让代码易于理解，保证可靠性 目的 让类创建的对象，在系统中只有惟一的一个实例 每一次执行类名()返回的对象，内存地址是相同的 __new__方法 创建对象时，首先会使用__new__方法为对象分配内存空间 __new__方法： 在内存中为对象分配空间 返回对象的引用 python解释器获得对象的引用之后，将引用作为第一个参数，传递给__init__方法 重写__new__方法的代码非常固定 __new__是一个静态方法，调用时需要主动传递cls参数 重写__new__一定要`return super().new(cls) 否则解释器得不到分配了空间的对象引用，就不会调用__init__方法12345678class A(object): def __new__(cls, *args, **kwargs): print("分配空间") def __init__(self): print("创建对象")a1 = A()print(a1) 执行结果 12分配空间None 可见自动执行了__new__而没有执行__init__，且a1没有内存空间 python中的单例 定义一个类属性，初始值是None，用于记录单例对象的引用 重写__new__方法 如果属性is None，调用父类的方法分配空间，并在类属性中记录结果 返回类属性中记录的对象引用1234567891011121314151617class A(object): # 创建类属性记录对象引用 instance = None # 重写__new__ def __new__(cls, *args, **kwargs): #判断是否为空对象 if cls.instance is None: # is None则分配空间 cls.instance = super().__new__(cls) #返回对象引用 return cls.instancea1 = A()a2 = A()print(a1)print(a2) 运行结果12&lt;__main__.A object at 0x7f701d71e690&gt;&lt;__main__.A object at 0x7f701d71e690&gt; 可见a1与a2地址是相同的，是同一个对象 只执行一次初始化 上例中每创建一个对象就会调用一次__init__ 设立类属性标志位，在__init__中判断 12345678910111213141516171819202122232425class A(object): # 创建类属性记录对象引用 instance = None init_flag = False # 重写__new__,静态方法需要传入cls以访问类属性 def __new__(cls, *args, **kwargs): #判断是否为空对象 if cls.instance is None: # is None则分配空间 cls.instance = super().__new__(cls) #返回类属性 return cls.instance def __init__(self): # 使用类名.的方式访问类属性 if A.init_flag: return A.init_flag = True print("初始化")a1 = A()a2 = A()print(a1)print(a2) 运行结果 123初始化&lt;__main__.A object at 0x7f1aa35baa50&gt;&lt;__main__.A object at 0x7f1aa35baa50&gt; 只被初始化了一次]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类属性，类方法，静态方法]]></title>
    <url>%2F2019%2F09%2F05%2F%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[类的结构 实例 创建出来的对象叫实例 创建对象的动作叫实例化 对象的属性叫做实例属性 对象调用的方法叫实例方法 每一个对象都有自己独立的内存空间，保存各自不同的属性 多个对象的方法，在内存中只有一份，调用方法时，需要把对象的引用传递到方法内部 类是特殊的对象 python中一切皆对象 class A定义的类属于类对象 aa = A()属于实例对象 在程序运行时，类也会被加载到内存 类对象在内存中只有一份，使用一个类可以创建出很多对象实例 除了实例的属性和方法外，类对象还可以拥有自己的属性和方法 类属性 类方法 通过类名.的方式可以访问 类属性和实例属性使用 类属性旧式给类对象定义的属性，通常用它来记录与这个类相关的特征 123456789class A(object): count = 0 def __init__(self): A.count += 1a1 = A()print(A.count)a2 = A()print(A.count) 执行结果 1212 属性获取机制 访问属性有两种方式 类名.类属性 对象.类属性（不推荐） 在python中使用对象.属性时 先从对象内部查找对象属性，如果没有就会向上寻找类属性 上例中也可写作 12print("a1.count")print("a2.count") 不要使用对象访问类属性 使用对象.类属性的方式给类属性赋值时，会给添加一个属性，不会影响到类属性 123456789class A(object): count = 0 def __init__(self): A.count += 1a1 = A()a1.count = 5print(A.count)print(a1.count) 执行结果 1215 类方法 定义类方法 123@classmethoddef 类方法名(cls): pass 可以使用cls.访问类的属性和方法 静态方法 在开发时既不需要访问实例属性和实例方法，也不需要访问类方法和类属性，就可定义为静态方法 语法如下 123@staticmethoddef 静态方法名(): pass 方法名后面直接跟()，不需要加self或cls 通过类名.静态方法调用 12345class A(object): @staticmethod def test(): print("hello")A.test() 执行结果 1hello]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_多态]]></title>
    <url>%2F2019%2F09%2F05%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码灵活度 演示1234567891011121314151617class Dog(object): def play(self): print("跑跑跳跳")class Xtq(Dog): def play(self): #重写父类方法 print("飞到天上")class Person(object): def play_with_dog(self, dog): print("快乐玩耍") dog.play()wangcai = Dog() #普通狗旺财xiaotian = Xtq() #哮天犬xiaoming = Person()xiaoming.play_with_dog(wangcai) print("*"*30)xiaoming.play_with_dog(xiaotian) #使用方法不变，传入另一个对象 执行结果12345快乐玩耍跑跑跳跳******************************快乐玩耍飞到天上]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_继承]]></title>
    <url>%2F2019%2F09%2F05%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承：实现代码的重用，相同的代码不需要重复编写 继承语法12class 子类(父类): ... 继承的传递性：A继承自B，B继承自C，则A也拥有C的属性和方法 子类不能访问父类的私有属性或方法，但可以在父类方法中访问自身私有内容，子类调用该方法来间接访问 多继承 语法 12class 子类(父类1, 父类2): ... 注意：如果多继承中，不同的父类方法重名，则会优先使用继承顺序靠前的父类方法 123456789101112131415161718192021222324252627class A: def test(self): print("A--test") def demo(self): print("A--demo")class B: def test(self): print("B--test") def demo(self): print("B--demo")class C(A, B): passclass D(B, A): passprint("继承顺序是先A后B")cc = C()cc.test()cc.demo()print("继承顺序是先B后A")dd = D()dd.test()dd.demo() 运行结果 123456继承顺序是先A后BA--testA--demo继承顺序是先B后AB--testB--demo 尽管不会报错，但不利于程序的阅读和理解，所以尽量不要使用多继承，使用时，也尽量保证属性方法不重名 __mro__ 用于查看方法搜索顺序类名.__mro__ 如在上例中使用 12print(C.__mro__)print(D.__mro__) 输出结果 12(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;) 重写方法override 在子类中直接编写与父类中同名的方法即可 12345678910111213class Animal: def voice(self): print("叫") def eat(self): print("吃")class Cat(Animal): def voice(self): print("喵喵喵")tom = Cat()tom.eat()tom.voice() 运行结果 12吃喵喵喵 对父类方法进行扩展 调用父类方法 super().方法名 父类名.方法(self) 不推荐使用，因为当父类名改变时，语句也要改变 将上例中Cat 类中voice方法改成 12345class Cat(Animal): def voice(self): super().voice() #第一种方法调用父类方法 Animal.voice(self) #第二种方法 print("喵喵喵") 执行结果 1234吃叫叫喵喵喵 新式类和旧式类 新式类：以object 为基类的类，推荐使用 旧式类：不以object 为基类的类，不推荐使用 python3中默认使用object类作为基类，即python3中定义的类全部是新式类 python2中如果没有指定父类，不会使用object类作为基类 新旧类会影响方法搜索顺序保证python2与python3的统一，可以写作 12class 类名(object): ... 构造函数的继承 旧式类：父类名称.init(self,参数1，参数2，…) 新式类：super(子类，self).init(参数1，参数2，….) 123456789101112class A(object): def __init__(self, name): self.name = nameclass B(A): def __init__(self, name, age): #调用父类初始化方法 super(B, self).__init__(name) self.age = agebb = B("das", 17)print(bb.name)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_封装]]></title>
    <url>%2F2019%2F09%2F04%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[封装：根据职责，将方法 和属性 封装到一个类中 dir()函数 使用dir()可以查看一个对象所有的可用方法 12345def test(): """this is a example""" print("hello") print(dir(test)) #查看可用方法 运行结果 1['__bool__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] 使用这些方法 1print(test.__doc__) 运行结果 1this is a example 返回了函数注释信息 定义简单类-只包含方法定义类123456class 类名: def 方法1(self, 参数列表) pass def 方法2(self, 参数列表) pass 类名使用大驼峰命名法 命名，首字母大写 类中的方法第一个参数必须是self，没有参数也要写self 创建对象1对象变量 = 类名() 先给创建出的对象开辟内存空间，再使对象变量 指向该地址 多次创建会开辟不同的内存空间 使用print()可以查看：对象的类和内存地址 123456class Cat: def eat(self): print("i love fish")tom = Cat()print(tom) 输出结果 1&lt;__main__.Cat object at 0x7f9c62f67290&gt; 给对象增加属性 可以直接使用赋值语句，继续使用上个例子中创建的tom1tom.name = "汤姆" #这样tom就获得了一个name的属性 这种方式不推荐使用，应当把属性封装在类中 关于self 哪一个对象调用的方法，self就是哪一个对象的引用 12345678910class Cat: def eat(self): print("%s 爱吃鱼" % self.name)tom = Cat()jf = Cat()tom.name = "汤姆"jf.name = "加菲"tom.eat()jf.eat() 输出结果 12汤姆 爱吃鱼加菲 爱吃鱼 可见self.name 返回的是各自的属性 初始化方法 当使用类名创建对象时，自动执行 创建对象：在内存中分配空间 初始化：执行__init__方法，__init__是专门用来定义一个类具有那些属性的方法 自动执行__init__ 12345class Cat: def __init__(self): print("自动执行了__init__方法")tom = Cat() 输出结果 1自动执行了__init__方法 在初始化内部定义属性 在__init__ 内部使用self.属性名 = 属性初始值 就可以定义属性 定义属性后，使用类名创建的对象都将拥有该属性 123class Cat: def __init__(self): self.name = "tom" 这样创建的对象name 属性是相同的，若想创建的同时给对象指定不同的属性，可以给__init 加入参数 12345class Cat: def __init__(self, name): self.name = name tom = Cat("Tom") 内置方法和属性__init__ 初始化时自动调用 __del__ 当对象被从内存中销毁前，会自动调用__del__ 方法 123456789class Cat: def __init__(self, name): self.name = name print("%s被创建了" % name) def __del__(self): print("对象被销毁了")tom = Cat("TOM")print("*" * 30) 执行结果 123TOM被创建了******************************对象被销毁了 使用del 关键字可以删除对象123tom = Cat("TOM")del tomprint("*" * 30) 执行结果123TOM被创建了对象被销毁了****************************** 可以使用del 关键字可以调用__del__ 方法 __str__ python中使用print() 输出对象，默认返回类和地址 可以使用__str__ 自定义返回内容 __str 必须返回一个字符串 12345678class Cat: def __init__(self, name): self.name = name def __str__(self): return "i am %s" % self.nametom = Cat("TOM")print(tom) 执行结果 1i am TOM 一个对象的属性可以是另一个类创建的对象1234567891011121314class Cat: def __init__(self, name, mouse): self.name = name self.mouse = mouse def catch(self): print("%s抓住了%s" % (self.name, self.mouse.name)) class Mouse: def __init__(self, name): self.name = namejerry = Mouse("Jerry")tom = Cat("Tom", jerry)tom.catch() 执行结果1Tom抓住了Jerry None 关键字 当不知道给参数什么初值时，可以使用None，他表示一个没有方法和属性的空对象，是一个特殊的常量 可以给任意一个变量赋None12a = Noneself.name = None 身份运算符is 与is not 身份运算符用于比较两个对象的内存地址是否一致–是否是对于同一个对象的引用 在python中使用None 比较时，建议使用is 和is not is 与== 的区别 is 判断是否为同一个对象 == 判断值是否相等1234a = [1, 2, 3]b = [1, 2, 3]print(a == b)print(a is b) 运行结果 12TrueFalse 私有属性和私有方法 定义方法：在定义属性或方法时，在名字前增加两个下划线__ 私有属性：在对象的方法内部可以访问，在外界不能直接访问 12345678910111213141516class Cat: def __init__(self, name, mouse): self.name = name self.__mouse = mouse def __str__(self): if self.__mouse: # 在对象内部方法可以访问私有属性 return "yes" else: return "no"tom = Cat("Tom", True)print(tom.name)# print(tom.__mouse) 访问不到私有属性__mouseprint(tom) 执行结果 12Tomyes 伪私有属性和方法 在python中，实际上没有完全的私有，对于私有属性和方法，在外部可以通过在属性或方法名前加_类名(下划线加类名)的方法访问，但尽量不要使用 12345678910class Women: def __init__(self, name): self.name = name self.__age = 18 def __secret(self): print("%s 年龄是%d" % (self.name, self.__age))mary = Women("玛丽")print(mary._Women__age)mary._Women__secret() 执行结果 1218玛丽 年龄是18]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数的返回值 利用元组返回多个值 1234567def test(): num = 1 str = "hello" return (num, str) temp = test() #则temp是一个元组类型，对于不同的内容要使用对应索引调用，容易出错temp1, temp2 = test() #或使用多个变量接收返回值，方便管理 同理，可利用元组交换数据 12a, b = (b, a)a, b = b, a # =右边是省略括号的元组 形参与实参在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用1234567891011121314def test(num, my_list): print("函数内部：") #赋值 num = 10 my_list = [4, 5, 6] print(num) print(my_list) g_num = 5g_list = [1, 2, 3]test(g_num, g_list)print("执行完成后")print(g_num)print(g_list) 执行结果123456函数内部：10[4, 5, 6]执行完成后5[1, 2, 3] 实参未改变，其原因是变量与数据是分开存储的，g_num 指向数据5 的地址，当将g_num传入test函数是，实则是传入了数据5 的地址，而当使用赋值语句时，局部变量num指向新的数据10 ，但g_num仍然指向5 如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据12345678def test1(my_list): print("函数内部：") my_list.append(9) print(my_list)g_list = [1, 2, 3]test1(g_list)print("程序结束：%s" % g_list) 输出结果123函数内部：[1, 2, 3, 9]程序结束：[1, 2, 3, 9] 可见外部参数也被修改，其原因是使用数据的自身方法不会创建新的数据，而是在原有数据上的修改，外部变量和局部变量同时指向该地址，因而在函数内部使用方法修改后会影响外部参数 +=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法123456789101112def test2(num, my_list): num += 10 print("不可变类型函数内部+=结果%d" % num) my_list += [8] print("可变类型函数内部+=结果%s" % my_list)g_number = 5g_l1 = [1, 2, 3]test2(g_num,g_l1)print("不可变类型外部结果%d" % g_number)print("可变类型外部结果%s" % g_l1) 运行结果1234不可变类型函数内部+=结果15可变类型函数内部+=结果[1, 2, 3, 8]不可变类型外部结果5可变类型外部结果[1, 2, 3, 8] 可见前者外部未改变，后者外部改变 给函数添加缺省值 在函数定义时可在参数后面加= 并添加缺省值 1234567891011121314def test3(name, gender=True): #True是gender的缺省值 """ 输入姓名和性别 :param name: 姓名 :param gender: 性别 True男生 False女生 :return: null """ gender_text = "男生" if not gender: gender_text = "女生" print(name+"是"+gender_text)test3("小明") #gender未输入，则使用缺省值test3("小美", False) #指定gender 输出结果 12小明是男生小美是女生 注意：带有缺省值的参数必须放在参数列表的末尾 当有多个缺省参数而需要指定特定的某个参数值时，需要同时输入参数名 123456789def test4(name, gender=True, grade="大一"): #代码块 ...#如果指定gendertest4("小美", False)#如果指定gradetest4("小明", grade="大二") 多值参数 有时一个函数传入的参数个数是不确定的，这个时候就可以使用多值参数 python中有两种多值参数 参数名前加一个 *可以接收元组 参数名前加两个 * 可以接收字典 一般给多值参数命名时，习惯使用以下名字 *args – 存放元组 arguments(变量) **kwargs –存放字典 kw是keyword123456def demo1(num, *args, **kwargs): print(num) print(args) print(kwargs)demo1(1, 2, 3, 4, 5, name="小明", age=18) #这种写法无须拆包 键不需要加分号，并用=连接 输出结果1231(2, 3, 4, 5)&#123;'name': '小明', 'age': 18&#125; 元组和字典的拆包 在调用有多致参数的函数时，如果希望 将元组直接传给args 将字典直接传给kwargs 就可以使用拆包 在元组变量前加一个* 在字典变量前加两个 * 12345678def demo2(*args, **kwargs): print(args) print(kwargs)g_nums = (1, 2, 3)g_dict = &#123;"姓名":"小明", "age":18&#125;demo2(g_nums, g_dict)demo2(g_nums, **g_dict) 运行结果1234((1, 2, 3), &#123;'姓名': '小明', 'age': 18&#125;)&#123;&#125;((1, 2, 3),)&#123;'姓名': '小明', 'age': 18&#125; 可见前者字典也被传给了args，与期望不符，而后者加了** 实现预期]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中关于全局变量]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[python中不允许直接修改全局变量的值 1234567891011num = 1 #定义全局变量def test1(): num = 2 print(num)def test2(): print(num)test1()test2() 按照其他语言的逻辑，全局变量在test1()中被修改为2，则在test2()中也输出2，而最终的输出结果是 1221 并未如所想，其原因是python不允许直接修改全局变量的值，如果使用赋值语句，会在函数内部创建一个同名局部变量，而此局部变量在函数执行完成后就会被系统回收 全局变量的修改 使用global 声明变量即可 123456789101112num = 1 #定义全局变量def test1(): global num num = 2 print(num)def test2(): print(num)test1()test2() 输出结果 1222 全局变量的命名 可以在全局变量前加g_ 或gl_ 的前缀]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的高级数据类型]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[获取元素类型 123# 使用type()获取数据类型my_list = [1, 2, 3]print(type(my_list)) 列表 类似于其他数据类型中的数组 列表使用[]括起来 列表中可以存储不同类型的数据类型 1234567891011121314151617181920212223242526my_list = ["aaa","bbb","ccc"]print(my_list[0]) #取值print(my_list.index("aaa")) #取索引my_list[0] = "ddd" #修改my_list.append("eee") #增加数据my_list.insert(1,"fff") #插入数据在my_list[1]，后面的数据后移temp_list = ["a","b"]my_list.extend(temp_list) #将另一个列表扩展进来my_list.remove("bbb") # 删除指定元素,如果出现多次，删除第一个my_list.pop() #默认删除最后一个元素（出栈）my_list.pop(3) #删除my_list[3]my_list.clear #清空列表del my_list[1] #利用del删除（直接从内存中删除，后续代码不可使用该变量）a = 10del alength = len(my_list) #读取列表大小time = my_list.count("aaa") #读取aaa出现的次数my_list.sort() #升序排序my_list.sort(reverse=True) #降序排序my_list.reverse() #逆序反转 迭代遍历12for temp_name in my_list: print("the name is %s" % temp_name) 元组 元组与列表相似，不同之处在于元组的元素不能修改 使用() 定义 1234567891011# 定义空元组empty_tuple = ()# 定义单元素元组single_tuple = (5) #这样定义得到的single_tuple是int类型single_tuple = (5,) #正确my_tuple(1) # 取值my_tuple.index("aaa") #取索引my_tuple.count("aaa") #统计aaa出现次数len(my_tuple) #统计长度 遍历元组 123for temp_info in my_tuple: 执行代码 ... 元组的应用 拼接字符串 12345my_tuple = ("zhangsan", 18, 175.5)print("%s的年龄是%d,身高是%f" % my_tuple)my_str = "%s的年龄是%d,身高是%f" % my_tupleprint(my_str) 保护列表安全 123my_list = [1, 2, 3, 4]my_tuple1 = tuple(my_list) #使用tuple()将list转换成tuplemy_list2 = list(my_tuple1) #使用list()将tuple转换成list 利用元组返回多个值 1234567def test(): num = 1 str = "hello" return (num, str) temp = test() #则temp是一个元组类型temp1, temp2 = test() #多个变量接收返回值 交换数字 1a, b = (b, a) 字典 使用{}定义 列表是有序的数据集合 字典是无序的数据集合 使用键值对存储数据 键 (key) 是索引，必须唯一 ，只能是字符串，数字，或者元组 值 (value) 是数据，可以是任意数据类型 key 和value 之间使用: 分隔 123456789101112131415161718192021# 由于字典无序，通常使用print()打印的结果与定义的顺序不同#定义xiaoming = &#123;"name": "小明", "age": 18, "height": 175&#125; xiaoming["name"] #取值xiaoming["weight"] = 70 #不存在则增加xiaoming["age"] = 19 #若存在则修改xiaoming.pop("weight") #删除len(xiaoming) #统计键值对数目temp_dict = &#123;"gender": boy, "age": 20&#125;xiaoming.update(temp_dict) #若新增key不存在，则增加;若key重复，则会替换掉之前的valuexiaoming.clear() #清空xiaoming. 遍历字典 123456my_dict = &#123;"name": "zhangsan", "age": "18"&#125; # 变量temp是my_dict中的keyfor temp in my_dict: print("%s - %s" % (temp,my_dict[temp])) 应用先用字典存储复杂数据，再将多个字典放在一个列表中管理 123456789card_list = [ &#123;"name": "zhangsan", "qq": "12345"&#125; &#123;"name": "lisi", "qq": "12412"&#125;]for info in card_list: print(info) 字符串12345678910111213141516171819202122232425262728# 字符串定义：使用''或""括起来的内容str1 = "hello"str2 = 'world' #为了和其他语言统一，尽量不使用单引号#当需要字符串中包含引号时str3 = "my name is "dgs"" #错误str4 = 'my name is "dgs"' #正确#取值str = "abcdefabcbac"str[2] #第三个字符str[-1] #倒数第一个字符#迭代遍历for temp in str: print(temp)len(str) #统计长度str.index(”e“) #获取索引str.count(”a“) #统计a出现的次数# 字符串切片 字符串[开始索引:结束索引:步长]，不包含结尾处索引的内容str[2:6] #截取第二个到第六个str[2:] #从第二个到末尾str[2:-1] #从第二个到倒数第一个str[:6] #从开头到第六个str[::2] #每隔一个截取一个str[-1::-1] #获得字符串倒序 公共方法 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式del(temp[1]) /del(temp) max(item) 返回容器元素最大值 字典只比较key min(item) 返回容器元素最小值 字典只比较key cmp(item1, item2) 比较两个值，-1 小于，0 等于，1 大于 python3取消了cmp 字符串比较遵循：0 &lt;A &lt;a 切片123l1 = [1, 2, 3, 4, 5][::2]t1 = ("s", 2, "hello", 4, 5)[::2]# 字典不能切片 运算符 运算符 演示 结果 描述 支持类型 + [1, 2]+[3, 4] [1, 2, 3, 4] 合并 字符串，列表，元组 * (“hi”)*3 (“hi”,”hi”,”hi”) 重复 同上 in 3 in (1, 2, 3) True 是否存在，字典判断key 字符串，列表，元组，字典 not in 4 not in (1, 2, 3) True 是否不存在，字典判断key 同上 &lt; &gt; 等 (1, 2, 3)&lt;(2, 3, 4) True 比较 字符串，列表，元组 + 与entend() 方法的区别：前者生成一个新的变量，后者追加到调用该方法的变量 append()与extend()区别 12345678l2 = [1, 2, 3]l2.append(4)print(l2)# 不能l2.extend(5)，extend()只能传入容器l2.append([6, 7])print(l2)l2.extend([8, 9])print(l2) 输出结果 123[1, 2, 3, 4][1, 2, 3, 4, [6, 7]] # 将append([6, 7])当成了一个元素[1, 2, 3, 4, [6, 7], 8, 9] # 将extend([8, 9])追加 完整的for循环1234for 变量 in 集合: 循环体代码else: 没有通过break退出循环，遍历结束后就会执行 应用遍历完成后，如果没有查询的就提示 其他 对变量使用自身的方法进行增删改不会改变id，而重新赋值会改变，这时它的指针指向了另一个地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的一些基础知识]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[python的运算符 与C,java等不同 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 and 与 a &gt;= 1 and a &lt;= 4 or 或 a &gt; 1 or a &lt; 10 not 非 not a &lt; 1 += -= *= /= %= //= **= 赋值运算 a+=1等同于a=a+1 查看关键字12import keywordprint(keyword.kwlist) 语法if123456if a==1: print("aaa")elif a==2: print("bbb")else: print("ccc") 条件分行1234# 使用()将条件括起来，在布尔运算符前可分行if((a == 1 and b == 2) or (a ==2 and b ==3)): print("test") while12while 条件: 执行代码 定义函数12345# 定义的函数要在使用前声明def 函数名(param1,param2): 封装代码 ... return res 注释12345678910111213141516# 单行注释"""这是多行注释"""# 在函数下方缩进后使用连续的三个'或“可以给函数编辑注释# 如果此时直接按回车会生成带参数描述的文档注释# 并且之后调用时可以使用Ctrl+Q快速查看def test(): '''this is a test example''' print("hello") # TODO(作者/邮件) 这是TODO注释，提醒接下来要做的工作，可以在pycharm左下角找到所有TODO项 print 数字和字符串输出 12age = 10print("you are %d" % age) 多个数字和字符串输出 1234num1 = 10num2 = 20num3 = 10.5print("the number is %d , %d and %f" % (num1,num2,num3)) #实际上这是元组的应用 %d是以十进制输出，可用%x以十六进制输出 使print不换行 123456# print()方法默认是在尾部添加了换行符，而如果不想换行可以加,end=""print("hello",end="")print("world")# 其他使用print("hellp",end="***") 连续输出相同内容 1print("*" * 50) #连续输出50个* 控制台输入1input("请输入：") 控制台输入的内容是字符串，如果需要用于判断，则 1a = int(input("请输入")) 生成随机数12import randomrandom.randint(10, 20) #生成10-20间的随机整数 导包 使用import关键字导入模块，所有以.py结尾的文件都可以看作一个模块 模块不能使用数字开头 pyc文件 当使用import导入模块并编译后，会在编译文件夹中生成.pyc文件，这是使用cpython编译出的二进制文件，使得每次使用模块不需要反复解释，以提高执行性能 跳过 如果写了判断或其他情况暂时不写某些代码时，可以使用pass 充当占位符，使编译器不报错 123456my_list = ["1", "2", "3"]num = input("please input:")if num in my_list: passelse: pass shebang符号 #! 是shebang符号，他后面加上解释器的路径即可在终端下通过输入文件地址而直接运行，且不影响在pycharm中运行1#! /usr/bin/python3 id id(变量/数据) 查看其内存地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一年--在武大智能车]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%BF%99%E4%B8%80%E5%B9%B4-%E5%9C%A8%E6%AD%A6%E5%A4%A7%E6%99%BA%E8%83%BD%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[此刻 坐在电脑前，也许应该点燃一支烟，吸一口，神清气爽，念天地之悠悠，吐一口，烟云缭绕，独怆然而涕下。于烟云之端，闭上双眼，追古溯今，回味这身于其中恨其长，蓦然回首已惘然的一年。 可是，我不会抽烟。 所以，我不能在烟云中幻想，只能在现实中回望。 回忆起来，尽管最终结果平平，但它仍旧不同以往，给大学生活添上了不寻常的一笔。 一 冬天的枝叶败落后，又在春天绿意盎然，如是想想，我也应该走出决赛失利的阴霾中，好好记录下这一年的高兴与惆怅，开怀与彷徨。 从大一的那个暑假走来，转眼一年多过去了，校内赛前能装实验室汗流夹背的景象回想起来，仿佛就在昨天，那个时候想必是这一年最难熬的吧。周围都是陌生的面孔，大家都为了入队而不断学习。两个月的时间里，很多人坚持不下去走了，但更多的坚持了下来，走过11月的校内赛，成功进入智能车这个大家庭。 那段时间应当感谢与我同行的两个同学，赵富强和雷飞，不如就合称赵雷吧，哈哈，感谢“赵雷“的陪伴，和赵雷的歌曲，陪我一步一步迈过那两个月的时光。 二 校内赛后，我选择了节能组，并负责软件部分，但由于组别的特殊性，我们组所有人都负责结构设计，华南赛前我花在结构设计上的时间甚至多于调试程序的时间。 也许那个时候方向真是错了，也因此，每次开会，我们组都是被点名的那个。 前后花了几个月，多方咨询，多次改稿，最终还真的设计出了一款机械能的车模。 然而，由于零件难以找到合适的，且直观感觉它并不会节省能量，最终在四月份刚拼起来就被舍弃，前功尽弃–想想有些可惜。 这样，我们开始专心搭纯电履带车，我专心负责程序编写。 之前只是大概写了个框架，没有几个月就要比赛了，那时候我有些慌了，尤其是在圆环的处理上，由于车身晃动太大和程序鲁棒性太差，总是出现各种问题，要不识别不到，要不识别过早，或者进去出不来，总之，问题百出。 即使是华南赛就要来临，即使我们天天熬夜，但成功率仍旧不高，那个时候甚至一度怀疑是否能挺过华南赛，是不是拿个华二就结束了… 然而，我也不敢大改程序，怕这一改便成仁了… 三 七月，空气中弥漫着潮湿的味道，智能车队整装出发。我们组内调侃：去旅个游就放假啦，好开心。 不过我心里其实还存有一丝侥幸，10多分钟，总能成功的吧。 试车：路障过不去，有些慌了 预赛：电感坏了，心想凉了，还好临时修好，一次成功 决赛：一次成功 结果如我所愿，成功狗过华南赛，还拿了个第二名的成绩，但可以看出来，不论结构和程序都很不稳定。 华南赛后合照 那几天的长沙天气不错，我们三五成群，晚上就出去逛街，喝过了网红饮品茶颜悦色，吃过了毛主席都爱吃的长沙臭豆腐，也算不虚此行。 和帅哥茶颜悦色打卡 哦，对了，张老师摔得那下有点惨0.0当时都吓到我们了 四 华南赛回来后，我决定重写程序，花了差不多十天左右的时间写完，调试。改完之后感觉良好，比之前的稳定很多，速度也从1.5提高到了1.68左右，用电池跑的时候，经常可以一次性跑五六圈都没有问题。 但是不知道为什么，每辆车刚搭出来表现不错，越跑就越变的不尽如人意了，只能降低速度，但我想这不应该是程序的问题，试了试其他样式的履带，结果一般，最终没有改动车体结构，也没有去深究这个问题。 剩下的二十天我调车的时间就下降了，和队里大部分人一样开始了养老生活。 转眼间，就从珞珈山下踏到了渤海之边。 五 我们走过了沙滩，趟过了海浪，挖过了拖鞋，埋过了雷飞…然而我只想问：海边为什么都是中年油腻大爷大妈，和我想象的不太一样啊… 我们在海滩 快乐的玩耍 比赛时，唉不想说了，一上场就发现和在实验室的差异了，实验室赛道较光滑，而威海的赛道摩擦力太大，以至于每次转弯车都要跳两下，出环岛时也不像在实验室那样顺滑，我在旁边胆战心惊。 而预赛的下午场和决赛，又出现了莫名其妙的问题，好几次在直道弯道处就撞上路障夭折了…这种情况在实验室从未出现过，还有一次刚到路障直接停车了，不明所以，事后我们组觉得可能是车硬件有问题，但那块板子自从按上以后我每天只是稍微跑跑，所以没有暴露出来，而当在国赛时显露出来，也来不及补救了。 于是最终拖了十四届的后腿，成为了唯一一个二等奖项。 嘤嘤嘤 … 总结 这一年无论结果如何，也伴着专老师的点拨，张老师的关怀，杨老师的鸡汤和整个车队的陪伴走过去了。这一年终将永久存留于每位十四届智能车队员的心中，并在未来珍藏，回味，历久弥新… 最后，盛年不重来，我们JinMaMen见吧！(滑稽)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2019%2F08%2F30%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法 标题123# 一级标题## 二级标题### 三级标题 n#+文字 n级标题 字体1234567**粗体***斜体*==高亮==***斜体加粗***~~删除线~~^上标^~下标~ 列表无序标题 使用”*”或者”+”后面跟空格，按一下回车会自动加标题，按两下会消失 eg： 12345- 一二三四五- 上山打老虎 - 下一级为空心圆 - 再下一级是实心方块 - 之后都是实心方块 效果 一二三四五 上山打老虎 下一级为空心圆 再下一级是实心方块 之后都是实心方块 有序标题与word类似 121. 一级2. 二级 效果 一级 二级 表格第二行要有连字符 123| 姓名 | 学号 | 专业 | 班级 ||------|------|------|------|| 张三 | 037 | 机械 | 四班 | 效果 姓名 学号 专业 班级 张三 037 机械 四班 引用12&gt; 大于号加引用内容&gt;&gt; 二级引用，可多级 效果 大于号加引用内容 二级引用，可多级 分割线使用连字符，上一行不能有字符 12345 上文------ 下文 效果 上文 下文 代码单行代码使用``将代码括起来 1`print("hello") ` 多行代码123System.out.println("hello");System.out.println("hello");System.out.println("hello"); 链接1234561. &lt;http://www.baidu.com&gt;2. [百度](http://www.baidu.com)3. 我经常用[百度][1]搜索，很少用[必应][2][1]:http://www.baidu.com/ &quot;Baidu&quot;[2]:http://www.bing.com/ &quot;Bing&quot; 效果 http://www.baidu.com 百度 我经常用百度搜索，很少用必应 图片1![狮子](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&amp;fm=26&amp;gp=0.jpg &quot;this is a lion&quot;) 百度地图 网址http://api.map.baidu.com/lbsapi/creatmap/index.html 注意要在html文件中加&lt;meta charset=&quot;UTF-8&quot;&gt;限定编码格式，否则可能乱码 1&lt;iframe src=&quot;~/Markdown/map.html&quot; width=&quot;600&quot; height=&quot;300&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; 百度地图API自定义地图 html,body{margin:0;padding:0;} .iw_poi_title {color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap} .iw_poi_content {font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word} L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":175,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"log":false}); //创建和初始化地图函数： function initMap(){ createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMarker();//向地图中添加marker addPolyline();//向地图中添加线 addRemark();//向地图中添加文字标注 } //创建地图函数： function createMap(){ var map = new BMap.Map("dituContent");//在百度地图容器中创建一个地图 var point = new BMap.Point(114.368076,30.543335);//定义一个中心点坐标 map.centerAndZoom(point,17);//设定地图的中心点和坐标并将地图显示在地图容器中 window.map = map;//将map变量存储在全局 } //地图事件设置函数： function setMapEvent(){ map.enableDragging();//启用地图拖拽事件，默认启用(可不写) map.enableScrollWheelZoom();//启用地图滚轮放大缩小 map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写) map.enableKeyboard();//启用键盘上下左右键移动地图 } //地图控件添加函数： function addMapControl(){ //向地图中添加缩放控件 var ctrl_nav = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE}); map.addControl(ctrl_nav); //向地图中添加缩略图控件 var ctrl_ove = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1}); map.addControl(ctrl_ove); //向地图中添加比例尺控件 var ctrl_sca = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT}); map.addControl(ctrl_sca); } //标注点数组 var markerArr = [{title:"终点",content:"come",point:"114.371444|30.545357",isOpen:1,icon:{w:21,h:21,l:46,t:46,x:1,lb:10}} ]; //创建marker function addMarker(){ for(var i=0;i]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F08%2F30%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git版本创建 1234git init //初始化git仓库git add . //添加全部修改git add 文件名 //添加指定文件的修改git commit -m "说明信息" //提交并添加备注 查看信息1git log //查看版本信息 1git status //查看修改信息 版本回退 HEAD指针会指向最新的版本 HEAD^指向上一个版本 HEAD^^指向上上个版本… 或者使用HEAD~n代表前n个版本 12git reset --hard HEAD^ //回退到上一个版本git reset --hard HEAD~3 //回退到之前3个版本]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git快速入门]]></title>
    <url>%2F2019%2F08%2F29%2Fgit%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git init 将当前文件下变为git仓库 git status 查看git仓库的状态 git add 12git add 文件 #添加指定文件的修改git add . #添加所有文件的修改 git diff 显示文件修改信息 git reset 退回追踪 git config 1234git config --global user.name "zhangsan" #配置用户名git config --global user.email "example@qq.com" #配置邮箱git config --global core.editor vim #配置默认编辑器git config credential.helper store #在执行`push`前输入这段命令，会使git记住用户名和密码，之后就不用再输入 git commit 12git commit #会打开编辑器，可输入描述信息git commit -m "some text" #提交更改并添加描述信息 让git忽略管理某些文件 1vim .gitignore #创建此文件，并在其中编辑要忽略的文件名即可 在该列表中添加的文件必须是从未被追踪过的，否则git将继续追踪该文件 git rm 1git rm --cached 文件 #让git停止追踪该文件 分支 123456git branch #显示分支列表git branch test #创建一个名为test的分支git checkout test #切换到test分支git merge test #将test分支添加到mastergit branch -d test #删除test分支，未添加的分支不可删除git branch -D test #强制删除test分支 推到github 首先去github创建一个新的仓库，并复制链接，假设为https://.../abc.git 12git remote add origin https://.../abc.git #告诉git你在网上的仓库位置git push --set-upstream origin master #将master提交到github（需要输入用户名和密码） 发送合作邀请 在github的仓库中setting–&gt;Collaborators–&gt;搜索用户–&gt;点击发送邀请至邮箱 复制文件 1git clone https://.../abc.git #复制仓库至本地，`.gitignore`中的文件不会被下载 git pull将github上更改过的文件下载到本地]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端指令]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[some tips Tab can auto compelete command Ctrl+c can stop the command or clear your input(终止命令或清空刚才的输入–命令较长时backspace太慢) the command formatcommand [-options] [parameter] instructions command: command name [-options]: control the command, it can be omited [parameter]: maybe only one, or two, or three… []: means optional basic command command word function ls list view the contents of the current folder pwd print work directory view current position cd [directory] change directory move to the specified directory touch [file name] touch create new file(s) mkdir [directory] make directory create new directory rm [file name] remove remove empty file(s) clear clear clean the screen view help information command --help man command(means manual) files and directory commands hidden files if the file begin with a dot . it is a hidden file . and.. . means this level directory.. means upper level directory ls options word function -a all display all files(including hidden files) -l list list display files (first letter isd:dir; -: file) -h display file size(Kb), it must be used with -l (ls -lh) wildcard character(通配符) symbol meaning * represents any number of characters(任意个数字符) ？ represents one character [] give some choices examples * ls a* display files begin with als *a.txt display files end with a.txtls *a* display files contains a ** ? ls ?a?.txt display files like 1a1.txt ** [] ls [abcde]ab.txt display files like aab.txt orbab.txt and so onls [a-f]ab.txt display files begin with abcdef like eab.txt cd absolute path specific path from the root directory or home directory(从根目录或家目录开始的具体路径)example:/home/duguosheng/Desktop/ relative path the path from current directory examples:../Desktop/ command function cd go back to the current user home directory cd ~ just likecd cd . keep in the current directory cd .. go to the parent directory cd - switch back and forth between the last two directory touch (file)if the file doesn’t exist, the file will be createdotherwise, the last modification time of the file will be modified(否则会更改文件的末次修改时间) mkdircreate a new file mkdir -p a/b/c/d recursively create directories(递归创建目录) the directory name can’t be same as existing file or directory rm delete file or directory (can not be restore)(不可恢复) option function -r recursively delete directory(递归删除目录) -f forced deletion(强制删除) copy and move files or directoriestree [directory]display directories and files in a tree view tree ~ display files form home directory tree -d only display directories cp cp src dest copy file example: cp ~/Documents/test.txt . copy test.txt to current directory,if you want to change file name, you can writecp ~/a.txt ./b.txt option function -i promat before overwritting files(覆盖文件前提示) -r copy directory mvmove file or directory format: mv src dest example:mv test ~/Documents/ move test to Documents/ change file or directory name if src and dest are under the same directory, then it can be renamed overwrite file iftest1.txtandtest2have been existed, then input cp test1.txt test2.txt, after that, test1.txt will be renamed astest2.txt and original filetest2.txt will be deleted, this operation is unsafe cp -i src dest prompt before overwriting files view file contentcat(concatenate连接合并)format: cat (file) view all content of the file option function -b show line number(except blank lines) -n show line number(including blank lines) moreformat: more (file) view the beginning of the file operation function display next page display next row b go back f go forward q quit grepa text search tool(文本搜索工具) option function -n show line number(行号) -v show lines which don’t match(不匹配的所有行) -i ignore case(忽略大小写) example: grep as test.txt look for the letter as in the test.txt grep -n as test.txt look for the letter as in the test.txt and show the line number grep -v as test.txt look for lines that don’t contain the letter as in the test.txt param function ^a look for lines start with the letter a ke$ looke for lines end with ke other commandecho (some words) the words will show in the terminal, it is always used with redirect command echo hello &gt; a if a doesn’t exist, a will be created, and write hello inside file.(创建文件并指定内容) redirect &gt;and&gt;&gt; linux allows to redirect command execution results to a file(linux允许将命令执行结果重定向到一个文件) output/append the content that should be displayed on the terminal to the specified file(将本应显示在终端的内容输出/追加到文件中) &gt;: output, overwrite the file &gt;&gt;: append, append content to the file examples: echo helloworld &gt; a.txt echo ls -lh &gt; a.txt write the file list and their information to a.txt echo goodbye &gt;&gt; a.txt pipe | (管道) the output of a command can be input to another with pipe(一个命令的输出可以通过管道作为另一个命令的输入) | divides commands into left and right, left to write, right to read common commands more: spilt screen display content grep: search for the specified content in the command execution result(在命令执行结果中搜索指定内容) example: ls -lha ~ | more spilt screen view files and directories ls -lha ~ | grep aa display files with letter aa in its name shutdown/restartshutdown shutdown command can safely shut down or restart the system option function -r restart if the command has no options and parameters, it will turn off after 1 minute by default(默认一分钟后关机)when remotely maintaining the serve, you’d better restart rather than shut down. examples: shutdown -r now –&gt;restart now shut down now –&gt;shut down now shutdown 20:30 –&gt;shut down at 8:30pm shutdown +10 –&gt;shut down 10 minutes later shutdown -c –&gt;cancel last command with shutdown view and configure network card information(查看和配置网卡信息) command word function ifconfig configure a network interface view/configure the network card information ping (ip address) ping check the connection with target IP address is normal or not ifconfig in manjaro, use command ip addr instead of ifconfig a computer may have a physical network card and multiple virtual network cards (一台计算机中可能有一个物理网卡和多个虚拟网卡) view ip address: ifconfig | grep inet (ip addr | grep inet in mangaro ) ping ping (IP) ‘s working principle just like sonar(声纳), it sends out a packet, and the target IP addr returns a packet, the shorter the time, the faster the network speed(指令发出数据包，目标IP收到后返回一个数据包，这段时间越短，则网速越快) ping (IP) can check the target computer is open or not Romote login and copy files(远程登录和复制文件)Basics of SSH Based on the SSH Client and SSH Serve SSH Client is a software program connected to a remote computer with protocol Secure Shell(SSH) (SSH客户端是一种使用SSH协议连接到远程计算机的软件程序) Transmitted data is Encrypted(加密) –Prevent information from being leaked Compressed(压缩) –Increase transmission speed Port number(端口号) and Domain name(域名) Port number: IP address: just like 172.168.12.13 use it can find computer on internet Port number: can find application running on the computer SSH Client default port number is 22, if it’s default port number, you can omit the port number when connecting(默认端口号连接时可以省略) services port number SSH Serve 22 Web Serve 80 HTTPS 443 FTP Serve 21 Domain name: just like www.baidu.com , it use aliases for easy memory(使用别名，方便记忆) As shown in figure, www.baidu.com is 180.97.33.107 aliases, if you type 180.97.33.107 in the browser, also can visit Baidu Also, you can input 180.97.33.107:80 to visit Baidu, IP addr180.97.33.107 to find the computer, and port number 80 to find its application program (web serve) SSH Serve format:ssh [-p port] user@romote user default current user romote IP addr, Alias Or Domain name of remote computer port the port of SSH Serve to listen, default22 exp: ssh -p 22 duguosheng@172.16.140.138 Tips: exit: Log out of the current user(退出当前账户登录) Linux and Mac can use SSH without doing anything, but in Windows, you have to install some software for free Putty XShell scp scp is secure copy, it be used to remote copy file example: If the path after: isn’t an absolute path, the user’s home directory is used as the reference path(: 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径) copy 01.py from your local current directory toDesktop/01.py in your remote home directory(把本地当前目录下的 01.py 文件复制到远程家目录下的 Desktop/01.py) scp -P port 01.py user@remote:Desktop/01.py P is capital(大写) scp -P 22 01.py duguosheng@172.16.139.122:Desktop/ &lt;++&gt; copy Desktop/01.py from remote home directory to 01.py in local current directory scp -P port user@remote:Desktop/01.py 01.py use -r can copy directory demo under current local dir –&gt; remote Desktop/ scp -r demo user@remote:Desktop scp -P 22 -r demo duguosheng@212.134.23.123:Desktop/ Desktop under remote home dir –&gt; demo/ in local current dir scp -r user user@remote:Desktop demo Attention: scp only can use in linux or unix in Windows, you can install Putty, use pscp OR install FileZilla, use FTP FTP use Ftp instead of Ssh, so its port number is 21 SSH advanced All SSH ci=onfiguration information is stroed in the /home/user/.ssh Password free login(免密码登录) Steps: Configure the public key(配置公钥) Execute ssh-keygen to generate a public key(生成公钥), you can see id_rsa(private key) and id_rsa.pub(public key) under ~/.ssh/ upload public key to Serve Execute ssh-copy-id -p port user@remote can let the Serve remember our pulic key, in fact, this command copy id_rsa.pub to Serve’s ~/.ssh/ Asymmetric encryption algorithm(非对称加密算法) Data encrypted using the public key needs to be decrypted using the private key(使用公钥加密的数据，需要使用私钥解密) Data encrypted using the private key needs to be decrypted using the public key(使用私钥加密的数据，需要使用公钥解密) Configure an alias Steps: cd ~/.ssh/ touch config vi config edit config for example, ssh -p 22 example@100.100.100.100 can be changed to ssh exp by edit config like this Also, you can use scp -r ~/Desktop exp:Desktop/demo to copy a directory Commands about User Premissions(用户权限)User and Premission In Linux, you can specify different permissions for different files or directories for each user the permissions contains: permission abbreviation number read r 4 write w 2 executive x 1 ls -l extended execute ls -lh get some infomation like this dor- rwx r-x r– 2 duguosheng duguosheng 4.0K Aug 2 23:04 桌面/ d directory - file user permission group permission other people permission Number of hard links user name group name size last version time file or directory name Number of hard links(硬链接数) how many ways to access the current directory/file if it is a file, the number is 1, through the path if it is a directory without subdirectories(没有子目录), the number is 2, through the path orcd . if it is a directory with n subdirectories(有n个子目录), the number is 2+n, through the path, cd . or cd .. chmod chmod can change permission of user/group format: chmod +/- rwx fileName/dirName this usage will permission of both change user and group sudo su is substitute user, default is root Group To facilitate user management, you can group users and then assign permissions to groups(分组，为组分配权限) command function groupadd (name) add a group groupdel (name) delete a group cat /etc/group view group chgrp -R (group_name) (dir) change the group to which the dir belongs User managementcreate/delete user And change password command function tips useraddd -m -g (groupName) (userName) add a user -m auto create home directory, -g specify user’s group, otherwise a group with the same name as the user will be created passwd (user) set user’s password normal user can set set password by passwd userdel -r (user) delete user -r will delete user’s home dir if you foget to add -m, you can delete user and recreate it the user information is stored in the /etc/passwd view user information command function id (user) view uid and gid who View a list of all currently logged in users(查看当前所有登录的用户列表) whoami view current user id duguosheng cat -n /etc/passwd cat -n /etc/group duguosheng x 1000 1000 duguosheng /home/duguosheng /usr/bin/fish user encrypted password user id group id group home dir shell usermod usermod can be used to set the user’s primary/additional group and login shell(设置主组/附加组，和登录shell) command function usermod -g (group) (user) change user’s primary group usermod -G (group) (user) change user’s additional group usermod -s /bin/bash (user) change user’s shell Users added by default with useradd do not have permission to use sudo to execute commands as root. Users can be added to sudo additional groups by using the following commands(默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中)usermod -G sudo (user) whichwhich (command) see the path of command which ls result: /bin/ls bin and sbin change user command func su change to root(not safe) su (user) change user su - (user) change user and go his home dir exit log out Modify File Permissions(修改文件权限) command func chown (user) (file/dir) change ower chgrp -R (user) (file/dir) change group chmod -R 755 (file/dir) change permission systemtime command func date view system time cal view calendar cal -y view calendar of a year disk information(磁盘信息) command word func df -h disk free show free space of disk(剩余空间) du -h [dir] disk usage display the file size in the dir(目录下的文件大小) process information(进程信息) command word func ps (aux) process status view process top Display running processes dynamically and sort them(动态显示运行中的进程并且排序) kill [-9] (process) process can be a name or its pid, stop the process, -9 :force to stop option of ps a :Display all processes on the terminal, including those of other users(显示终端上的所有进程，包括其他用户的进程) u :display details of process x :Display processes without control terminals(显示没有控制终端的进程) Other commandfind format: find [path] -name &quot;*.png&quot; if no path, default in current directory Softlink(软链接) format: ln -s src destfile use absolute path, don’t use relative path Hardlink(硬链接) format: ln src destfile Packing and Compression(打包压缩)Pack/unpack(打包/解包) different OS has different mode of pack and compression windows : rar mac : zip linux : tar tar can pack a series of files into a large file or restore a packaged large file into a series of files(此命令可以把一系列文件打包到 一个大文件中，也可以把一个打包的大文件恢复成一系列文件) command func tar -cvf 打包文件.tar 被打包文件/路径… pack tar -xvf 打包文件.tar unpack options of tar option func c 生成档案文件，创建打包文件 x 解开档案文件 v 列出详细过程，显示进度 f 指定档案文件，f后面一定是.tar文件，所以必须放选项最后 attention: f 必须放在选项最后，其他随意tar 只负责打包，不负责压缩 compression/decompression(压缩/解压)gzip tar 与gzip 结合可实现打包压缩 用gzip 压缩tar 打包后的文件，扩展名一般用xxx.tar.gz 在tar 命令中，有一个-z 选项可以调用gzip 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...# 解压缩tar -zxvf 打包文件.tar.gz# 解压缩到指定路径,该指定路径必须已存在tar -zxvf 打包文件.tar.gz -C 指定路径 bzip2 tar 与bzip2 结合可实现打包压缩 用bzip2 压缩tar 打包后的文件，扩展名一般用xxx.tar.bz2 在tar 命令中，有一个-j 选项可以调用bzip2 12345678# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径...# 解压缩tar -jxvf 打包文件.tar.bz2# 解压缩到指定路径,该指定路径必须已存在tar -jxvf 打包文件.tar.bz2 -C 指定路径]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux包管理工具pacman]]></title>
    <url>%2F2019%2F08%2F29%2Farchlinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pacman%2F</url>
    <content type="text"><![CDATA[pacman的基本命令分为三大类S,R,Q command with S (means synchronized&lt;同步的&gt;) command function example sudo pacman -S (some apps) install software sudo pacman -S vlc sudo pacman -Sy only synchronize source(仅同步源) sudo pacman -Syy force to refresh for updates(强制刷新一遍更新信息) sudo pacman -Su update the system sudo pacman -Syu synchronize source and update sudo pacman -Syyu force to refresh imformation for updates and update system sudo pacman -Ss (some apps) search for the software from internet sudo pacman -Ss vim sudo pacman -Sc delete software installation packages command with R (means remove) command function example sudo pacman -R (app) delete the software sudo pacman -R vim sudo pacman -Rs (app) delete the software and the packages it rely on(删除软件及其依赖的包) sudo pacman -Rs vim *sudo pacman -Rns (app) delete software, packages, and global profile sudo pacman -Rns vim command with Q (means query&lt;查询&gt;) command function example sudo pacman -Q list all softwares be installed sudo pacman -Qe list the software have been installed by user sudo pacman -Q &#124; wc -l show total number of softwares sudo pacman -Qe &#124; wc -l show number of personal softwares sudo pacman -Qeq list pesonal softwares without version sudo pacman -Qs (app) query the softwares which contains letters sudo pacman -Qs vim sudo pacman -Qdt query unrequired packages sudo pacman -Qdtq query unrequired packages(不需要的包) combination commands command function example sudo pacman -R $(pacman -Qdtq) delete unrequired packages]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pacman</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端下文件管理器Ranger使用]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8Ranger%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[选择/打开文件 命令 功能 left或h 上一级 right或l 下一级/打开文件 up或k 上一个 down或j 下一个 gg 最上方 G 最下方 r 选择打开方式 [ 移动至上一个父文件夹 ] 移动至下一个父文件夹 H 退回上一个位置 L 撤销退回 &lt;Space&gt; 选择该文件，可多选 v 反转选择 V 进入可视模式，结合移动键进行选择 打开文件默认使用nano或者gedit，如果想要修改， 查看默认编辑器 1echo $EDITOR 修改默认编辑器(如改为vim) 如果使用bash 1export EDITOR="/usr/bin/vim" 如果使用fish 1set -g -x EDITOR "/usr/bin/vim" 复制粘贴 命令 功能 y 按照提示选择复制的内容，如文件，文件路径等 yy 复制一个文件 p 按照提示招贴 pp 复制刚才粘贴的，不覆盖 po 复制并覆盖重名文件 dd 剪切 dD 删除 dU 查看文件大小 复制一个很大的文件进行粘贴时，可使用w进入进度管理 在进度管理中，dd取消当前任务 其他操作 命令 功能 /搜索内容 查找文件,n下一个,N上一个 f 搜索内容 查找文件，并直接指向该文件 zh / &lt;BackSpace&gt; / &lt;C-h&gt; 显示/隐藏隐藏文件 cw / a / i / A / I 重命名文件 o 按照提示选择排序方式 生成Ranger配置文件 在终端下执行 1ranger --copy-config=all 就会在.config/ranger/下看到相关配置文件，更多配置信息可以去ranger的github下的wiki栏目下查看]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
</search>
