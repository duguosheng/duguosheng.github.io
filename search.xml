<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gdb调试</title>
    <url>/2019/11/06/gdb%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>set args</td>
<td></td>
<td>设置主程序的参数</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点,<code>b 20</code>表示在第20行设置断点,可设置多个断点</td>
</tr>
<tr>
<td>run</td>
<td>r</td>
<td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>执行当前行语句，如果该语句为函数调用，则进入函数(必须有源码)执行其中的第一条语句</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>显示变量值，例如：p name表示显示变量name的值</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续程序的运行，直到遇到下一个断点。</td>
</tr>
<tr>
<td>set varname=v</td>
<td></td>
<td>设置变量varname的值为v,字符串也用=,而不是strcpy</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出gdb</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言编译预处理</title>
    <url>/2019/11/06/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>C语言由源代码生成可执行程序的过程如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中编译预处理阶段，读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p>
<p>预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。</p>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>在C语言的程序中可包括各种以符号#开头的编译指令，这些指令称为预处理命令。预处理命令属于C语言编译器，而不是C语言的组成部分。通过预处理命令可扩展C语言程序设计的环境。</p>
<p>预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p>
<ul>
<li>预处理指令主要有以下三种：</li>
</ul>
<ul>
<li><input disabled type="checkbox"> 包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。</li>
<li><input disabled type="checkbox"> 宏定义指令：#define 指令定义一个宏，#undef指令删除一个宏定义。</li>
<li><input disabled type="checkbox"> 条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。</li>
</ul>
<h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p>当一个C语言程序由多个文件模块组成时，主模块中一般包含main函数和一些当前程序专用的函数。程序从main函数开始执行，在执行过程中，可调用当前文件中的函数，也可调用其他文件模块中的函数。</p>
<p>如果在模块中要调用其他文件模块中的函数，首先必须在主模块中声明该函数原型。一般都是采用文件包含的方法，包含其他文件模块的头文件。</p>
<p>文件包含中指定的文件名即可以用引号括起来，也可以用尖括号括起来，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"文件名"</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件。</p>
<p>因为C语言的标准头文件都存放在include文件夹中，所以一般对标准头文件采用尖括号；对编程自己编写的文件，则使用双引号。</p>
<p>如果自己编写的文件不是存放在当前工作文件夹，可以在#include命令后面加在路径。</p>
<p><code>#include</code>命令的作用是把指定的文件模块内容插入到#include所在的位置，当程序编译链接时，系统会把所有#include指定的文件链接生成可执行代码。文件包含必须以#开头，表示这是编译预处理命令，行尾不能用分号结束。</p>
<p><code>#include</code>所包含的文件，其扩展名可以是“.c”,表示包含普通C语言源程序。也可以是 “.h”,表示C语言程序的头文件。C语言系统中大量的定义与声明是以头文件形式提供的。</p>
<h3 id="宏定义指令"><a href="#宏定义指令" class="headerlink" title="宏定义指令"></a>宏定义指令</h3><p>使用#define命令并不是真正的定义符号常量，而是定义一个可以替换的宏。被定义为宏的标识符称为“宏名”。在编译预处理过程时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p>
<p>在C语言中，宏分为有参数和无参数两种。</p>
<h4 id="无参数的宏"><a href="#无参数的宏" class="headerlink" title="无参数的宏"></a>无参数的宏</h4><p>其定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名  字符串</span></span><br></pre></td></tr></table></figure>

<p>在以上宏定义语句中，各部分的含义如下：</p>
<blockquote>
<p><code>#</code>表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。<br>define 关键字“define”为宏定义命令。<br>宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。<br>字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</p>
</blockquote>
<p>注意：预处理命令语句后面一般不会添加分号，如果在#define最后有分号，在宏替换时分号也将替换到源代码中去。在宏名和字符串之间可以有任意个空格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例（pre1.c）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行预编译指令<code>gcc -E -o pre1.E pre1.c</code>，得到预处理<code>pre1.E</code>文件，如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre1.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, <span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见<code>PI</code>被替换为了3.14</p>
</blockquote>
<ul>
<li>在使用宏定义时，还需要注意以下几点：</li>
</ul>
<p>宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。</p>
<p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。</p>
<p>习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。</p>
<h4 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h4><p><code>#define</code>命令定义宏时，还可以为宏设置参数。与函数中的参数类似，在宏定义中的参数为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，还要用实参去代换形参。</p>
<p>带参宏定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(形参表) 字符串</span></span><br></pre></td></tr></table></figure>

<p>在定义带参数的宏时，宏名和形参表之间不能有空格出现，否则，就将宏定义成为无参数形式，而导致程序出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y)  ((x)&gt;(y)?(x):(y))</span></span><br></pre></td></tr></table></figure>

<p>以上的宏定义中，如果x的值大于y，得到x，否则得到y。</p>
<ul>
<li>示例（pre2.c）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a&gt;b)?a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, MAX(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>运行gcc -E -o pre2.E pre2.c并查看</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre2.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, ((<span class="number">5</span>&gt;<span class="number">6</span>)?<span class="number">5</span>:<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带参的宏和带参的函数相似，但其本质是不同的。使用带参宏时，在预处理时将程序源代码替换到相应的位置，编译时得到完整的目标代码，而不进行函数调用，因此程序执行效率要高些。而函数调用只需要编译一次函数，代码量较少，一般情况下，对于简单的功能，可使用宏替换的形式来使用。</p>
<p>带参数的宏不容易理解，所以，在实际开发中，我不建议使用带参数的宏。</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>条件编译有多种格式，在这里我只介绍最常用的两种格式#ifdef和#ifndef。</p>
<h4 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a>#ifdef</h4><ul>
<li>#ifdef命令的使用格式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">    程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其意义是，如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”。</p>
<ul>
<li><p>示例（pre3.c）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINUX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LINUX</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是linux操作系统\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他操作系统\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行预编译指令gcc -E -o pre3.E pre3.c，得到pre3.E文件，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre3.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是linux操作系统\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h4><p>而#ifndef的意义与#ifdef相反，其格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">    程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其意义是，如果未定义标识符，则编译“程序段1”；否则编译“程序段2”</p>
<p>在实际开发中，程序员用#ifndef来防止头文件被重复包含。</p>
<p>打开<code>/usr/include/stdio.h</code>，第一条有效行的代码是<code>#ifndef _STDIO_H</code>，接下来是<code>#define _STDIO_H 1</code>，最后一行是<code>#endif</code>。</p>
<p>程序员自定义的头文件，我们也会这么写，如：</p>
<p>如果头文件被包含多次，就表示头文件中的函数被多次声明，全局变量被多次定义，在以前的C语言编译器中，这是不允许的，编译时会报错，但是，现在的部分编译器比较智能，多次定义全局变量或多次声明函数也不会报错。这些新的特征让我这个老家伙很不适应。</p>
<h4 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h4><p><code>#undef</code>取消已定义的标识符。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言系统错误信息</title>
    <url>/2019/11/05/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437350" target="_blank" rel="noopener">原文链接</a></p>
<p>为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。</p>
<p>配合 strerror和perror两个库函数，还可以很方便地查看出错的详细信息。</p>
<h3 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h3><ul>
<li>strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。</li>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errno)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数说明：strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。<br>返回值：返回描述错误原因的字符串地址。<br>在gcc4.4.7版本中，定义了130多个错误代码，我们用程序把它们全部显示出来。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> errorno;</span><br><span class="line">    <span class="keyword">for</span>(errorno=<span class="number">0</span>; errorno&lt;<span class="number">150</span>; errorno++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d--&gt;%s\n"</span>, errorno, strerror(errorno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出结果<br><img src="e1.png" alt="错误信息"> <img src="e2.png" alt="错误信息"></p>
</blockquote>
<p>一共有130多个错误代码和描述，上面的截图只显示了前5条和最后5条。这些错误代码和描述看一下就行了，不需要记住。</p>
<h3 id="perror-在-lt-stdio-h-gt-中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。"><a href="#perror-在-lt-stdio-h-gt-中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。" class="headerlink" title="perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。"></a>perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这个文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>(remove(<span class="string">"/abcd/efg.txt"</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"删除文件失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="e3.png" alt="运行"></p>
</blockquote>
<h3 id="errno的细节"><a href="#errno的细节" class="headerlink" title="errno的细节"></a>errno的细节</h3><ul>
<li>调用库函数失败不一定会设置errno<br>如果库函数调用失败，库函数会设置errno的值，程序员通过 errno 的值来判断出错的具体原因，但是，并不是全部的库函数在调用失败时都会设置errno的值，那么，哪些库函数会设置errno的值呢，要看函数的说明，例如fopen函数，在命令行下输入man fopen，在诸多的文字中，有以下行说明文字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The fopen() function may also fail and set errno for any of the errors specified for the routine open(2).</span><br></pre></td></tr></table></figure>

<p>不属于系统调用的函数不会设置errno，属于系统调用的函数才会设置errno。</p>
<ul>
<li><p>errno不能作为调用库函数失败的标志<br>在 C 语言中，如果库函数被正确地执行，那么 errno 的值不会被清零。换句话说，errno 的值只有在一个库函数调用发生错误时才会被设置，当库函数调用成功运行时，errno 的值不会被修改，当然也不会主动被置为 0。也正因为如此，在实际编程中，判断函数执行是否成功还得靠函数的返回值，只有在返回值是失败的情况下，才需要关注errno的值。</p>
</li>
<li><p>程序员可以不用errno<br>关注errno的目的是为了获取更详细错误信息，这些错误信息对程序员诊断程序可能会有帮助，但不是必须的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>错误信息</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言目录操作补充</title>
    <url>/2019/11/05/C%E8%AF%AD%E8%A8%80%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437217" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="access库函数"><a href="#access库函数" class="headerlink" title="access库函数"></a>access库函数</h3><blockquote>
<p>access函数用于判断当前操作系统用户对文件或目录的存取权限。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<br>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。<br>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK 2    <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回值：<br>当pathname满足mode的条件时候返回0，不满足返回-1。<br>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p>
<h3 id="stat库函数"><a href="#stat库函数" class="headerlink" title="stat库函数"></a>stat库函数</h3><h4 id="stat结构体"><a href="#stat结构体" class="headerlink" title="stat结构体"></a>stat结构体</h4><p>struct stat结构体用于存放文件和目录的状态信息，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev;   <span class="comment">// device 文件的设备编号</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino;   <span class="comment">// inode 文件的i-node</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode;   <span class="comment">// protection 文件的类型和存取的权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;   <span class="comment">// number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;   <span class="comment">// user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;   <span class="comment">// group ID of owner 文件所有者的组识别码</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;  <span class="comment">// device type 若此文件为设备文件, 则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;  <span class="comment">// total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;  <span class="comment">// blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;  <span class="comment">// number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime;  <span class="comment">// time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime;  <span class="comment">// time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime;  <span class="comment">// time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>struct stat结构体的成员变量比较多，对程序员来说，重点关注st_mode、st_size和st_mtime成员就可以了。注意st_mtime是一个整数表达的时间，需要程序员自己写代码转换格式。<br>st_mode成员的取值很多，或者使用如下两个宏来判断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_ISREG (st_mode) 是否为一般文件</span><br><span class="line">S_ISDIR (st_mode) 是否为目录</span><br></pre></td></tr></table></figure>

<h4 id="stat库函数-1"><a href="#stat库函数-1" class="headerlink" title="stat库函数"></a>stat库函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p>stat函数获取path指定文件或目录的信息，并将信息保存到结构体buf中，执行成功返回0，失败返回-1。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(access(argv[<span class="number">1</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件或目录%s不存在"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st_stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态信息</span></span><br><span class="line">    <span class="keyword">if</span>(stat(argv[<span class="number">1</span>], &amp;st_stat) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(st_stat.st_mode))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s是一个文件\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(st_stat.st_mode))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s是一个目录\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件名%s\n类型%d\n最终修改时间%ld\n大小%ld\n"</span> ,\</span><br><span class="line">            argv[<span class="number">1</span>], st_stat.st_mode, st_stat.st_mtime, st_stat.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>运行结果<br><img src="d1.png" alt="结果"></p>
</blockquote>
<h3 id="utime库函数"><a href="#utime库函数" class="headerlink" title="utime库函数"></a>utime库函数</h3><p>utime函数用于修改文件的存取时间和更改时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：utime()用来修改参数filename 文件所属的inode 存取时间。如果参数times为空指针(NULL), 则该文件的存取时间和更改时间全部会设为目前时间。结构utimbuf 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> actime;</span><br><span class="line">    <span class="keyword">time_t</span> modtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值：执行成功则返回0，失败返回-1。</p>
<h3 id="rename库函数"><a href="#rename库函数" class="headerlink" title="rename库函数"></a>rename库函数</h3><p>rename函数用于重命名文件或目录，相当于操作系统的mv命令，对程序员来说，在程序中极少重命名目录，但重命名文件是经常用到的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rename(<span class="string">"/home/user/aaa.txt"</span>, <span class="string">"/home/user/aaa_new.txt"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数说明：<br>oldpath 文件或目录的原名。<br>newpath 文件或目录的新的名称。<br>返回值：0-成功，-1-失败。</p>
<h3 id="remove库函数"><a href="#remove库函数" class="headerlink" title="remove库函数"></a>remove库函数</h3><p>remove函数用于删除文件或目录，相当于操作系统的rm命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：<br>pathname 待删除的文件或目录名。<br>返回值：0-成功，-1-失败。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>目录操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言时间操作</title>
    <url>/2019/11/04/C%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437007" target="_blank" rel="noopener">原文连接</a></p>
<h3 id="time-t别名"><a href="#time-t别名" class="headerlink" title="time_t别名"></a>time_t别名</h3><p>在C语言中，用time_t来表示时间数据类型，它是一个long（长整数）类型的别名，在time.h文件中定义，表示一个日历时间，是从1970年1月1日0时0分0秒到现在的秒数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出time_t其实是一个长整型。</p>
<h3 id="time库函数"><a href="#time库函数" class="headerlink" title="time库函数"></a>time库函数</h3><p>time函数的用途是返回一个值，也就是从1970年1月1日0时0分0秒到现在的秒数。<br>time函数是C语言标准库中的函数，在time.h文件中声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t);</span><br></pre></td></tr></table></figure>

<ul>
<li>time函数有两种调用方法：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> tnow;</span><br><span class="line">tnow =time(<span class="number">0</span>);     <span class="comment">// 将空地址传递给time函数，并将time返回值赋给变量tnow</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">time(&amp;tnow);       <span class="comment">// 将变量tnow的地址作为参数传递给time函数</span></span><br></pre></td></tr></table></figure>

<p>各位可以写代码测试一下这两种方式，效果完全相同。</p>
<h3 id="tm结构体"><a href="#tm结构体" class="headerlink" title="tm结构体"></a>tm结构体</h3><p>time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">int</span> tm_sec;     <span class="comment">/* 秒 – 取值区间为[0,59]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_min;    <span class="comment">/* 分 - 取值区间为[0,59]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_hour;   <span class="comment">/* 时 - 取值区间为[0,23] */</span></span><br><span class="line">       <span class="keyword">int</span> tm_mday;  <span class="comment">/* 一个月中的日期 - 取值区间为[1,31]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_mon;   <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_year;   <span class="comment">/* 年份，其值等于实际年份减去1900  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_wday;   <span class="comment">/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span><br><span class="line">       <span class="keyword">int</span> tm_yday;   <span class="comment">/* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</span></span><br><span class="line">       <span class="keyword">int</span> tm_isdst;   <span class="comment">/* 夏令时标识符，该字段意义不大，我们不用夏令时。 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个结构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。用这个结构体可以很方便的显示时间。</p>
</blockquote>
<h3 id="localtime库函数"><a href="#localtime库函数" class="headerlink" title="localtime库函数"></a>localtime库函数</h3><p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间，函数返回struct tm结构体的地址。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm * <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>struct tm结构体包含了时间的各要素，但还不是我们习惯的时间表达方式，我们可以用格式化输出printf、sprintf或fprintf等函数，把struct tm结构体转换为我们想要的结果。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">st_tm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> tnow, tnow1;</span><br><span class="line">    tnow = time(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now=%ld\n"</span>, tnow);</span><br><span class="line">    st_tm = localtime(&amp;tnow);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d年%d月%d日 星期%d %02d:%02d:%02d\n"</span>, \</span><br><span class="line">            st_tm-&gt;tm_year+<span class="number">1900</span>, st_tm-&gt;tm_mon+<span class="number">1</span>, st_tm-&gt;tm_mday, \</span><br><span class="line">            st_tm-&gt;tm_wday, st_tm-&gt;tm_hour, st_tm-&gt;tm_min, st_tm-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>输出结果<br><img src="t1.png" alt="结果"></p>
</blockquote>
<h3 id="mktime库函数"><a href="#mktime库函数" class="headerlink" title="mktime库函数"></a>mktime库函数</h3><p>mktime函数的功能与localtime函数相反。</p>
<blockquote>
<p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间。<br>mktime  函数用于把struct tm表示的时间转换为time_t表示的时间,函数返回time_t的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> mktime(struct tm *tm);</span><br></pre></td></tr></table></figure>

<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">st_tm</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;st_tm, <span class="number">0</span>, <span class="keyword">sizeof</span>(st_tm));</span><br><span class="line">    st_tm.tm_year = <span class="number">2019</span><span class="number">-1900</span>;</span><br><span class="line">    st_tm.tm_mon = <span class="number">11</span><span class="number">-1</span>;</span><br><span class="line">    st_tm.tm_mday = <span class="number">4</span>;</span><br><span class="line">    st_tm.tm_hour = <span class="number">20</span>;</span><br><span class="line">    st_tm.tm_min = <span class="number">18</span>;</span><br><span class="line">    st_tm.tm_sec = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the long num is %lu\n"</span>, mktime(&amp;st_tm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="t2.png" alt="结果"></p>
</blockquote>
<h3 id="程序睡眠"><a href="#程序睡眠" class="headerlink" title="程序睡眠"></a>程序睡眠</h3><p>在实际开发中，我们经常需要把程序挂起一段时间，可以使用sleep和usleep两个库函数，需要包含unistd.h头文件中。函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(<span class="keyword">useconds_t</span> usec)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sleep函数的参数是秒，usleep函数的参数是微秒，1秒=1000000微秒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sleep(<span class="number">1</span>);           <span class="comment">// 程序睡眠1秒。</span></span><br><span class="line">sleep(<span class="number">10</span>);          <span class="comment">// 程序睡眠10秒。</span></span><br><span class="line">usleep(<span class="number">100000</span>);    <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line">usleep(<span class="number">1000000</span>);   <span class="comment">// 程序睡眠一秒。</span></span><br></pre></td></tr></table></figure>

<p>程序员不关心sleep和usleep函数的返回值。</p>
<h3 id="精确到微秒的计时器"><a href="#精确到微秒的计时器" class="headerlink" title="精确到微秒的计时器"></a>精确到微秒的计时器</h3><h4 id="timeval结构体"><a href="#timeval结构体" class="headerlink" title="timeval结构体"></a>timeval结构体</h4><p>timeval结构体在sys/time.h文件中定义，声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span>  tv_sec;            <span class="comment">// 1970年1月1日到现在的秒。</span></span><br><span class="line">    <span class="keyword">long</span>  tv_usec;         <span class="comment">// 当前秒的微妙，即百万分之一秒。</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h4 id="timezone-结构体"><a href="#timezone-结构体" class="headerlink" title="timezone 结构体"></a>timezone 结构体</h4><p>timezone 结构体在sys/time.h文件中定义，声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">timezone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tz_minuteswest;     <span class="comment">// 和greenwich 时间差了多少分钟。</span></span><br><span class="line">    <span class="keyword">int</span> tz_dsttime;           <span class="comment">// type of DST correction。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gettimeofday库函数"><a href="#gettimeofday库函数" class="headerlink" title="gettimeofday库函数"></a>gettimeofday库函数</h4><p>gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数，可以用于程序的计时。调用gettimeofday函数需要包含sys/time.h头文件。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct  timeval *tv, struct  timezone *tz )</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当前的时间存放在tv 结构体中，当地时区的信息则放到tz所指的结构中。<br>函数执行成功后返回0，失败后返回-1。</p>
<blockquote>
<p>在使用gettimeofday()函数时，第二个参数一般都为空，我们一般都只是为了获得当前时间，不关心时区的信息。</p>
</blockquote>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begin</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;begin, <span class="number">0</span>);  <span class="comment">//第二个参数一般固定填0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"begin time(0)=%lu tv_sec=%lu, tv_usec=%lu\n"</span>,\</span><br><span class="line">            time(<span class="number">0</span>), begin.tv_sec, begin.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始睡眠1000000us\n"</span>);</span><br><span class="line">    usleep(<span class="number">1000000</span>);</span><br><span class="line">    gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end time(0)=%lu tv_sec=%lu, tv_usec=%lu\n"</span>,\</span><br><span class="line">            time(<span class="number">0</span>), end.tv_sec, end.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计时过去了%luus\n"</span>, \</span><br><span class="line">            (end.tv_sec-begin.tv_sec)*<span class="number">1000000</span>+(end.tv_usec-begin.tv_usec));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="t3.png" alt="结果"></p>
</blockquote>
<p>程序采用usleep睡眠十分之一秒，但是计时器显示的实际时间大于十分之一秒，为何？原因很简单，因为程序执行需要时间，虽然这个时间很短，在千分之一秒内，那也是需要时间。</p>
<p>还有一个要注意的问题，time.h 是ISO C99 标准日期时间头文件。sys/time.h 是Linux 系统的日期时间头文件，也就是说，timeval、timezone结构体和gettimeofday函数在windows平台中不能使用。</p>
<blockquote>
<p>应用经验<br>在实际开发中，除了当前的时间，还经常需要一个偏移量的时间，例如获取十分钟之后的时间，做法是采用time函数得到一个整数后，再加上<code>10*60</code>秒，再用localtime函数转换为结构体。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>时间操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言目录操作</title>
    <url>/2019/10/31/C%E8%AF%AD%E8%A8%80%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98436646" target="_blank" rel="noopener">码农有道的博客</a></li>
</ul>
<h3 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h3><p>在系统命令行下我们可以直接输入命令<code>pwd</code>来获取当前的工作目录，在C语言中可以使用<code>getcwd</code>函数来获取当前工作目录</p>
<ul>
<li><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含于&lt;unistd.h&gt;中</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strpwd[<span class="number">301</span>];</span><br><span class="line">    <span class="built_in">memset</span>(strpwd, <span class="number">0</span>, <span class="keyword">sizeof</span>(strpwd));</span><br><span class="line">    getcwd(strpwd, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前目录：%s\n"</span>, strpwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>就像我们在shell里使用cd命令来切换目录一样，在程序里则可以使用chdir系统调用来实现目录的变更。返回值：0-切换成功；非0-失败。<br>切换目录只是切换程序的运行环境目录，而不会改变用户的目录</p>
</blockquote>
<h3 id="目录的创建和删除"><a href="#目录的创建和删除" class="headerlink" title="目录的创建和删除"></a>目录的创建和删除</h3><p> 在系统命令行下我们可以通过mkdir和rmdir命令通过shell来创建一个目录和删除一个目录,在C语言中</p>
<ul>
<li>函数声明<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建目录,返回0为成功，-1为失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//mode是权限设置，如00755</span></span><br><span class="line"><span class="comment">//删除目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取目录中的文件列表"><a href="#获取目录中的文件列表" class="headerlink" title="获取目录中的文件列表"></a>获取目录中的文件列表</h3><p>获取目录中的文件列表，类似于ls命令<br>在实际开发中，我们经常要处理文件，文件是存放在目录中的，在处理文件之前，必须先知道目录中有哪些文件，所以要获取目录中的文件列表。涉及到的库函数如下：</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开目录的函数opendir的声明。</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">//读取目录的函数readdir的声明。</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">//关闭目录的函数closedir的声明。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>DIR是目录指针，就像文件操作时的文件指针。<br>调用一次readdir，返回结构体struct dirent（在dirent.h中声明，程序员只管用就行了）的指针，存放本次读取到的文件的信息，就像文件操作时调用一次fgets一样，但是fgets调用获取的内容是一个字符串，readdir返回的是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off;                    <span class="comment">// offset to this dirent 在目录文件中的偏移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;       <span class="comment">// length of this d_name 文件名长</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;          <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">    <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];  <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们只需要关注结构体的d_type和d_name成员，其它的不必关心。<br>d_name文件名或目录名。<br>d_type描述了文件的类型，有多种取值，最重要的是8和4，8-常规文件（A regular file）；4-目录（A directory），其它的暂时不关心.</p>
<ul>
<li><p>示例程序：获取某个目录下的文件和目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要输入一个目录参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    <span class="keyword">if</span>((dir=opendir(argv[<span class="number">1</span>]))==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//用于存放读取到的文件和目录信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">stdinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((stdinfo=readdir(dir))==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name=%s;type=%d\n"</span>, stdinfo-&gt;d_name, stdinfo-&gt;d_type);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例程序：获取目录下的文件及子目录下的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//列出目录及子目录下的文件</span></span><br><span class="line">    ReadDir(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;  <span class="comment">//定义目录指针</span></span><br><span class="line">    <span class="keyword">char</span> child_path[<span class="number">256</span>];  <span class="comment">//子目录的全路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    <span class="keyword">if</span>((dir=opendir(path))==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放从目录读到的文件和目录信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">stdinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((stdinfo=readdir(dir))==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略隐藏文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(stdinfo-&gt;d_name, <span class="string">"."</span>, <span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stdinfo-&gt;d_type==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//child_path = stdinfo-&gt;d_name;</span></span><br><span class="line">            <span class="built_in">sprintf</span>(child_path, <span class="string">"%s/%s"</span>, path, stdinfo-&gt;d_name);</span><br><span class="line">            ReadDir(child_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s/%s\n"</span>, \</span><br><span class="line">                    path, stdinfo-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><h4 id="mkdir函数"><a href="#mkdir函数" class="headerlink" title="mkdir函数"></a>mkdir函数</h4><h4 id="access库函数"><a href="#access库函数" class="headerlink" title="access库函数"></a>access库函数</h4><ul>
<li>access用于判断当前操作系统下用户对文件或目录的存取权限</li>
<li>包含头文件<code>&lt;unistd.h&gt;</code></li>
<li>函数声明<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。<br>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK 2     <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure>

<p>返回值<br>当pathname满足mode的条件时候返回0，不满足返回-1<br>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p>
<ul>
<li>示例程序：创建目录(可多级创建)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数个数错误\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个用于创建目录的函数，可多级创建\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"示例： ./mkdir_r /a/b/c\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mkdir_r(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path_name[<span class="number">301</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(path); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测间隔符‘/’或字符串末尾</span></span><br><span class="line">        <span class="keyword">if</span>(path[i]!=<span class="string">'/'</span> &amp;&amp; path[i+<span class="number">1</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">memset</span>(path_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(path_name));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(path[i+<span class="number">1</span>]==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="built_in">strncpy</span>(path_name, path, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strncpy</span>(path_name, path, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(access(path_name, F_OK)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件path_name=%s已存在\n"</span>, path_name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建文件path_name=%s\n"</span>, path_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mkdir(path_name, <span class="number">00755</span>)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"创建文件path_name=%s失败\n"</span>, path_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>目录操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言动态内存管理</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98435626" target="_blank" rel="noopener">https://blog.csdn.net/wucz122140729/article/details/98435626</a></p>
<a id="more"></a>
<p>在C语言中，编写程序的时候不能确定内存变量应该定义为多大，程序员希望在程序运行的时候根据数据量的大小向系统动态获得内存空间。所谓动态内存管理，就是指在程序执行的过程中动态地申请和回收内存空间。动态内存管理不像变量和数组那样在程序编写时预先分配内存空间，而是根据程序的需要即时分配，而且分配的内存大小就是程序要求的大小。</p>
<p>C语言允许程序动态申请内存，用于存放一些数据，需要时随时开辟，不需要时随时释放。C语言中，内存的动态分配是通过系统提供的库函数来实现的，主要有malloc和free 函数。</p>
<h2 id="相关的库函数"><a href="#相关的库函数" class="headerlink" title="相关的库函数"></a>相关的库函数</h2><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc 函数"></a>malloc 函数</h3><p>其函数的申明为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">void *malloc(unsigned int size)；</span><br></pre></td></tr></table></figure>

<p>其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">100</span>)； <span class="comment">// 开辟 100 个字节的临时分配域，返回值为其第一个字节的地址</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意地址的基类型为 void，即不指向任何类型的数据，只提供一个地址。如果此函数未能成功的执行（例如内存空间不足），则返回空（NULL，即0）。</p>
<p>程序员需要定义一个指针来指向动态分配的内存地址。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a>free 函数</h3><p>函数申明为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其作用是释放指针 p 所指向的动态空间的地址。p 是调用 malloc 函数时的返回的地址。free函数无返回值。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);     <span class="comment">// 释放指针变量pi指向的已分配的动态空间</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在使用动态分配内存技术的时候，分配出来的内存必须及时释放，否则会引起系统内存耗尽，这话说起来简单，好像很容易做到，但是在实际开发中，程序员往往是漏洞百出。<br>内存问题是C程序员的主要问题之一，程序崩溃是初中级程序员的恶梦。</p>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针就是无效的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。</p>
<ul>
<li>指针变量未初始化<br>指针变量刚被创建时不一定会自动成为空指针（与编译器有关），它的缺省值是可能随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针的值设置为0，要么让它指向合法的内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi=&amp;I;</span><br></pre></td></tr></table></figure>

<ul>
<li>指针释放后之后未置空<br>指针在free后不一定会赋值 0（也与编译器有关），便会使人以为是合法的。free只是把指针所指的内存给释放掉，此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为0。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在C语言的早期标准中，定义数组必须用常量指明大小，不能用变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">101</span>];        <span class="comment">// 可以这样</span></span><br><span class="line"><span class="keyword">int</span> len=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> str[len];         <span class="comment">// 不可以这样</span></span><br></pre></td></tr></table></figure>

<p>程序在运行的时候，如果要定义一个字符串存放100个字符，那怎么办，只能通过动态分配内存技术。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str=<span class="built_in">malloc</span>(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>现在，定义数组可以用变量指明大小，所以就不必为数组动态分配内存了。<br>还有，C++的string是一个字符串，非常好用，程序员根本不必关心内存的问题。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是C语言的一个经典的数据结构，相当于一个动态的结构体数组，非常巧妙，功能强大，但操作也麻烦，在这里我就不介绍了。</p>
<p>在C++中，容器全完代替了链表的功能，极其好用，程序员也不必关心内存的问题。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言文件操作</title>
    <url>/2019/10/25/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98435952" target="_blank" rel="noopener">码农有道的博客</a></p>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p> 打开文件的时候，C语言为打开的文件分配一个文件信息区，该信息区中包含文件描述信息、该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中<code>struct _IO_FILE</code>，这个结构体有一个别名<code>FILE</code>–<code>typedef struct _IO_FILE FILE</code>，<code>FILE</code>结构体和对文件操作的库函数在<code>stdio.h</code>头文件中声明的。<br>  打开文件的时候，调用打开文件的函数<code>fopen</code>时会动态分配一个<code>FILE</code>结构体，并把<code>FILE</code>结构体地址作为函数的返回值，即文件指针。调用关闭文件的函数<code>fclose</code>时候，除了关闭文件，还会释放文件指针占用的内存空间</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><ul>
<li>使用<code>fopen</code>创建或者打开一个文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> FILE *<span class="title">fopen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__filename,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">const</span> <span class="keyword">char</span> *__modes)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的目录。实际开发中，采用文件的全路径，即包含目录名。<br>参数mode也是字符串，表示打开文件的模式，打开模式可以是下列值中的一个</p>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rt</td>
<td>只读</td>
<td>文件必须存在，否则打开失败</td>
</tr>
<tr>
<td>wt</td>
<td>只写</td>
<td>文件存在，则清除原文件内容；文件不存在，则新建文件</td>
</tr>
<tr>
<td>at</td>
<td>追加只写</td>
<td>同上</td>
</tr>
<tr>
<td>rt+</td>
<td>读写</td>
<td>文件必须存在，+表示在只读上增加可写功能</td>
</tr>
<tr>
<td>wt+</td>
<td>读写</td>
<td>在只写上增加可读</td>
</tr>
<tr>
<td>at+</td>
<td>读写</td>
<td>在追加只写基础上增加可读</td>
</tr>
</tbody></table>
<ul>
<li><p>如果是二进制文件，则模式改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果打开文本，则<code>t</code>可以省略，<code>rt</code>可以简写为<code>r</code></p>
</li>
</ul>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span> <span class="params">(FILE *__stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h2><blockquote>
<p>在实际开发中，文本文件以行为单位存放字符串，如C程序的源代码，一段文字等，所以一般是按行写入或读取数据。</p>
</blockquote>
<h3 id="向文件中写入数据"><a href="#向文件中写入数据" class="headerlink" title="向文件中写入数据"></a>向文件中写入数据</h3><ul>
<li>可使用<code>fputc</code>, <code>fputs</code>, <code>fprintf</code>写文件，一般使用<code>sprintf</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span> <span class="params">(FILE *__stream,<span class="keyword">const</span> <span class="keyword">char</span> *__format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>与<code>printf</code>用法大致相同，只是第一个参数多了个<code>FILE</code>文件指针</p>
</blockquote>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p> C语言从文件中读取数据的库函数有fgetc、fgets、fscanf，在实际开发中，fgetc和fscanf没什么用，只介绍fgets就可以了。fgets函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span> <span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size, FILE *__stream)</span></span></span><br></pre></td></tr></table></figure>

<p>fgets的功能是从文件中读取一行<br>参数buf是一个字符串，用于保存从文件中读到的数据<br>参数size是打算读取内容的长度<br>参数fp是待读取文件的文件指针。</p>
<p>如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。<br>调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现</p>
<h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p> fwrite() 库函数用来向文件中写入块数据，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>

<p>参数的说明：<br>ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。<br>size：固定填1。<br>nmemb：表示打算写入数据的字节数。<br>fp：表示文件指针。</p>
<p>函数的返回值是本次成功写入数据的字节数，一般情况下，程序员不必关心fwrite函数的返回值。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;GIRL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GIRL girl;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制只写打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"/home/duguosheng/study/c/file/f1.txt"</span>, <span class="string">"wb"</span>))==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(girl.name, <span class="string">"小红"</span>);</span><br><span class="line">    girl.age = <span class="number">18</span>;</span><br><span class="line">    girl.height = <span class="number">167</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结构体存入文件</span></span><br><span class="line">    fwrite(&amp;girl, <span class="number">1</span>, <span class="keyword">sizeof</span>(girl), fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>vi打开该二进制文件<br><img src="f1.png" alt="二进制文件"></p>
</blockquote>
<h3 id="从文件中读取数据-1"><a href="#从文件中读取数据-1" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *fp);</span><br></pre></td></tr></table></figure>

<p>ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。<br>size：固定填1。<br>nmemb：表示打算读取的数据的字节数。<br>fp：表示文件指针。</p>
<blockquote>
<p>调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p>
</blockquote>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p> 在文件内部有一个位置指针，用来指向当前读写的位置，也就是读写到第几个字节。在文件打开时，如果打开模式是r和w，位置指针指向文件的第一个字节，如果打开模式是a，位置指针指向文件的尾部。每当从文件里读n个字节或文件里写入n个字节之后位置指针也会向后移动n个字节<br> C语言提供了ftell、rewind和fseek三个库函数来实现文件定位功能。</p>
<h3 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h3><p>  ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h3><p>rewind函数用来将位置指针移动到文件开头，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h3><p>fseek() 用来将位置指针移动到任意位置，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fp 为文件指针，也就是被移动的文件。</li>
<li>offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</li>
<li>origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</li>
</ul>
<p>fseek(fp,100,0);     // 从文件的开始位置计算，向后移动100字节。<br>fseek(fp,100,1);     // 从文件的当前位置计算，向后移动100字节。<br>fseek(fp,-100,2);    // 从文件的尾部位置计算，向前移动100字节</p>
<h2 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h2><p> 在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。<br>在实际开发中，如果程序员想把缓冲区的数据立即写入文件，可以调用fflush库函数，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数的参数只有一个，即文件指针，返回0成功，其它失败，程序员一般不关心它的返回值。</p>
<h2 id="标准输入，标准输出，标准错误"><a href="#标准输入，标准输出，标准错误" class="headerlink" title="标准输入，标准输出，标准错误"></a>标准输入，标准输出，标准错误</h2><p>  Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world.\n"</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello world.\n"</span>);</span><br></pre></td></tr></table></figure>

<p>这几个文件指针没什么用，让大家了解一下就行。在实际开发中，我们一般会关闭这几个文件指针。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言main函数的参数</title>
    <url>/2019/10/25/C%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>

<p>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98435291" target="_blank" rel="noopener">码农有道的博客</a></p>
<h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><p> main函数有三个参数，argc、argv和envp表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> argc，用于存放命令行参数的个数。</span><br><span class="line"><span class="keyword">char</span> *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</span><br><span class="line"><span class="keyword">char</span> *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</span><br></pre></td></tr></table></figure>

<h3 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv"></a>argc和argv</h3><ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc is %d\n"</span>, argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d] is %s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>终端下执行并输出<br><img src="m1.png" alt="结果"></p>
</blockquote>
<p>1）argc的值是参数个数加1，因为程序名称是程序的第一个参数，即argv[0]，在上面的示例中，argv[0]是./main1<br>2）main函数的参数，不管是书写的整数还是浮点数，全部被认为是字符串。<br>3）参数的命名argc和argv是程序员的约定，你也可以用argd或args，但是不建议这么做。</p>
<h3 id="用于提示信息"><a href="#用于提示信息" class="headerlink" title="用于提示信息"></a>用于提示信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入参数个数不匹配\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个选秀的程序，根据输入的信息为其评定\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"用法： ./main2 age appearance character\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"例如： ./main2 18 漂亮 开朗\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"age          年龄\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"appearance   颜值\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"character    性格\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((atoi(argv[<span class="number">1</span>])&gt;=<span class="number">18</span> &amp;&amp; atoi(argv[<span class="number">1</span>])=&lt;<span class="number">25</span>)</span><br><span class="line">            &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"漂亮"</span>)==<span class="number">0</span></span><br><span class="line">            &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">"开朗"</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"选秀合格"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还需努力"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当输入参数个数不满足预期设定时<br><img src="m2.png" alt="弹出提示信息"></p>
</blockquote>
<blockquote>
<p>当输入满足预期时<br><img src="m3.png" alt="正确执行"></p>
</blockquote>
<h3 id="envp"><a href="#envp" class="headerlink" title="envp"></a>envp</h3><blockquote>
<p>存放当前程序运行环境的参数 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(envp[num++]!=<span class="number">0</span>) <span class="comment">//数组最后一个元素是0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, envp[num]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果(部分截图)<br><img src="m4.png" alt="环境变量"></p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言格式化输出</title>
    <url>/2019/10/23/C%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flags][width][.prec]type</span><br></pre></td></tr></table></figure>

<h3 id="类型符type"><a href="#类型符type" class="headerlink" title="类型符type"></a>类型符type</h3><table>
<thead>
<tr>
<th>说明</th>
<th>标识符</th>
<th>含义</th>
<th>标识符</th>
<th>含义</th>
<th>标识符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>十进制有符号</td>
<td>%hd</td>
<td>short</td>
<td>%d</td>
<td>int</td>
<td>%ld</td>
<td>long</td>
</tr>
<tr>
<td>十进制无符号</td>
<td>%hu</td>
<td>short</td>
<td>%u</td>
<td>int</td>
<td>%lu</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>%c</td>
<td>输出字符</td>
<td>%f</td>
<td>float</td>
<td>%lf</td>
<td>double</td>
</tr>
<tr>
<td></td>
<td>%s</td>
<td>输出字符串</td>
<td>%e</td>
<td>科学计数法输出double</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="宽度width"><a href="#宽度width" class="headerlink" title="宽度width"></a>宽度width</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"=%5s=\n"</span>, <span class="string">"abc"</span>);  <span class="comment">//输出=  abc=</span></span><br></pre></td></tr></table></figure>

<h3 id="对齐标志flags"><a href="#对齐标志flags" class="headerlink" title="对齐标志flags"></a>对齐标志flags</h3><ul>
<li><code>+</code> 左对齐</li>
<li><code>-</code> 右对齐</li>
<li>缺省为<code>+</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"=%-5s="</span>, <span class="string">"abc"</span>);  <span class="comment">//输出=abc  =</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果输出整数或浮点数可在左补0<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%05d="</span>, <span class="number">123</span>);  <span class="comment">//输出=00123=</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="精度prec"><a href="#精度prec" class="headerlink" title="精度prec"></a>精度prec</h3><ul>
<li>如果输出是浮点数，它用于控制输出内容的精度，即保留位数，后面的四舍五入<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%010.2lf="</span>, <span class="number">123.456</span>);  <span class="comment">//输出=0000123.46=</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="格式化输出到字符串"><a href="#格式化输出到字符串" class="headerlink" title="格式化输出到字符串"></a>格式化输出到字符串</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>是参数个数可变的函数</p>
<p>功能：printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</p>
<p>在之前的章节中，介绍过把字符串转换为整数和浮点数据的库函数，C语言没有提供把整数和浮点数据转换为字符串的库函数，而是采用sprintf和snprintf函数格式化输出到字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%s今年%d岁了\n"</span>, <span class="string">"小明"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="built_in">snprintf</span>(str, <span class="number">11</span>, <span class="string">"%s今年%d岁了"</span>, <span class="string">"小明"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小明今年18岁了</span><br><span class="line">小明今�</span><br></pre></td></tr></table></figure>

<blockquote>
<p>snprintf截取中文不当会乱码</p>
</blockquote>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @func: 解析xml文件</span></span><br><span class="line"><span class="comment"> * @param: in_XMLBuffer所要查询的段落，in_FieldName所要查询的信息，out_Value获取内容存放的变量的指针</span></span><br><span class="line"><span class="comment"> * @return: 0-成功，-1-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">char</span> *out_Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> begin_filed_name[<span class="built_in">strlen</span>(in_FieldName)+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> end_filed_name[<span class="built_in">strlen</span>(in_FieldName)+<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(begin_filed_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(begin_filed_name));</span><br><span class="line">    <span class="built_in">memset</span>(end_filed_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(end_filed_name));</span><br><span class="line">    <span class="built_in">sprintf</span>(begin_filed_name, <span class="string">"&lt;%s&gt;"</span>, in_FieldName);</span><br><span class="line">    <span class="built_in">sprintf</span>(end_filed_name, <span class="string">"&lt;/%s&gt;"</span>, in_FieldName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *start, *end;</span><br><span class="line">    start = end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//寻找开始和结束地址</span></span><br><span class="line">    start = <span class="built_in">strstr</span>(in_XMLBuffer, begin_filed_name);</span><br><span class="line">    end = <span class="built_in">strstr</span>(in_XMLBuffer, end_filed_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start==<span class="number">0</span> || end==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:not found\n"</span>, in_FieldName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = end-start;</span><br><span class="line">    <span class="built_in">strncpy</span>(out_Value, start+<span class="built_in">strlen</span>(begin_filed_name), end-start-<span class="built_in">strlen</span>(begin_filed_name));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    char str_XML_buffer[301], str_value[51], str_age[51];</span></span><br><span class="line"><span class="comment">    memset(str_XML_buffer, 0, sizeof(str_XML_buffer));</span></span><br><span class="line"><span class="comment">    memset(str_value, 0, sizeof(str_value));</span></span><br><span class="line"><span class="comment">    strcpy(str_XML_buffer, "&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;18&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;");</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "name", str_value);</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "nme", str_value);</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "age", str_age);</span></span><br><span class="line"><span class="comment">    printf("%s", str_value);</span></span><br><span class="line"><span class="comment">    printf("%s", str_age);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>格式化输出</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中数据类型扩展</title>
    <url>/2019/10/23/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<a id="more"></a>

<p>一大部分摘自<a href="https://blog.csdn.net/wucz122140729" target="_blank" rel="noopener">码农有道</a></p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h3><ul>
<li><p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制使用‘0b’或者‘0B’</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0b101</span>;</span><br><span class="line"><span class="comment">//八进制使用‘0‘</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0706</span>;</span><br><span class="line"><span class="comment">//十六进制使用‘0x‘或’0X‘</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0xabc</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出<br><img src="c1.png" alt="输出"></p>
</li>
</ul>
<h3 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h3><ul>
<li>以下库函数包含在<code>stdlib.h</code>中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> +nptr)</span></span>;  <span class="comment">//将字符串转化为int整数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> j)</span></span>;        <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">labs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;  <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;  <span class="comment">//随机数生成器的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span></span>;  <span class="comment">//获得一个随机数</span></span><br></pre></td></tr></table></figure>

<p>srand函数初始化随机数发生器（俗称种子），在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同，通常我们采用<code>&lt;time.h&gt;</code>头文件中的<code>time</code>函数即可得到一个精确到秒的时间作为种子。<br><code>rand</code>函数会随机生成一个位于<code>0 ~ RAND_MAX</code>之间的整数。而对<code>RAND_MAX</code>是<code>&lt;stdlib.h&gt;</code>头文件中的一个宏，它用来指明<code>rand</code>所能返回的随机数的最大值</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="c2.png" alt="随机数"></p>
</blockquote>
<ul>
<li>生成一定范围的随机数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">50</span>;   <span class="comment">// 产生0~49 </span></span><br><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">100</span>;   <span class="comment">// 产生100~150的随机数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul>
<li>常用的库函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalpha</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是字母（'A'-'Z','a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalnum</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是字母（'A'-'Z','a'-'z'）或数字（'0'-'9'），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isdigit</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是数字（'0'-'9'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是小写字母（'a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是大写字母（'A'-'Z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是大写字母（'A'-'Z'）返回相应的小写字母（'a'-'z'）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是小写字母（'a'-'z'）返回相应的大写字母（'A'-'Z'）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> num1 = <span class="number">111.1</span>;</span><br><span class="line">    <span class="keyword">double</span> num2 = <span class="number">111.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num1=%f\n"</span>,num1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num2=%lf\n"</span>,num2);</span><br><span class="line">    <span class="keyword">if</span>(num1==<span class="number">111.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"11111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num2==<span class="number">111.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"22222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num1=<span class="number">111.099998</span></span><br><span class="line">num2=<span class="number">111.100000</span></span><br><span class="line"><span class="number">22222</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可见<blockquote>
<p>float数据类型表达的是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大<br>double数据类型表达的也是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大<br>float不可以用来比较是否相等，double可以</p>
</blockquote>
</li>
</ul>
<h3 id="常用库函数-1"><a href="#常用库函数-1" class="headerlink" title="常用库函数"></a>常用库函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;       <span class="comment">// 把字符串nptr转换为double</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;     <span class="comment">// 求 x 的 y 次幂（次方）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;              <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;                 <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;     <span class="comment">// 求x/y整除后的双精度余数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> val,<span class="keyword">double</span> *ip)</span></span>; <span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="常用库函数-2"><a href="#常用库函数-2" class="headerlink" title="常用库函数"></a>常用库函数</h3><ul>
<li>获取字符串的长度（strlen）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span>  <span class="built_in">strlen</span>( <span class="keyword">const</span> <span class="keyword">char</span>*  str);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：计算字符串长度，不包含\0<br>返回值：返回字符串的字符数<br>strlen 函数计算的是字符串的实际长度，遇到第一个\0结束。<br>函数返回值一定是size_t，是无符号的整数，即typedef unsigned int size_t。<br>如果你只定义字符串没有初始化，结果是不定的，它会从首地址一直找下去，直到遇到\0停止。</p>
<p>还有一个注意事项，sizeof返回的是变量所占的内存数，不是实际内容的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(buf)为<span class="number">10</span>。</span><br><span class="line"><span class="built_in">strlen</span>(buf)是<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串复制或赋值（strcpy）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功 能: 将参数src字符串拷贝至参数dest所指的地址。<br>返回值: 返回参数dest的字符串起始地址。<br>复制完字符串后，在dest后追加0。<br>如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串复制或赋值（strncpy）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：把src前n字符的内容复制到dest中<br>返回值：dest字符串起始地址。<br>如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。<br>如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0；<br>dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串拼接（strcat）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：将src字符串拼接到dest所指的字符串尾部。<br>返回值：返回dest字符串起始地址。<br>dest最后原有的结尾字符\0会被覆盖掉，并在连接后的字符串的尾部再增加一个\0。<br>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串拼接（strncat）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span> <span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。<br>返回值：返回dest字符串的起始地址。<br>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n大于字符串src的长度，只追加src的前n个字符。<br>strncat会将dest字符串最后的\0覆盖掉，字符追加完成后，再追加\0。<br>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串比较（strcmp、strncmp）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2 )</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；<br>int strncmp(const char *str1,const char *str2 ,const size_t n);<br>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；<br>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。<br>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</p>
<ul>
<li>字符查找（strchr、strrchr）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回一个指向在字符串s中第一个出现c的位置，如果找不到，返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回一个指向在字符串s中最后一个出现c的位置，如果找不到，返回0。</p>
<ul>
<li>字符串查找（strstr）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">const</span> <span class="keyword">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：检索子串在字符串中首次出现的位置。<br>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>css伪类标签</title>
    <url>/2019/10/12/css%E4%BC%AA%E7%B1%BB%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<a id="more"></a>

<table>
<thead>
<tr>
<th>伪类标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>a:link</code></td>
<td>普通的、未被访问的链接</td>
</tr>
<tr>
<td><code>a:visited</code></td>
<td>用户已访问的链接</td>
</tr>
<tr>
<td><code>a:hover</code>, <code>p:hover</code>, <code>#id:hover</code></td>
<td>鼠标指针位于链接的上方</td>
</tr>
<tr>
<td><code>a:active</code>, <code>p:active</code>, <code>#id:active</code></td>
<td>链接被点击的时刻</td>
</tr>
<tr>
<td><code>E:not(#p1)</code></td>
<td>所有的<code>&lt;E&gt;</code>标签，除了<code>id</code>为<code>p1</code>的</td>
</tr>
<tr>
<td><code>E:first-child</code></td>
<td>父类的第一个子级，如<code>li:first-child</code>表示选择所有作为第一个子级的<code>li</code></td>
</tr>
<tr>
<td><code>E:last-child</code></td>
<td>父类的最后一个子级，如<code>li:last-child</code>表示选择所有作为最后一个子级的<code>li</code></td>
</tr>
<tr>
<td><code>E:only-child</code></td>
<td>只有一个子级，如<code>li:only-child</code>表示选择<code>li</code>，且它的同级必须只有一个<code>li</code></td>
</tr>
<tr>
<td><code>E:empty</code></td>
<td>匹配为空的<code>&lt;E&gt;</code>标签</td>
</tr>
<tr>
<td><code>E:checked</code></td>
<td>匹配用户界面上处于选中状态的元素<code>&lt;E&gt;</code>，用于<code>input type</code>为<code>radio</code>与<code>checkbox</code>时，或<code>&lt;option&gt;</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>伪对象标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>E::before</code></td>
<td>在<code>&lt;E&gt;</code>前面添加内容</td>
</tr>
<tr>
<td><code>E::after</code></td>
<td>在<code>&lt;E&gt;</code>后面添加内容</td>
</tr>
</tbody></table>
<ul>
<li><p>当为链接的不同状态设置样式时，请按照以下次序规则：</p>
<blockquote>
<p>a:hover 必须位于 a:link 和 a:visited 之后<br>a:active 必须位于 a:hover 之后</p>
</blockquote>
</li>
<li><p>first-child实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*注意不是ul:first-child*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line">            background-color: gold;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css1.png" alt="效果"></p>
</blockquote>
<ul>
<li>checked实例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">option</span><span class="selector-pseudo">:checked</span>&#123;</span></span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* +表示同级 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:checked+span</span>&#123;</span></span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css2.png" alt="效果"></p>
</blockquote>
<ul>
<li>伪对象标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">            content: "你好";</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css3.png" alt="效果"></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css关系选择器和属性选择器</title>
    <url>/2019/10/11/css%E5%85%B3%E7%B3%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><ul>
<li>包含关系选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1 element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取所有包含于<code>element1</code>中的<code>element2</code>元素，可以是子级，孙级等等</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div p&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="css1.png" alt="结果"><br>只有<code>&lt;div&gt;</code>中的<code>&lt;p&gt;</code>设置了红色背景</p>
</blockquote>
<ul>
<li>父子关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1&gt;element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取包含于<code>element1</code>中的<code>element2</code>元素，只选取子级，孙级及以下不选取</p>
</blockquote>
<ul>
<li>相邻关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1+element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取<code>element1</code>后面紧跟的第一个<code>element2</code>元素</p>
</blockquote>
<ul>
<li>兄弟关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1~element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选择<code>element1</code>之后出现的所有<code>element2</code>,两种元素必须拥有相同的父元素，但是<code>element2</code>不必直接紧随<code>element1</code></p>
</blockquote>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li>只要包含某一个属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element[attribute]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性的元素</p>
</blockquote>
<ul>
<li>选取定值属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element[attribute=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值为<code>value</code>的元素</p>
</blockquote>
<ul>
<li>选取包含某值的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute~=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值包含<code>value</code>元素，如<code>title~=abc</code>，则<code>title</code>中所有带有<code>abc</code>的都会被选中</p>
</blockquote>
<ul>
<li>选取以整个单词开头的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute|=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>开头的元素，如<code>title|=abc</code>，则<code>title</code>中所有以<code>abc</code>开头的都会被选中,该值必须是整个单词</p>
</blockquote>
<ul>
<li>选取以某个团素开头的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute^=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>开头的元素，如<code>title^=abc</code>，则<code>title</code>中所有以<code>abc</code>开头的都会被选中</p>
</blockquote>
<ul>
<li>选取以某个元素结尾的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute$=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>结尾的元素，如<code>title$=abc</code>，则<code>title</code>中所有以<code>abc</code>结尾的都会被选中</p>
</blockquote>
<ul>
<li>选择包含某个元素的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute*=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值包含<code>value</code>，如<code>title*=abc</code>，则<code>title</code>中所有包含<code>abc</code>的都会被选中</p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css关系选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>css的布局和背景</title>
    <url>/2019/10/11/css%E7%9A%84%E5%B8%83%E5%B1%80%E5%92%8C%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><blockquote>
<p>常用布局格式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        header&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">        &#125;</span><br><span class="line">        aside&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        article&#123;</span><br><span class="line"><span class="css">            <span class="comment">/*这里不要写70%，因为页面有一些其他元素需要一些空间*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:69</span>%;</span></span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        footer&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: purple;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>效果<br><img src="css1.png" alt="布局"></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p><a href="https://www.w3school.com.cn/css/css_background.asp" target="_blank" rel="noopener">详细资料</a><br><img src="css2.png" alt="背景"></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用css样式的方式和基础选择器</title>
    <url>/2019/10/10/%E4%BD%BF%E7%94%A8css%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="使用css的方式"><a href="#使用css的方式" class="headerlink" title="使用css的方式"></a>使用css的方式</h3><h4 id="段内导入"><a href="#段内导入" class="headerlink" title="段内导入"></a>段内导入</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"background-color:red;"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="head中定义"><a href="#head中定义" class="headerlink" title="head中定义"></a><code>head</code>中定义</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    p&#123;</span><br><span class="line">        background-color: gold;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后这个文件中所有的<code>&lt;p&gt;</code>都会为<code>gold</code>颜色</p>
</blockquote>
<h4 id="导入其他的css文件"><a href="#导入其他的css文件" class="headerlink" title="导入其他的css文件"></a>导入其他的css文件</h4><p>在<code>css</code>文件夹下新建<code>base.css</code>文件<br>在<code>&lt;head&gt;</code>中导入：</p>
<ul>
<li><p>导入方式一</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/base.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入方式二</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    @<span class="keyword">import</span> url(<span class="string">"base.css"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><blockquote>
<p>通用选择器是一个符号<code>*</code>，像通配符</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: 0<span class="selector-tag">px</span>;    <span class="comment">/*取消所有的外间距*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><blockquote>
<p>id在文件中最好是唯一的</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*使用#指定对应的id，多个id使用逗号隔开*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-id">#d1</span>, <span class="selector-id">#p1</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d1"</span>&gt;</span>你好，世界!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>你好世界!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*使用.指定类，多个类之间用逗号隔开*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.cls1</span>, <span class="selector-class">.cls2</span>&#123;</span></span><br><span class="line">            background-color: purple;</span><br><span class="line">            margin: 3px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"cls1"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"cls1"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cls2"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span> <span class="attr">class</span>=<span class="string">"cls2"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一个标签可以属于多个类，多个类之间用<code>空格</code>隔开</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"cls1 cls2"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><blockquote>
<p>即指定对应的标签给定样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/*给所有的input标签指定样式*/</span></span></span><br><span class="line">    input&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h4><ul>
<li>id&gt;class&gt;标签&gt;通配符</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html5新增标签</title>
    <url>/2019/10/10/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>详细的html教程 <a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school</a></p>
<a id="more"></a>
<h2 id="常见的新增语义标签"><a href="#常见的新增语义标签" class="headerlink" title="常见的新增语义标签"></a>常见的新增语义标签</h2><p><code>&lt;header&gt;</code>: 页面头部<br><code>&lt;footer&gt;</code>: 页脚<br><code>&lt;article&gt;</code>: 定义页面独立的内容区域<br><code>&lt;aside&gt;</code>: 定义页面的侧边栏内容<br><a href="#details"><code>&lt;</code>details<code>&gt;</code></a>: 文档某个部分的细节<br><code>&lt;summary&gt;</code>: 是detail中的标题<br><code>&lt;figure&gt;</code>: 独立的文档流，在<code>&lt;figure&gt;</code>中定义的内容会自动缩进一部分<br><code>&lt;figcaption&gt;</code>: 是<code>&lt;figure&gt;</code>的标题<br><code>&lt;mark&gt;</code>: 重点标记，高亮显示<br><code>&lt;nav&gt;</code>: 导航连接<br><a href="#ruby"><code>&lt;</code>ruby<code>&gt;</code></a>: 加注释<br><a href="#datalist"><code>&lt;</code>datalist<code>&gt;</code></a>: 提示框<br><a href="#meter"><code>&lt;</code>meter<code>&gt;</code></a>: 用来表示范围已知且可度量的内容<br><a href="#progress"><code>&lt;</code>progress<code>&gt;</code></a>: 进度条，<code>max</code>指定最大值，<code>value</code>属性指定当前进度<br><a href="#audio"><code>&lt;</code>audio<code>&gt;</code></a>: 播放音频<br><a href="#video"><code>&lt;</code>video<code>&gt;</code></a>: 播放视频<br><a href="#embed"><code>&lt;</code>embed<code>&gt;</code></a>: 嵌入插件，网页<br><a href="#画布">画布</a></p>
<h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4><p><code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>联用</p>
<blockquote>
<p><code>&lt;summary&gt;</code>默认为<em>详细信息</em></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>点击查看<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是一张动漫图<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/img_1.jpg"</span> <span class="attr">width</span>=<span class="string">"80px"</span> <span class="attr">height</span>=<span class="string">"50px"</span> <span class="attr">alt</span>=<span class="string">"动漫"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h1.png" alt="效果"><br>点击查看后<br><img src="h2.png" alt="效果"></p>
</blockquote>
<h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><ul>
<li>加拼音，使用<code>&lt;rt&gt;</code>标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">    汪<span class="tag">&lt;<span class="name">rt</span>&gt;</span>w<span class="tag">&lt;<span class="name">ruby</span>&gt;</span>a<span class="tag">&lt;<span class="name">rt</span>&gt;</span>_<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span>ng<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行<br><img src="h3.png" alt="注释"></p>
</blockquote>
<h4 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h4><ul>
<li>和<code>&lt;input&gt;</code>联用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用list指定数据来源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">list</span>=<span class="string">"mydata"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用id指定名称，不是name--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"mydata"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用value指定提示内容--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--中间的文字是一些其他附属信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>热度100<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"bcd"</span>&gt;</span>热度70<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"emm"</span>&gt;</span>热度50<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"bat"</span>&gt;</span>热度30<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="h4.png" alt="datalist"><br>当键入<code>a</code>时，自动弹出了和<code>a</code>相关的提示</p>
<h4 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h4><blockquote>
<p>比较大小</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0<span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"40"</span>&gt;</span><span class="tag">&lt;/<span class="name">meter</span>&gt;</span>100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h5.png" alt="meter"></p>
</blockquote>
<h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><blockquote>
<p>进度条</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0<span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"80"</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span>100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h6.png" alt="meter"></p>
</blockquote>
<h4 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h4><ul>
<li>属性<br><code>src</code>: 音频地址<br><code>autoplay</code>: 自动播放<br><code>controls</code>: 显示控件，比如播放按钮<br><code>loop</code>: 循环播放<blockquote>
<p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"someaudio.mp3"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 audio 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><ul>
<li>属性部分同<code>audio</code><br><code>width</code>: 设置宽度<br><code>height</code>: 设置高度<br><code>poster</code>: 设置封面</li>
</ul>
<h4 id="embed"><a href="#embed" class="headerlink" title="embed"></a>embed</h4><blockquote>
<p>定义嵌入的内容，比如插件，网页。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"/i/helloworld.swf"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h7.png" alt="embed"><br>成功嵌入了网页，并且可以使用网页的功能</p>
</blockquote>
<h4 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h4><p><code>&lt;canvas&gt;</code>标签用于绘制标签，<canvas> 元素本身并没有绘制能力（它仅仅是图形的容器，必须使用脚本来完成实际的绘图任务。</canvas></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>晒晒自己的桌面</title>
    <url>/2019/10/06/%E6%99%92%E6%99%92%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<a id="more"></a>
<p><img src="desktop.png" alt="桌面"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>桌面</tag>
        <tag>i3</tag>
      </tags>
  </entry>
  <entry>
    <title>安装谷歌访问助手</title>
    <url>/2019/10/06/%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<a id="more"></a>

<p>&emsp;&emsp;众所周知，谷歌浏览器最牛逼的地方就是在于插件众多，而插件可以提供丰富的用法，从而造就谷歌丰富的功能。一般来说，谷歌插件（也叫扩展）可以在谷歌应用商店下载安装，但是emmmm没办法直接上应用商店下载，但是有一个谷歌插件完美解决了这个问题，那就是<strong>谷歌访问助手</strong>。</p>
<p>&emsp;&emsp;本篇文章要讲的就是如何安装<strong>谷歌访问助手</strong>，然后利用这个插件登上应用商店，下载各种各样的谷歌插件，走向人生巅峰！</p>
<h2 id="1-下载谷歌访问助手的安装包"><a href="#1-下载谷歌访问助手的安装包" class="headerlink" title="1.下载谷歌访问助手的安装包"></a>1.下载谷歌访问助手的安装包</h2><p>链接：<a href="https://pan.baidu.com/s/1gjbVfFjDRQvUcKjNfYeAXQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1gjbVfFjDRQvUcKjNfYeAXQ</a>  提取码：x9ox</p>
<ul>
<li><p>首先就是下载这个安装包，然后解压，解压后是一个文件夹，而不是一个单纯的.crx文件，现在单纯的.crx文件已经不能直接安装在浏览器上了。</p>
</li>
<li><p>解压后打开谷歌浏览器，点击浏览器右上角的三个竖点点，点击更多工具—&gt;扩展程序（当然，也可以直接在地址栏中输入chrome://extensions/，和这些操作结果是一样的。）</p>
</li>
</ul>
<p>如下图<img src="https://img-blog.csdnimg.cn/20190731082506181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>进入这个扩展程序页面（即插件页面）</p>
<p><img src="https://img-blog.csdnimg.cn/20190731082613464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>记得打开<strong>开发者模式</strong>。</p>
<ul>
<li>将刚才解压好的文件夹里的文件夹直接拖进来。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083342927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>拖进来就直接安装了（因为我之前安装过，为了演示删掉重装，没安装过得应该可能会弹出提示，点击确定就行了）</p>
<p><img src="https://img-blog.csdnimg.cn/201907310836365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>点击永久免费激活，进入如下图页面，再点击往选项页面</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083813800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>勾选网址</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083912722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>安装好了就是这个样子</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731084013654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>温馨提示：有时候这个插件是灰色的，不能用就刷新重启，不然就把浏览器关了再来。</p>
</li>
<li><p>接下去就是去谷歌应用商店愉快地下载插件了，点击应用，我的是在浏览器左上角<img src="https://img-blog.csdnimg.cn/20190731084201348.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>转自：<a href="https://www.jianshu.com/p/ca06b16613cc" target="_blank" rel="noopener">https://www.jianshu.com/p/ca06b16613cc</a></p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>arch下PKGBUILD包的安装</title>
    <url>/2019/10/04/arch%E4%B8%8BPKGBUILD%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>cd到有<code>PKGBUILD</code>文件的目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成后缀.pkg.tar.xz的压缩文件</span></span><br><span class="line">makepkg</span><br><span class="line"><span class="comment"># 使用pacman安装</span></span><br><span class="line">sudo pacman -U *.pkg.tar.xz</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>PKGBUILD</tag>
      </tags>
  </entry>
  <entry>
    <title>polybar主题配置</title>
    <url>/2019/10/04/polybar%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<a id="more"></a>

<blockquote>
<p>折腾了一天的<code>polybar</code>主题，来记录一下</p>
</blockquote>
<h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><ul>
<li>首先，你已经下好了polybar</li>
<li>然后下载<code>polybar</code>的主题<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/adi1090x/polybar-themes.git</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>然后在<code>.config</code>目录下就会有一个名为<code>polybar-themes</code>的文件夹</p>
</blockquote>
<h2 id="配置字体"><a href="#配置字体" class="headerlink" title="配置字体"></a>配置字体</h2><ul>
<li>就会看到一共九个主题，每个主题下都有一个名为<code>fonts</code>的文件夹，想要使用哪个主题，先将主题的字体复制到你系统的字体文件夹下<blockquote>
<p>这个字体我搞了好长时间(大概一下午加晚上)，一直以为要自己下载，下载了还显示不出来，原来他自带，我….</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> polybar-themes</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以<code>polybar-6</code>为例，它的字体目录如下</p>
<p><img src="p1.png" alt="字体"></p>
<p>我的字体目录是<code>/usr/share/fonts/</code>，我的<code>ttf</code>尾缀的字体在<code>/usr/share/fonts/TTF/</code>下，所以我将<code>ttf</code>字体复制到这里面，然后<code>termsyn</code>是个字体文件夹，直接放在<code>fonts</code>目录下即可，<code>siji</code>放在<code>/usr/share/fonts/misc/</code>下</p>
<blockquote>
<p>最后将原来的<code>~/.config/polybar/</code>这个目录改个名字，如果不需备份的话直接删除就好了，然后我用的<code>polybar-5</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r ~/.config/polybar-themes/polybar-5 ~/.config/polybar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来运行脚本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config/polybar/</span><br><span class="line">./launsh.sh</span><br></pre></td></tr></table></figure>

<h2 id="配置-polybar-5"><a href="#配置-polybar-5" class="headerlink" title="配置(polybar-5)"></a>配置(polybar-5)</h2><ul>
<li>如果想更改标题栏顺序，可以在主题中<code>config.ini</code>中修改<br>建议将<code>[bar/top]</code>下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules-left = menu title right-end-top left-end-bottom workspaces right-end-top left-end-bottom colors-switch right-end-top</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules-left = menu workspaces right-end-top left-end-bottom colors-switch right-end-top left-end-bottom title right-end-top</span><br></pre></td></tr></table></figure>

<p>用起来感觉好些</p>
<ul>
<li><p>如果要更改左上角菜单栏中<code>Files</code>，<code>Terminal</code>等的程序，可以在主题下<code>user_modules.ini</code>中<code>[module/menu]</code>下更改</p>
</li>
<li><p>解决polybar显示不了中文<br>打开主题目录下<code>config.ini</code>，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-0 = Iosevka Nerd Font:style=Medium:size=14;3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-0 = unifont:style=Medium:size=14;3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然也可以下载其他支持中文的字体</p>
</blockquote>
<ul>
<li>我用的<code>i3wm</code>所以它的右上角<code>powermenu</code>菜单中<code>logout</code>用不了</li>
</ul>
<p>首先下载<code>i3exit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S i3exit</span><br></pre></td></tr></table></figure>

<p>然后更改主题文件夹下<code>scripts/powermenu</code>，将</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*Logout) openbox --<span class="built_in">exit</span> ;;</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*Logout) i3exit <span class="built_in">logout</span> ;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>polybar</tag>
      </tags>
  </entry>
  <entry>
    <title>html表格表单</title>
    <url>/2019/10/03/html%E8%A1%A8%E6%A0%BC%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li><code>&lt;caption&gt;</code>标签：表格标题</li>
<li><code>&lt;table&gt;</code>标签：声明一个表格，它的常用属性如下<ul>
<li><code>bgcolor</code>：定义背景色</li>
<li><code>background</code>：背景图片</li>
<li><code>border</code>：定义表格的边框，设置值是数值</li>
<li><code>bordercolor</code>：定义表格的边框的颜色</li>
<li><code>width</code>：表格宽度</li>
<li><code>height</code>：表格高度</li>
<li><code>cellpadding</code>：定义单元格内容与边框之间的间距，设置值是数值</li>
<li><code>cellspacing</code>：定义单元格与单元格之间的间距，设置值是数值</li>
<li><code>align</code>：设置整体表格相对于浏览器窗口的水平对齐方式，设置值有<code>left</code>，<code>center</code>，<code>right</code></li>
</ul>
</li>
<li><code>&lt;tr&gt;</code>标签：定义表格中的一行</li>
<li><code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>标签：定义一行中的一个单元格，<code>&lt;td&gt;</code>表示普通单元格，<code>&lt;th&gt;</code>表示表头单元格，常用属性如下<ul>
<li><code>align</code>：设置单元格中的内容水平对齐方式，设置值有<code>left</code>，<code>center</code>，<code>right</code></li>
<li><code>valign</code>：设置单元格中内容垂直对齐方式：设置值有<code>top</code>，<code>middle</code>，<code>bottom</code></li>
<li><code>colspan</code>：设置单元格水平合并，设置值是数值</li>
<li><code>rowspan</code>：设置单元格垂直合并，设置值是数值</li>
<li><code>bgcolor</code>：设置背景色</li>
</ul>
</li>
</ul>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><blockquote>
<p>用于收集不同类型的用户输入</p>
</blockquote>
<h4 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h4><ul>
<li>定义整体的表单区域<blockquote>
<p> <code>action</code>属性定义表单数据提交地址</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>登陆界面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"success.html"</span>&gt;</span>    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入帐号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入手机号或者邮箱"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>另外在当前目录下新建一个<code>success.html</code>显示内容为<strong>欢迎你</strong></p>
<blockquote>
<p>运行</p>
</blockquote>
<p><img src="ht_3.png" alt="action"><br>点击登录<br><img src="ht_4.png" alt="登录"></p>
<p>成功跳转</p>
<blockquote>
<p><code>method</code>属性定义表单提交的方式，一般有<code>get</code>和<code>post</code>方式<br><code>post</code>方法通常用于提交数据，数据的内容不会显示在浏览器的地址栏中，且对数据的长度没有限制。<br><code>get</code>方法会将你的数据在浏览器地址栏中显示出来，而且由于URL长度有限，所以传递的数据长度也受限制。</p>
</blockquote>
<h4 id="lt-input-gt-标签："><a href="#lt-input-gt-标签：" class="headerlink" title="&lt;input&gt;标签："></a><code>&lt;input&gt;</code>标签：</h4><blockquote>
<p><code>type</code>属性：<br>  type=”text”：输入文本<br>  type=”password”：输入密码<br>  type=”submit”：提交表单，显示文字默认是<strong>提交</strong>，可以使用<code>value=&quot;&quot;</code>更改<br>  type=”reset”：清空数据，显示文字默认是<strong>重置</strong>，可以使用<code>value=&quot;&quot;</code>更改<br>  type=”botton”：自定义按键<br>  type=”checkbox”：多选框<br>  type=”radio”：单选框，必须有<code>name</code>属性，且<code>name</code>值必须相同<br>  type=”hidden”：隐藏<br>  type=”file”：上传文件<br>h5新增：<br>  type=”date”：输入日期<br>  type=”week”：输入第几周<br>  type=”url”：输入网址<br>  type=”email”：输入邮箱<br>  type=”cloor”：输入颜色<br>  type=”range”：还需要设定最小值，最大值，是一个拖动条<br>  type=”search”：搜索内容</p>
</blockquote>
<blockquote>
<p><code>name</code>属性：为输入内容定义名字</p>
</blockquote>
<blockquote>
<p><code>checked</code>属性：布尔类型，在某个单选或复选框内加入表示默认选择</p>
</blockquote>
<blockquote>
<p><code>required</code>属性：布尔类型，加上它表示此项必须要填</p>
</blockquote>
<blockquote>
<p><code>readonly</code>属性：布尔类型，只读，表示只能查看，不能修改</p>
</blockquote>
<blockquote>
<p><code>value</code>属性：<br>存储填入的值</p>
<ul>
<li><code>placeholder</code>：提示信息</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入帐号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入手机号或者邮箱"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="ht_1.png" alt="提示信息"></p>
</blockquote>
<h4 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h4><ul>
<li><code>&lt;select&gt;</code>标签：定义下拉框区域<blockquote>
<p><code>size</code>属性：定义显示的下拉菜单中的数量</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>name</code>属性：定义名称</p>
<ul>
<li><code>&lt;option&gt;</code>标签：下拉框中的选项<br><code>selected</code>属性：布尔类型，表示缺省选择这个选项</li>
</ul>
</blockquote>
<ul>
<li><code>&lt;optgroup&gt;</code>标签：定义下拉框组，里面继续嵌套<code>&lt;option&gt;</code></li>
</ul>
<h4 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h4><ul>
<li><code>&lt;textarea&gt;</code>标签:<blockquote>
<p><code>rows</code>：定义行数<br><code>cols</code>：定义列数</p>
</blockquote>
</li>
<li><code>placeholder</code>：提示信息</li>
</ul>
<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><blockquote>
<p>一般可以给如上面的<em>请输入帐号</em>加一个<code>&lt;label&gt;</code>标签，无实际效果，只是为了后面加样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>请输入帐号<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span> 男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span> 女</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>爱&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 看电影</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 学习</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 读书</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>照&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;片：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"photo"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>描&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;述：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>籍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;贯：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>天津<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>重庆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="ht_2.png" alt="表单"></p>
</blockquote>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html基本标签</title>
    <url>/2019/10/02/html%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="html基本结构"><a href="#html基本结构" class="headerlink" title="html基本结构"></a>html基本结构</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        网页显示内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h2><ul>
<li>属性(不推荐使用)：<ul>
<li><code>bgcolor</code>：设置背景色</li>
<li><code>background</code>：设置背景图</li>
</ul>
</li>
</ul>
<h2 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释内容--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><ul>
<li>通过<code>&lt;h1&gt;</code>，<code>&lt;h2&gt;</code>…<code>&lt;h6&gt;</code>来确定标题等级<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式的段落中首段开头的空格和换行不会识别，段落中的多个空格只识别一个<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>    这是  一段</span><br><span class="line">内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<p><img src="ht_1.png" alt="结果"></p>
<h3 id="html字符实体"><a href="#html字符实体" class="headerlink" title="html字符实体"></a>html字符实体</h3><table>
<thead>
<tr>
<th>字符</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>换行符</td>
<td><code>&lt;br /&gt;</code></td>
</tr>
</tbody></table>
<h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a><div>块标签</div></h2><blockquote>
<p>块元素，表示一块内容，没有具体的语义<br>可以设置宽高，缺省为内容的高度，宽为整个网页<br>独占一行，两个块之间默认换行</p>
<ul>
<li>与<code>&lt;p&gt;&lt;/p&gt;</code>的区别，在<code>body</code>中写如下内容</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<p><img src="ht_2.png" alt="区别"></p>
<blockquote>
<p>可以看到，<code>p</code>标签两端内容间有空行，即<code>p</code>标签是带有格式的，而<code>div</code>没有格式</p>
</blockquote>
<h2 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a><span>内联标签</span></h2><blockquote>
<p>行内标签，表示一行中的一小段内容，没有具体的语义(在做样式的地方会用到)<br>不能嵌套换行<br>不能设置宽高，宽高都是内容的宽高</p>
</blockquote>
<h2 id="font标签"><a href="#font标签" class="headerlink" title="font标签"></a>font标签</h2><ul>
<li>属性：<ul>
<li><code>color</code>：设置字体颜色</li>
<li><code>size</code>：设置字体大小 </li>
</ul>
</li>
</ul>
<h2 id="含样式和语义的标签"><a href="#含样式和语义的标签" class="headerlink" title="含样式和语义的标签"></a>含样式和语义的标签</h2><ul>
<li><code>&lt;em&gt;</code>标签：行内元素，表示语气中的强调词，倾斜</li>
<li><code>&lt;i&gt;</code>标签：行内元素，表示专业词汇，倾斜</li>
<li><code>&lt;b&gt;</code>标签：行内元素，表示文档中的关键词或者产品名，加粗</li>
<li><code>&lt;strong&gt;</code>标签：行内元素，表示非常重要的内容，加粗</li>
<li><code>&lt;u&gt;</code>：下划线</li>
<li><code>&lt;del&gt;</code>：删除线</li>
<li><code>&lt;sup&gt;</code>：上标，如<code>x&lt;sup&gt;2&lt;/sup&gt;</code></li>
<li><code>&lt;sub&gt;</code>：下标，如<code>x&lt;sub&gt;2&lt;/sub&gt;</code></li>
<li><code>&lt;address&gt;</code>：地址标签，倾斜</li>
<li><code>&lt;pre&gt;</code>：预编译，不推荐使用，即写入什么格式就显示什么</li>
<li><code>&lt;big&gt;</code>：字体稍大</li>
<li><code>&lt;small&gt;</code>：字体稍小</li>
</ul>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片路径 "</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>width</code>:宽度</li>
<li><code>height</code>:高度</li>
<li><code>alt</code>:图片不能显示时的显示文字 </li>
<li><code>title</code>:鼠标悬浮在图片上显示的文字</li>
</ul>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span> <span class="attr">title</span>=<span class="string">"鼠标悬停时的描述信息"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>文字或图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>href=&quot;#&quot;</code>：表示跳转到顶部<br><code>target=&quot;_self&quot;</code>：使用框架，替换当前区域，不设定时默认为<code>_self</code><br><code>target=&quot;_parent&quot;</code>：使用框架，替换父级页面<br><code>target=&quot;_top&quot;</code>：使用框架，替换全局页面<br><code>target=&quot;_blank&quot;</code>：新开一个页面</p>
</blockquote>
<ul>
<li><p>跳转到指定位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#test"</span>&gt;</span>点我跳转到hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>点我跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以使用图片跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/bd.jpg"</span> <span class="attr">alt</span>=<span class="string">"百度logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="有序标签"><a href="#有序标签" class="headerlink" title="有序标签"></a>有序标签</h3><ul>
<li><p>定义有序列表可以用<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>配合使用来使用，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>属性：<br>type=”1”：12345<br>type=”a”：abcde<br>type=”A”：ABCDE<br>type=”i”：i ii iii<br>type=”I”：罗马字母</p>
</li>
</ul>
<blockquote>
<p>执行结果: </p>
</blockquote>
<p><img src="ht_3.png" alt="执行结果"></p>
<blockquote>
<p>可以使用快捷键生成列表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- 生成五个有序列表 --&gt;</span><br><span class="line">ol&gt;li*<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li><p>定义无序列表可以用<code>&lt;ul&gt;</code>和<code>&lt;li&gt;</code>配合使用来使用，可嵌套，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"disc"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>属性：<br>type=”none”：无<br>type=”disc”：默认黑色圆点<br>type=”circle”：空心圆点<br>type=”square”：方块</p>
</li>
</ul>
<blockquote>
<p>执行结果: </p>
</blockquote>
<p><img src="ht_4.png" alt="执行结果"></p>
<blockquote>
<p>可以使用快捷键生成列表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- 生成五个有序列表 --&gt;</span><br><span class="line">ul&gt;li*<span class="number">5</span></span><br></pre></td></tr></table></figure>


<h3 id="列表嵌套链接"><a href="#列表嵌套链接" class="headerlink" title="列表嵌套链接"></a>列表嵌套链接</h3><ul>
<li><p>一般标题是可以点击跳转的，所以对标题增加链接功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用快捷键生成上述内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul&gt;(li&gt;a&#123;列表标题&#125;)*3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><ul>
<li>定义列表通常用于术语的定义，<code>&lt;dl&gt;</code>标签定义术语的题目，<code>&lt;dd&gt;</code>标签是术语的解释，一个<code>&lt;dl&gt;</code>中可以有多个题目和解释<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>html<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>超文本标记语言<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Http<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>超文本传输协议<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Url<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>统一资源定位符<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="ht_5.png" alt="结果"></p>
<ul>
<li>快捷键<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">dl&gt;(dt+dd)*3</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2019/09/27/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>cowsay软件--linux轻松一下</title>
    <url>/2019/09/27/cowsay%E8%BD%AF%E4%BB%B6-linux%E8%BD%BB%E6%9D%BE%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cowsay 文本</span></span><br><span class="line">cowsay hahaha</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="cow.png" alt="cow"></p>
</blockquote>
<h3 id="使用其他动物"><a href="#使用其他动物" class="headerlink" title="使用其他动物"></a>使用其他动物</h3><h4 id="罗列所有动物"><a href="#罗列所有动物" class="headerlink" title="罗列所有动物"></a>罗列所有动物</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -l</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cow files in /usr/share/cows:</span><br><span class="line">beavis.zen blowfish bong bud-frogs bunny cheese cower daemon default dragon</span><br><span class="line">dragon-and-cow elephant elephant-in-snake eyes flaming-sheep ghostbusters</span><br><span class="line">head-in hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose</span><br><span class="line">mutilated ren satanic sheep skeleton small sodomized stegosaurus stimpy</span><br><span class="line">supermilker surgery telebears three-eyes turkey turtle tux udder vader</span><br><span class="line">vader-koala www</span><br></pre></td></tr></table></figure>

<h4 id="切换动物"><a href="#切换动物" class="headerlink" title="切换动物"></a>切换动物</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如换成dragon-and-cow</span></span><br><span class="line">cowsay -f dragon-and-cow hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="cow_d.png" alt="cow_dragon"></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cowsay</tag>
        <tag>字符软件</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式re模块</title>
    <url>/2019/09/26/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h2><blockquote>
<p><code>match()</code>方法默认判断开头</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用match方法查看是否满足规则，如果匹配失败，返回None</span><br><span class="line"># 字符串前加r表示这是非转义的原始字符串</span><br><span class="line">ret = re.match(r&quot;指环王[1-3]&quot;, &quot;指环王2&quot;)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"># 可以使用group方法查看匹配的对象</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;指环王2&apos;&gt;</span><br><span class="line">指环王2</span><br></pre></td></tr></table></figure>

<h2 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h2><blockquote>
<p><code>search</code>可以从文章的任意位置开始，但只能找到第一个满足条件的文本</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = re.search(<span class="string">r"\d+"</span>, <span class="string">"阅读次数为：4567; 点赞数为：345"</span>)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4567</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>match</code>则<code>4567</code>必须在开头才能被匹配到<br>只能取到第一个满足的文本</p>
</blockquote>
<h2 id="findall方法"><a href="#findall方法" class="headerlink" title="findall方法"></a>findall方法</h2><ul>
<li>可以检索到所有满足条件的文本<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = re.findall(<span class="string">r"\d+"</span>, <span class="string">"阅读次数为：4567; 点赞数为：345"</span>)</span><br><span class="line"><span class="comment"># 无需调用group，直接返回列表</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;4567&apos;, &apos;345&apos;]</span><br></pre></td></tr></table></figure>

<h2 id="sub方法"><a href="#sub方法" class="headerlink" title="sub方法"></a>sub方法</h2><ul>
<li><p>可以更改数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.sub(<span class="string">r"正则表达式"</span>, <span class="string">"要替换的文本"</span>, <span class="string">"被替换的文本"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = re.sub(<span class="string">r"\d+"</span>, <span class="string">"123米"</span>, <span class="string">"长达4324, 宽为678"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长达123米, 宽为123米</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全部都被替换了</p>
</blockquote>
<h3 id="嵌入表达式"><a href="#嵌入表达式" class="headerlink" title="嵌入表达式"></a>嵌入表达式</h3><ul>
<li><code>sub()</code>还支持调用表达式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(temp)</span>:</span></span><br><span class="line">    num = int(temp.group())</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> str(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_content1 = re.sub(<span class="string">r"\d+"</span>, add, <span class="string">"长达4324, 宽为678"</span>)</span><br><span class="line">print(new_content1)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长达4325, 宽为679</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现了数据<code>+1</code>的操作</p>
</blockquote>
<h2 id="spilt方法"><a href="#spilt方法" class="headerlink" title="spilt方法"></a>spilt方法</h2><ul>
<li>根据匹配进行切割字符串，并返回一个列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逗号，分号或空格分开字符串</span></span><br><span class="line">result = re.split(<span class="string">r",|;| "</span>, <span class="string">"abc def,gh;ij"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;gh&apos;, &apos;ij&apos;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>re模块</tag>
      </tags>
  </entry>
  <entry>
    <title>IAR的基本使用</title>
    <url>/2019/09/26/iar_use/</url>
    <content><![CDATA[<h1 id="IAR"><a href="#IAR" class="headerlink" title="IAR"></a>IAR</h1><!-- vim-markdown-toc Redcarpet -->

<ul>
<li><a href="#iar软件界面介绍">IAR软件界面介绍</a><ul>
<li><a href="#如何显示工具栏">如何显示工具栏</a></li>
<li><a href="#更改字体">更改字体</a></li>
</ul>
</li>
<li><a href="#常用操作">常用操作</a><ul>
<li><a href="#新建并添加源文件">新建并添加源文件</a><ul>
<li><a href="#创建源文件">创建源文件</a></li>
<li><a href="#添加源文件">添加源文件</a></li>
</ul>
</li>
<li><a href="#管理文件">管理文件</a><ul>
<li><a href="#多文件">多文件</a></li>
<li><a href="#头文件管理">头文件管理</a><ul>
<li><a href="#头文件的一些说明">头文件的一些说明</a></li>
</ul>
</li>
<li><a href="#分组管理">分组管理</a></li>
</ul>
</li>
<li><a href="#分屏">分屏</a></li>
<li><a href="#livewatch功能">Livewatch功能</a></li>
<li><a href="#断点调试">断点调试</a></li>
</ul>
</li>
<li><a href="#常用快捷键">常用快捷键</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="IAR软件界面介绍"><a href="#IAR软件界面介绍" class="headerlink" title="IAR软件界面介绍"></a>IAR软件界面介绍</h2><p><img src="iar_1.png" alt="界面"></p>
<ul>
<li>一个标准的<strong>IDE界面</strong></li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> 菜单栏：涵盖几乎所有用户需要的功能</li>
<li><input checked disabled type="checkbox"> 工具栏：放置一些常用的功能，便于调用</li>
<li><input checked disabled type="checkbox"> 标签栏：显示用户打开的文件，方便切换</li>
<li><input checked disabled type="checkbox"> 文件目录树：显示用户文件目录树形结构，方便查找切换</li>
<li><input checked disabled type="checkbox"> 编程区域：占据了大部分空间，是我们写代码的地方</li>
<li><input checked disabled type="checkbox"> 结果显示窗口：相当于控制台，输出文件编译信息，如错误，警告</li>
</ul>
<h3 id="如何显示工具栏"><a href="#如何显示工具栏" class="headerlink" title="如何显示工具栏"></a>如何显示工具栏</h3><ul>
<li>可能有些同学没有图中的工具栏区域<blockquote>
<p>勾选<code>Windows-&gt;Toolbar-&gt;Main</code>即可显示工具栏<br><img src="iar_2.png" alt="工具栏"></p>
</blockquote>
</li>
</ul>
<h3 id="更改字体"><a href="#更改字体" class="headerlink" title="更改字体"></a>更改字体</h3><ul>
<li>默认的界面字体太小而且颜色单一，不利于阅读，和区分不同类型的代码，如关键字，注释等等</li>
<li>通过<code>按住Ctrl+滑动滚轮</code>的方式可以调节当前文件的字体</li>
<li>通过设置选项个人化配置：<code>Tools-&gt;Options-&gt;Editor-&gt;Colors and Fonts</code><br><img src="iar_16.png" alt="改字体"></li>
</ul>
<p><img src="iar_18.png" alt="改字体"></p>
<hr>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="新建并添加源文件"><a href="#新建并添加源文件" class="headerlink" title="新建并添加源文件"></a>新建并添加源文件</h3><h4 id="创建源文件"><a href="#创建源文件" class="headerlink" title="创建源文件"></a>创建源文件</h4><blockquote>
<ul>
<li>点击工具栏的新建文件选项<br><img src="iar_3.png" alt="工具栏创建"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>点击<code>File-&gt;New File</code><br><img src="iar_4.png" alt="菜单栏创建"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在这里我们可以看到右侧有快捷键提示，所以我们也可以使用<code>Ctrl+n</code>来创建一个未命名的空文件，创建后，会出现一个名为<code>untitled</code>的空白文件<br><img src="iar_5.png" alt="空白文件"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>我们鼠标<strong>右键单击</strong>标签栏中的空白文件名称，选择<code>Save Untitled</code>保存该文件，当然，你可可以直接使用<code>Ctrl+s</code>进行保存<br><img src="iar_6.png" alt="保存"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>一般我们保存在当前工程下的<code>app</code>目录下，如我当前的工程根目录是<code>LPLD_OSKinetis_V3/project/gsproject/</code>，那么我保存在<code>LPLD_OSKinetis_V3/project/gsproject/app</code>下，并且为这个文件起一个有意义的名字，<strong>如果是程序文件，则后缀名是<code>.c</code>，如果是头文件，后缀名是<code>.h</code></strong>，<blockquote>
<p>文件名字中，以及你的工程路径中都尽量不要包含中文，这和编码解码有关，可能导致无法预知的错误<br>文件名不要使用数字开头或者包含特殊符号，尽量以字母开头，使用字母，下划线，数字的组合，如<code>my_test1.c</code><br><img src="iar_7.png" alt="保存"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h4><ul>
<li><p>尽量将自己写的文件新建一个<code>Group</code>进行存放，以免和底层别人写的库函数混淆</p>
</li>
<li><p>创建<code>Group</code>：<code>右键单击文件目录树最顶层-&gt;Add-&gt;Add Group...</code>，之后输入你的组名字即可创建（不要有中文）<br><img src="iar_8.png" alt="Group"></p>
</li>
<li><p>添加源文件：<code>右键单击组-&gt;Add-&gt;Add Files...</code>，去刚才保存文件的目录下选择文件保存即可<br><img src="iar_9.png" alt="Add File"></p>
</li>
</ul>
<hr>
<h3 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h3><h4 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h4><ul>
<li>在智能车竞赛的开发中会建立函数，变量，建议将共同实现某一功能的程序放置在一个文件，而其他功能的程序根据所达成的功能分别创建不同的文件存放，方便查询，修改<blockquote>
<p>如建立名为<code>Motor.c</code>的文件存放电机驱动程序，<code>Motor.h</code>的文件声明全局变量，函数</p>
</blockquote>
</li>
</ul>
<h4 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h4><ul>
<li><p>在开发中会建立许多功能不同的程序文件，而他们之间往往需要引用到同一个头文件，假设有十个文件都需要引用<code>Camera.h</code>，<code>Motor.h</code>，<code>Oled.h</code>等等，那么你就需要在这十个文件的开头都写上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Camera.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Motor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Oled.h"</span></span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>不免有些重复，所以我们可以建立一个名为<code>Include.h</code>的头文件（名字可以任取，起这个是为了<strong>见名知意</strong>），而将需要多次引用的头文件写在这个文件里，其他文件只需要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Include.h"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>就可以导入这个文件中所有声明过的文件</p>
</li>
</ul>
<h5 id="头文件的一些说明"><a href="#头文件的一些说明" class="headerlink" title="头文件的一些说明"></a>头文件的一些说明</h5><ul>
<li><input checked disabled type="checkbox"> 防止重复编译<blockquote>
<p>大家应该在程序头文件中经常看到下面的代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOME_TEXT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOME_TEXT_H</span></span><br><span class="line"></span><br><span class="line">...  <span class="comment">//全局变量，函数声明，结构体定义等等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>那么，他有什么作用呢？</p>
<blockquote>
<p>直观可以看出，<code>ifndef</code>是<code>if not define</code>的缩写，前面有<code>#</code>是C语言中预编译指令的写法，也就是<em>如果<code>_SOME_TEXT_H</code>没有被定义，则定义<code>_SOME_TEXT_H</code></em>，并执行下面的代码，直到<code>#endif</code><br>我们设想一下，当多个文件<code>#include</code>同一个头文件的时候，没有上面的代码，那么每导入一次，这个头文件就会被执行（包含）一次，多次执行（包含后）就会造成<strong>重定义（Duplicate Definition）</strong>的问题而导致程序出错<br>而如果加上这段代码，第一次执行时，条件为真（True），执行下面的代码，而后来条件都为假（False），不再执行，就避免了上述问题</p>
</blockquote>
</li>
<li><p>说明</p>
<blockquote>
<p>这里的<code>_SOME_TEXT_H</code>可以任取，只要不重复，唯一标识头文件即可，一般取<strong>头文件名字大写，并以下划线分隔</strong><br>还可以使用下面的这段代码替换，但由于有的编译器不支持，所以一般还是写成上面的那种格式，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#program once</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> extern</li>
</ul>
<ul>
<li>在引用或声明全局变量时，需要用<code>extern</code>关键字修饰</li>
<li>它的功能是说明这里并不是在定义一个变量，而是声明其他地方的变量</li>
<li>函数声明不需要<code>extern</code>修饰，因为函数本身不加修饰的话就是<code>extern</code></li>
<li><code>extern</code>声明全局变量时不可以复制，这个问题经常在从<code>.c</code>文件复制变量到<code>.h</code>文件声明时出现（复制过去忘记删除初始化值），导致程序出错</li>
</ul>
<h4 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h4><blockquote>
<p>刚才已经讲过了如何创建一个<strong>组</strong>，其实对于我们文件的管理也是基于<strong>组</strong>来管理的，这里推荐几种方式</p>
<ul>
<li>即创立两个组，一个组用来放入<code>.c</code>后缀的程序文件，另一个组用来放入<code>.h</code>后缀的头文件，将二者分开管理，如经典<code>Ruler</code>程序，<code>Header</code>放头文件，<code>Source</code>放程序文件<br><img src="iar_10.png" alt="Ruler"> <img src="iar_11.png" alt="Ruler"></li>
<li>只创建一个组，将自己的头文件和程序文件都放到里面，这样的优点是同名的<code>.c</code>和<code>.h</code>文件在一起，而往往更改一个程序文件的时候同时需要更改同名的头文件，这样可以方便找到，而不用来回滑动滚轮，如我的程序<br><img src="iar_12.png" alt="Sakura"></li>
<li>你还可以根据文件功能进行分组，如底层的文件（超声波，激光，OLED，摄像头等）分为一组，跑车算法文件分为一组，这里只是介绍几种，随个人喜好你可以任意配置</li>
</ul>
</blockquote>
<hr>
<h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><ul>
<li>在<code>IAR</code>中<strong>代码编辑区域</strong>有一条不太明显的<strong>竖线</strong>，它存在的作用可能就是提醒<code>iar</code>具有分屏功能</li>
<li>具体操作：<strong>鼠标左键按住标签栏中的文件向下拖动至代码编辑区域松开</strong>即可实现分屏，<code>iar</code>可以支持多个分屏<br><img src="iar_2.gif" alt="分屏"></li>
</ul>
<h3 id="Livewatch功能"><a href="#Livewatch功能" class="headerlink" title="Livewatch功能"></a>Livewatch功能</h3><ul>
<li><p><strong>注意：这个功能只有在调试模式才会找到</strong>，如下图，编辑模式和调试模式下的<code>View</code>菜单栏</p>
</li>
<li><p>位置：<code>View-&gt;Live Watch</code><br><img src="iar_13.png" alt="Live watch"></p>
</li>
<li><p>功能：在里面输入变量名就可以实时查看变量的数值变化（非常非常常用的重要功能，如查看数值变化，断点调试等）</p>
</li>
<li><p>修改<code>Live Watch</code>刷新速度：<code>Tools-&gt;Options-&gt;Debugger-&gt;Live Watch</code><br><img src="iar_16.png" alt="liveWatch"><br><img src="iar_17.png" alt="liveWatch"></p>
<blockquote>
<p>默认是1000ms刷新一次，根据实际需要可以调节</p>
</blockquote>
</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>当程序不能按照我们的预期得到结果时，我们要使用Debug功能，设置断点</li>
<li>在指定位置设置断点，程序执行到这里以后，会停止向下执行，而保存当前的数据，我们通过多处设置断点，一步步查看数据值，即可一步步缩小程序的错误排查范围，并最终找到问题所在</li>
<li>案例：求平均值(我在VS2017中进行演示，用它的Debug功能，这和Live Watch原理是差不多的）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AD模块采集到的值</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> ad_value[<span class="number">5</span>] = &#123; <span class="number">17878</span>, <span class="number">15267</span>, <span class="number">15667</span>, <span class="number">17621</span>, <span class="number">22132</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += ad_value[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"结果是：%d\n"</span>, aver());</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<ul>
<li>执行后控制台输出结果<br><img src="iar_14.png" alt="结果"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>显然不是我们想要的正确结果，我们观察程序执行的流程，在循环语句处设置断点，如下图<br><img src="iar_15.png" alt="断点"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>然后debug，逐步执行，查看结果<br><img src="iar_1.gif" alt="debug"></li>
</ul>
</blockquote>
<blockquote>
<p>通过Debug我们发现，程序在累加的过程中<strong>和突然减小</strong>，那么显然这是由于相加后数据大于65535溢出造成的，我们可以通过更换更大的数据类型或者改用其他算法来规避这个问题<br>实际问题会复杂一些，这里只是抛砖引玉</p>
</blockquote>
<hr>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ctrl+S</code></td>
<td>保存文件，建议没事就<code>Ctrl+S</code>一下</td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>向右缩进（具体缩进多少可在<code>Tools-&gt;Options-&gt;Editor-&gt;Indent Size</code>更改）</td>
</tr>
<tr>
<td><code>Shift+Tab</code></td>
<td>向左缩进，和<code>Tab</code>一样可以选中多行文本执行</td>
</tr>
<tr>
<td><code>Ctrl+T</code></td>
<td>将选中的文本自动排版</td>
</tr>
<tr>
<td><code>Ctrl+K</code></td>
<td>注释选中文本（未选中文本注释当前行）</td>
</tr>
<tr>
<td><code>Ctrl+Shift+K</code></td>
<td>取消注释选中的文本（未选中文本取消注释当前行），注意：当选中的文本中有一行没有被注释时，命令不会执行</td>
</tr>
<tr>
<td><code>Ctrl+Tab</code></td>
<td>返回上一个界面</td>
</tr>
<tr>
<td><code>Ctrl+F</code></td>
<td>查找文本</td>
</tr>
<tr>
<td><code>Ctrl+H</code></td>
<td>查找文本并支持替换文本</td>
</tr>
<tr>
<td><code>Ctrl+B</code></td>
<td>括号匹配，会将同一个<code>()</code>或者<code>[]</code>或者<code>{}</code>的内容选中，再次执行此命令会继续扩大范围</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>iar</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="python中使用正则表达式"><a href="#python中使用正则表达式" class="headerlink" title="python中使用正则表达式"></a>python中使用正则表达式</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入re模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用match方法查看是否满足规则，如果匹配失败，返回None</span></span><br><span class="line"><span class="comment"># 字符串前加r表示这是非转义的原始字符串</span></span><br><span class="line">ret = re.match(<span class="string">r"指环王[1-3]"</span>, <span class="string">"指环王2"</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用group方法查看匹配的对象</span></span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;指环王2&apos;&gt;</span><br><span class="line">指环王2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>match()</code>方法默认判断开头</p>
</blockquote>
<h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意一个字符，<code>\n</code>除外</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配<code>[]</code>中列举的字符</td>
<td>“[1-34-6a-nA-N]”(可以匹配1-3, 4-6, a-n, A-N之间的数字或字符)</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一位数字，即1-9</td>
<td>“\d”(可以匹配0-9之间的一位数字)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配非数字</td>
<td>“\d”(可以匹配0-9之间的一位数字)</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配单个字符，包括<code>0-9</code>，<code>a-z</code>，<code>A-Z</code>，<code>_</code>(下划线)其他语言中的单个字符</td>
<td></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符，如一些特殊符号</td>
<td></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空白字符，如<code>空格</code>，<code>tab</code>，<code>\n</code>等</td>
<td></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配非空白字符</td>
<td></td>
</tr>
</tbody></table>
<h2 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>{m}</code></td>
<td>限制前面表达式的位数为m个</td>
<td><code>\d{3}</code>表示必须是一个三位数</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>限制前面表达式的位数为m-n个，注意<code>,</code>后面不要有空格</td>
<td><code>\d{1, 3}</code>表示一个1-3位数</td>
</tr>
<tr>
<td><code>？</code></td>
<td>指定前面的字符要么有一个，要么没有</td>
<td><code>021-?\d{7}</code>表示<code>-</code>可有可无，如<code>021-1234567</code>或<code>0211234567</code>都满足</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意多个字符，可以为空</td>
<td><code>.*</code>匹配所有字符</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配任意多个字符，但不能为空</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><code>.</code>默认是不匹配换行符的，如果想要匹配所有字符，可以与<code>*</code>连用并在<code>match()</code>方法中加一个参数<code>re.S</code>使之可以匹配换行，如</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.match(<span class="string">".*"</span>, <span class="string">"some \n text"</span>, re.S)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当匹配中需要使用到<code>.</code>，<code>*</code>等作为普通字符，需要前面加转义字符，如<code>\.</code>，<code>\*</code></p>
</blockquote>
<h2 id="匹配开头结尾"><a href="#匹配开头结尾" class="headerlink" title="匹配开头结尾"></a>匹配开头结尾</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配结尾</td>
</tr>
</tbody></table>
<h2 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td>匹配左右任意一个表达式</td>
</tr>
<tr>
<td><code>(ab)</code></td>
<td>1. 括号内的优先运算 2. 将括号中的字符作为一个分组，在python中根据括号的先后顺序，可分别使用<code>group(1)</code>，<code>group(2)</code>取出分组的数据，<a href="#()使用演示">使用演示</a></td>
</tr>
<tr>
<td><code>\num</code></td>
<td>引用第<code>num</code>组匹配到的字符串，<a href="#\使用演示">使用演示</a></td>
</tr>
<tr>
<td><code>(?P&lt;name&gt;)</code></td>
<td>分组起别名</td>
</tr>
<tr>
<td>(?P=name)</td>
<td>引用别名为<code>name</code>分组匹配到的字符串，<a href="#别名使用演示">使用演示</a></td>
</tr>
</tbody></table>
<h3 id="使用演示"><a href="#使用演示" class="headerlink" title="()使用演示"></a><code>()</code>使用演示</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""输入邮箱用户名为4-20位"""</span></span><br><span class="line">    email = input(<span class="string">"请输入您的邮箱："</span>)</span><br><span class="line">    <span class="comment"># 利用()设置分组，并且使或运算仅限于163与126</span></span><br><span class="line">    result = re.match(<span class="string">r"^([0-9a-zA-Z_]&#123;4,20&#125;)@(163|126)\.com$"</span>, email)</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="comment"># 利用group取出分组的值</span></span><br><span class="line">        print(<span class="string">"您注册的用户名是&#123;0&#125;，邮箱类型是&#123;1&#125;邮箱"</span>.format(result.group(<span class="number">1</span>), result.group(<span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"格式错误，请重新输入"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行程序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入您的邮箱：zhangsan_123@126.com</span><br><span class="line">您注册的用户名是zhangsan_123，邮箱类型是126邮箱</span><br></pre></td></tr></table></figure>

<h3 id="使用演示-1"><a href="#使用演示-1" class="headerlink" title="\使用演示"></a><code>\</code>使用演示</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"请重复输入两次用户名和密码\n用户名与密码间以,间隔\n第一次和第二次间用;间隔"</span>)</span><br><span class="line">    name_pass = input(<span class="string">"==&gt;"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        result = re.match(<span class="string">r"^([a-zA-Z0-9]&#123;3,10&#125;),([a-zA-Z0-9]&#123;6,16&#125;);\1,\2$"</span>, name_pass)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            print(<span class="string">"OK"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name_pass = input(<span class="string">"请重新输入==&gt;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行程序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请重复输入两次用户名和密码</span><br><span class="line">用户名与密码间以,间隔</span><br><span class="line">第一次和第二次间用;间隔</span><br><span class="line">==&gt;jack,123456;jack,654321</span><br><span class="line">请重新输入==&gt;jack,123456;john,123456</span><br><span class="line">请重新输入==&gt;jack,123456;jack,123456</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="别名使用演示"><a href="#别名使用演示" class="headerlink" title="别名使用演示"></a>别名使用演示</h3><ul>
<li>上面的判断代码可以写为<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = re.match(<span class="string">r"^(?P&lt;name&gt;[a-zA-Z0-9]&#123;3,10&#125;),(?P&lt;pass&gt;[a-zA-Z0-9]&#123;6,16&#125;);(?P=name),(?P=pass)$"</span>, name_pass)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro解决idea,pycharm,clion等菜单中文乱码小方框</title>
    <url>/2019/09/26/%E8%A7%A3%E5%86%B3idea-pycharm-clion%E7%AD%89%E8%8F%9C%E5%8D%95%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%B0%8F%E6%96%B9%E6%A1%86/</url>
    <content><![CDATA[<a id="more"></a>

<blockquote>
<p>这是由于字体不支持中文造成的</p>
<ul>
<li>解决方法<br>终端下载字体</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ide设置<code>Appearance-&gt;Theme下勾选use custom font-&gt;选择WenQuanYi micro hei</code>更改字体<br><img src="jet_1.png" alt="更改字体"></p>
</blockquote>
<blockquote>
<p>接下来就可以看到中文了<br><img src="jet_2.png" alt="更改字体"></p>
</blockquote>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>idea乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>python中range与xrange</title>
    <url>/2019/09/24/python%E4%B8%ADrange%E4%B8%8Exrange/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li><code>range(start, stop, step)</code>与<code>xrange(start, stop, step)</code>用法相同<ul>
<li>start：起始数字，可不填，默认0</li>
<li>stop：结束数字，必须填</li>
<li>step：步长，可不填，默认1</li>
</ul>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><code>range()</code>直接生成一个列表，需要立即开辟内存空间</li>
<li><code>xrange()</code>生成一个可以迭代的对象，即用即取</li>
<li>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python2</span></span><br><span class="line"><span class="comment"># *-* coding: utf-8 *-*</span></span><br><span class="line">print(<span class="string">"测试range"</span>)</span><br><span class="line">my_range = range(<span class="number">10</span>)</span><br><span class="line">print(my_range)</span><br><span class="line">print(<span class="string">"测试xrange"</span>)</span><br><span class="line">my_xrange = xrange(<span class="number">10</span>)</span><br><span class="line">print(my_xrange)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试range</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">测试xrange</span><br><span class="line">xrange(10)</span><br></pre></td></tr></table></figure>

<ul>
<li>而使用for循环输出结果一致<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(3):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">for i in xrange(3):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2019/09/23/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>迭代是访问集合元素的一种方式，迭代器是一种可以记住遍历的位置的对象，从集合的第一个元素开始访问知道所有的元素访问完结束</p>
</blockquote>
<h3 id="查看是否可以迭代"><a href="#查看是否可以迭代" class="headerlink" title="查看是否可以迭代"></a>查看是否可以迭代</h3><ul>
<li>可迭代的对象可以使用<code>isinstance</code>验证与<code>Iterable</code>的关系，返回<code>True</code>则可以迭代</li>
<li>迭代器可以使用<code>isinstance</code>验证与<code>Iterator</code>的关系，返回<code>True</code>则可以迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">print(isinstance([<span class="number">11</span>, <span class="number">22</span>], Iterable))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="定义可以迭代的类"><a href="#定义可以迭代的类" class="headerlink" title="定义可以迭代的类"></a>定义可以迭代的类</h2><ul>
<li><p>如果想让创建的对象可以迭代，必须实现<code>__iter__()</code>方法，且需要返回一个迭代器</p>
<blockquote>
<p>返回的迭代器也是一个对象，这个对象要包含<code>__iter__()</code>方法和<code>__next__()</code>，方法，其中<code>__next__()</code>方法的返回值就是迭代的内容</p>
<blockquote>
<p>可以重新写一个迭代器的类，用于返回值<br>可以直接返回<code>self</code>，并在本类中实现<code>__next__()</code></p>
</blockquote>
</blockquote>
</li>
<li><p>两个类实现迭代</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.names = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_iterator</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回一个迭代器对象</span></span><br><span class="line">        <span class="keyword">return</span> my_itor(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_itor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; len(self.obj.names):</span><br><span class="line">            ret = self.obj.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 超过容量抛出StopIteration来终止迭代</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iterator = my_iter()</span><br><span class="line">my_iterator.my_iterator(<span class="string">"张三"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"李四"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"王五"</span>)</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_iterator:</span><br><span class="line">    print(temp)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现了迭代功能</p>
</blockquote>
<ul>
<li>一个类实现迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.names = list()</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_iterator</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回自身,会自动调用__next__()方法</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; len(self.names):</span><br><span class="line">            ret = self.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 超过容量抛出StopIteration来终止迭代</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iterator = my_iter()</span><br><span class="line">my_iterator.my_iterator(<span class="string">"张三"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"李四"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"王五"</span>)</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_iterator:</span><br><span class="line">    print(temp)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也实现了迭代功能</p>
</blockquote>
<ul>
<li>迭代器在类型转换中的作用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list = [ <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span> ]</span><br><span class="line">my_tuple = tuple(my_list)</span><br><span class="line">print(my_tuple)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(11, 22, 33)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实质上是先生成一个空的元组，然后调用<code>my_list</code>中的迭代方法，向<code>my_tuple</code>中添加内容</p>
</blockquote>
<h3 id="iter-和next-方法"><a href="#iter-和next-方法" class="headerlink" title="iter()和next()方法"></a><code>iter()</code>和<code>next()</code>方法</h3><ul>
<li><code>iter()</code>用于获取可迭代对象的迭代器，实质上是调用了可迭代对象的<code>__iter__()</code>方法</li>
<li><code>next()</code>方法用于获取迭代对象的下一条数据，迭代完成后抛出<code>StopIteration</code>的异常终止迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1_iter = iter(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li>生成器是一种特殊的迭代器<h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4></li>
<li>将列表生成式的<code>[]</code>换成<code>()</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x7f924b6088d0</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ul>
<li>使用<code>yield</code>创建</li>
<li><code>yield</code>会返回它后面的值，并将程序停留于此，等待下一次调用从当前位置开始执行</li>
<li>示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波纳奇数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    print(<span class="string">"---1---"</span>)</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        print(<span class="string">"---2---"</span>)</span><br><span class="line">        <span class="comment"># 如果一个函数中有yield语句，那么这个就不再是函数，而是一个生成器的模板</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        print(<span class="string">"---3---"</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"---4---"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在调用create_num的时候，发现这个函数中有yield，那么此时不是调用函数，而是创建一个生成器对象</span></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> obj:</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">0</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">1</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">1</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">2</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">3</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见只输出了一次<code>---1---</code>，而当第二次循环的时候没有进行初始化，直接在<code>while</code>循环中的<code>yield</code>下面继续执行，即<code>yield</code>返回后面的<code>a</code>后，停留在当前位置，等待下一次执行</p>
</blockquote>
<blockquote>
<p>另外，当使用同一个模板创建了多个生成器时，相互之间互不影响</p>
<ul>
<li>当生成器执行完成后有返回值时，可以使用异常获取</li>
</ul>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"遍历结束"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 使用next()启用生成器</span></span><br><span class="line">        ret = next(obj)</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 获取返回值</span></span><br><span class="line">        print(e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">遍历结束</span><br></pre></td></tr></table></figure>

<h3 id="启动生成器"><a href="#启动生成器" class="headerlink" title="启动生成器"></a>启动生成器</h3><h4 id="使用next-启动"><a href="#使用next-启动" class="headerlink" title="使用next()启动"></a>使用<code>next()</code>启动</h4><blockquote>
<p>上面的例子中都是使用<code>next()</code>启动的，这里不再介绍</p>
</blockquote>
<h4 id="使用send-启动"><a href="#使用send-启动" class="headerlink" title="使用send()启动"></a>使用<code>send()</code>启动</h4><ul>
<li><code>send()</code>中可以填入参数作为<code>yield</code>执行后的返回值<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        res = <span class="keyword">yield</span> a</span><br><span class="line">        print(res)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"遍历结束"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line">ret = next(obj)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = obj.send(<span class="string">"你好"</span>)</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">你好</span><br><span class="line">1</span><br><span class="line">你好</span><br><span class="line">1</span><br><span class="line">你好</span><br><span class="line">2</span><br><span class="line">你好</span><br><span class="line">3</span><br><span class="line">你好</span><br><span class="line">遍历结束</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，<code>send()</code>将<code>&quot;你好&quot;</code>作为参数传递给了<code>yield</code>执行后的结果<code>res</code>，并且，它是下一次进入函数才传递的，这点可以从结果中先输出<code>0</code>(<code>print(ret)</code>)，后输出<code>你好</code>(<code>print(res)</code>)可以看出来<br>因此，<code>send()</code>如果作为第一次启动生成器时，必须使用<code>obj.send(None)</code>，即不传入参数，或使用<code>next(obj)</code>来第一次启动</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——协程</title>
    <url>/2019/09/23/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h2><h3 id="使用yield和next-创建协程"><a href="#使用yield和next-创建协程" class="headerlink" title="使用yield和next()创建协程"></a>使用<code>yield</code>和<code>next()</code>创建协程</h3><ul>
<li>关于<a href="http://www.duguosheng.xyz/2019/09/23/迭代器与生成器/" target="_blank" rel="noopener">yield和next()</a><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----1----"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"****2****"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    next(task1())</span><br><span class="line">    next(task2())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<h3 id="使用greenlet"><a href="#使用greenlet" class="headerlink" title="使用greenlet"></a>使用<code>greenlet</code></h3><ul>
<li><p>如果没有可以使用<code>pip3</code>安装<code>greenlet</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install greenlet</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>greenlet</code>对于<code>yield</code>进行了封装，使用户可以按照正常写函数的方式实现多任务</p>
</li>
<li><p>使用：</p>
<ul>
<li><code>gr = greenlet(目标函数)</code>创建对象</li>
<li><code>gr.switch()</code>切换执行任务</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----1----"</span>)</span><br><span class="line">        <span class="comment"># 切换到task2</span></span><br><span class="line">        gr2.switch()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"****2****"</span>)</span><br><span class="line">        <span class="comment"># 切换到task1</span></span><br><span class="line">        gr1.switch()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet.greenlet(task1)</span><br><span class="line">gr2 = greenlet.greenlet(task2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到task1</span></span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用gevent"><a href="#使用gevent" class="headerlink" title="使用gevent"></a>使用gevent</h3><ul>
<li>如果没有可以使用下面的命令安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install gevent</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>gevent</code>是在<code>greenlet</code>的基础上再次封装的</p>
</blockquote>
<ul>
<li><code>gevent</code>遇到延时操作自动切换任务，这个延时操作不能是<code>time.sleep()</code>而需要是<code>gevent.sleep()</code></li>
<li>代码示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># 获取当前协程id</span></span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        gevent.sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g2 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现三者交替执行，实现了多任务</p>
</blockquote>
<ul>
<li>上述创建协程方法有些麻烦，还可以使用<code>joinall([任务1, 任务2, ...])</code>的方式，它的参数是一个列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">gevent.joinall([gevent.spawn(fun, <span class="number">3</span>),</span><br><span class="line">                gevent.spawn(fun, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如果原来的程序中使用了time-sleep-进行延时"><a href="#如果原来的程序中使用了time-sleep-进行延时" class="headerlink" title="如果原来的程序中使用了time.sleep()进行延时"></a>如果原来的程序中使用了<code>time.sleep()</code>进行延时</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g2 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，两个任务并没有交替执行，而是一个执行完了另一个再执行，并没有实现多任务</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>在执行前之前写如下代码，使用patch_all()解决<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>wordPress文章版本</title>
    <url>/2019/09/22/wordPress%E6%96%87%E7%AB%A0%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<a id="more"></a>

<p>修改站点的<code>wp-config.php</code>文件，在其中添加如下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'WP_POST_REVISIONS'</span>, <span class="number">0</span>);     <span class="comment">//不启用修订版本</span></span><br><span class="line">define(<span class="string">'WP_POST_REVISIONS'</span>, <span class="number">3</span>);     <span class="comment">//共保存3个版本</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>文章版本</tag>
        <tag>wordPress配置</tag>
      </tags>
  </entry>
  <entry>
    <title>wordPress的文章和页面</title>
    <url>/2019/09/22/wordPress-1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="文章和页面"><a href="#文章和页面" class="headerlink" title="文章和页面"></a>文章和页面</h2><blockquote>
<p>文章：是网站的主要内容<br>页面：是网站的其他一些信息</p>
</blockquote>
<ul>
<li>以<strong>哔哩哔哩</strong>网为例<blockquote>
<p>它的主要内容是视频，所以打开它的网站可以看到许多视频推送，这就是它的<strong>文章</strong><br><img src="wp_1.png" alt="文章"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>而下拉到末尾，可以看到其他一些次要信息，这些就是<strong>页面</strong><br><img src="wp_2.png" alt="页面"></p>
</blockquote>
<ul>
<li>由于<strong>文章</strong>内容繁杂，所以可以创建分类便于管理和用户查询，而页面没有分类功能<br><img src="wp_2.png" alt="分类"></li>
</ul>
]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>wordpress一些基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>时域分析</title>
    <url>/2019/09/22/%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="一阶动态性能指标"><a href="#一阶动态性能指标" class="headerlink" title="一阶动态性能指标"></a>一阶动态性能指标</h2><p><img src="sy_1.png" alt="一阶"></p>
]]></content>
      <categories>
        <category>自动控制原理</category>
      </categories>
      <tags>
        <tag>时域分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——进程</title>
    <url>/2019/09/20/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="进程及其状态"><a href="#进程及其状态" class="headerlink" title="进程及其状态"></a>进程及其状态</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序：例如<code>xxx.py</code>这是程序，是静态的</li>
<li>进程：程序运行起来后，<strong>代码+用到的资源</strong>称为进程</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>任务数往往大于CPU核数，因而一定有一些任务正在进行，另一些任务等待，这样就导致了进程有不同的状态<br><img src="pro_1.png" alt="进程的状态"></p>
<ul>
<li>就绪态：运行条件都满足，等待CPU调度</li>
<li>执行态：CPU正在执行</li>
<li>等待态：等待某些条件满足，例如一个程序<code>sleep</code>中</li>
</ul>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="使用multiprocessing模块"><a href="#使用multiprocessing模块" class="headerlink" title="使用multiprocessing模块"></a>使用<code>multiprocessing</code>模块</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testProcess</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"process------"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    my_pro = multiprocessing.Process(target=testProcess)</span><br><span class="line">    <span class="comment"># 启动进程</span></span><br><span class="line">    my_pro.start()</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><blockquote>
<p>线程间资源共享<br>进程间资源不共享，是独立的</p>
<ul>
<li>举例说明</li>
</ul>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"test1-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"test2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pro</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"测试进程"</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=test1)</span><br><span class="line">    p2 = multiprocessing.Process(target=test2)</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_thr</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"测试线程"</span>)</span><br><span class="line">    t1 = threading.Thread(target=test1)</span><br><span class="line">    t2 = threading.Thread(target=test2)</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># test_pro()</span></span><br><span class="line">    test_thr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试线程</span><br><span class="line">test1-----10</span><br><span class="line">test2-----20</span><br></pre></td></tr></table></figure>

<ul>
<li>改变<code>main()</code>函数<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    test_pro()</span><br><span class="line">    <span class="comment"># test_thr()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>再次执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试进程</span><br><span class="line">test1-----10</span><br><span class="line">test2-----10</span><br></pre></td></tr></table></figure>

<ul>
<li>实现进程间通信：<strong><code>Queue</code></strong><blockquote>
<p><code>Queue</code>是队列的意思，遵循先进先出的原则<br>一个进程向<code>Queue</code>中写入数据，另一个进程从<code>Queue</code>中取出，就可实现通信<br>这是一种比较低端的方式，还可使用<code>socket</code>，<code>redis</code>等实现</p>
</blockquote>
</li>
<li>代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_from_web</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="string">"""模拟从网上下载数据"""</span></span><br><span class="line">    data = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向对列中写入数据</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> data:</span><br><span class="line">        queue.put(temp)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"已全部存入队列"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_data</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="string">"""数据处理"""</span></span><br><span class="line">    d_data = list()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        data = queue.get()</span><br><span class="line">        d_data.append(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"接收完成--%s"</span> % d_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程，将队列的引用当作实参传递到里面</span></span><br><span class="line">    p1 = multiprocessing.Process(target=download_from_web, args=(queue, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=analysis_data, args=(queue, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已全部存入队列</span><br><span class="line">接收完成--[11, 22, 33, 44]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>成功实现了进程间的通讯</p>
</blockquote>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><blockquote>
<p>进程不多时可以直接使用<code>Process</code>动态生成多个进程，但如果所需进程过多，手动创建进程工作量太大，且不利于cpu的运行，因而可以使用进程池<code>Pool</code><br>进程池是资源进程、管理进程组成的技术的应用(引自<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%B1%A0/3765641?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</p>
<blockquote>
<p>资源进程：预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。<br>管理进程：管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。<br>这样进程使有进有出，有序管理</p>
<ul>
<li>代码</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义进程池</span></span><br><span class="line">po = Pool(<span class="number">3</span>)    <span class="comment"># 3指最多同时执行3个进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加进程队列，target指进程地址，args是进程函数的参数，是一个元组</span></span><br><span class="line">po.apply_asyns(target, args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池</span></span><br><span class="line">po.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待po中所有子进程完成，必须在close()语句之后，没有这句代码，可以使主进程先结束，子进程也无法继续进行</span></span><br><span class="line">po.join()</span><br></pre></td></tr></table></figure>

<ul>
<li>案例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">"&#123;0&#125;开始执行，进程号&#123;1&#125;"</span>.format(msg, os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg, <span class="string">"执行完毕，耗时%f"</span> % (t_stop-t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    po = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        po.apply_async(worker, (i+<span class="number">1</span>, ))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---start---"</span>)</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"----end----"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---start---</span><br><span class="line">1开始执行，进程号22044</span><br><span class="line">2开始执行，进程号22045</span><br><span class="line">3开始执行，进程号22046</span><br><span class="line">1 执行完毕，耗时0.175232</span><br><span class="line">4开始执行，进程号22044</span><br><span class="line">3 执行完毕，耗时0.217286</span><br><span class="line">5开始执行，进程号22046</span><br><span class="line">5 执行完毕，耗时0.187288</span><br><span class="line">6开始执行，进程号22046</span><br><span class="line">4 执行完毕，耗时0.613512</span><br><span class="line">7开始执行，进程号22044</span><br><span class="line">2 执行完毕，耗时0.860506</span><br><span class="line">8开始执行，进程号22045</span><br><span class="line">7 执行完毕，耗时0.470875</span><br><span class="line">9开始执行，进程号22044</span><br><span class="line">6 执行完毕，耗时0.969476</span><br><span class="line">10开始执行，进程号22046</span><br><span class="line">9 执行完毕，耗时0.312829</span><br><span class="line">8 执行完毕，耗时0.909825</span><br><span class="line">10 执行完毕，耗时0.897377</span><br><span class="line">----end----</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以从进程号看出一直在重复利用<code>22044, 22045, 22046</code>三个pid<br>从输出来看，可以看出来同一时间最多只有三个进程执行</p>
</blockquote>
<ul>
<li>注意：<strong>在进程池间使用队列通信，不能使用<code>multiprocessing.Queue()</code>，而要使用<code>multiprocessing.Manager().Queue()</code></strong></li>
</ul>
<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><ul>
<li>实现文件复制功能<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_file</span><span class="params">(queue, file_name, src_dir, dest_dir)</span>:</span></span><br><span class="line">    src_file = open(src_dir+<span class="string">"/"</span>+file_name, <span class="string">"rb"</span>)</span><br><span class="line">    <span class="comment"># print("正在复制%s" % src_file)</span></span><br><span class="line">    content = src_file.read()</span><br><span class="line">    dest_file = open(dest_dir+<span class="string">"/"</span>+file_name, <span class="string">"wb"</span>)</span><br><span class="line">    dest_file.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果拷贝完了文件，就向队列写入数据，表示下载完成</span></span><br><span class="line">    queue.put(file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取用户需要copy的文件名</span></span><br><span class="line">    src_dir = input(<span class="string">"请输入要复制的文件夹："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个新的文件夹</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dest_dir = src_dir+<span class="string">"_copy"</span></span><br><span class="line">        os.mkdir(dest_dir)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"该文件夹已存在"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件夹中所有的待copy的文件名字listdir()</span></span><br><span class="line">    file_names = os.listdir(src_dir)</span><br><span class="line">    total_num = len(file_names)</span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    po = multiprocessing.Pool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    queue = multiprocessing.Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向进程池添加复制任务</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_names:</span><br><span class="line">        po.apply_async(copy_file, (queue, file_name, src_dir, dest_dir))</span><br><span class="line"></span><br><span class="line">    po.close()</span><br><span class="line">    <span class="comment"># po.join()</span></span><br><span class="line">    <span class="comment"># 显示执行进度</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        file_name = queue.get()</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">        now_step = current_num/total_num</span><br><span class="line">        print(<span class="string">"\r已拷贝%s-------进度%.2f %%              "</span> % (file_name, <span class="number">100</span>*now_step), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">if</span> now_step == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——线程</title>
    <url>/2019/09/19/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Thread创建线程"><a href="#Thread创建线程" class="headerlink" title="Thread创建线程"></a>Thread创建线程</h2><h3 id="使用Threading模块"><a href="#使用Threading模块" class="headerlink" title="使用Threading模块"></a>使用Threading模块</h3><ul>
<li><p>语法格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入threading模块</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">my_thread = threading.Thread(target=函数名)</span><br><span class="line"><span class="comment"># 开启线程</span></span><br><span class="line">my_thread.start()</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thrd = threading.Thread(target=testThread)</span><br><span class="line">    thrd.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果： 每隔一秒打印一次hello</p>
</blockquote>
<h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><ul>
<li>步骤<ul>
<li>创建类，继承Thread类</li>
<li>在这个类中重写<code>run()</code>方法</li>
</ul>
</li>
<li>示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="string">"""继承Thread类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写run()方法"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mythread = MyThread()</span><br><span class="line">    <span class="comment"># 调用start()方法后会自动调用run()方法</span></span><br><span class="line">    mythread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果：每隔一秒打印一次hello</p>
</blockquote>
<h2 id="查看线程数量"><a href="#查看线程数量" class="headerlink" title="查看线程数量"></a>查看线程数量</h2><ul>
<li><p>使用Threading模块中的<code>enumerate()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(threading.enumerate())</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">"thread---1"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">"thread---2"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thrd1 = threading.Thread(target=testThread1)</span><br><span class="line">    thrd2 = threading.Thread(target=testThread2)</span><br><span class="line">    thrd1.start()</span><br><span class="line">    thrd2.start()</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">[&lt;_MainThread(MainThread, started 140351833364096)&gt;, &lt;Thread(Thread-1, sta</span><br><span class="line">rted 140351824549632)&gt;, &lt;Thread(Thread-2, started 140351746602752)&gt;]</span><br><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">[&lt;_MainThread(MainThread, started 140351833364096)&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 只有调用了<code>start()</code>方法时才会创建线程并开始执行，而使用<code>Thread(target=)</code>只是创建一个对象，所以只有放在<code>start()</code>后和线程结束前才可以使用<code>enumerate()</code>查看</p>
</blockquote>
<ul>
<li>由运行结果可见，当一个线程结束后，不会再打印它的信息，即列表中不再存在，由此可以判断其他线程是否都结束<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当只有主线程的时候</span></span><br><span class="line"><span class="keyword">if</span> len(threading.enumerate()) == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="线程中传递参数args"><a href="#线程中传递参数args" class="headerlink" title="线程中传递参数args"></a>线程中传递参数args</h2><ul>
<li>线程中传递的参数使用args指定，必须是一个元组<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_list1 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">g_list2 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(list1)</span>:</span></span><br><span class="line">    list1.append(<span class="number">33</span>)</span><br><span class="line">    print(<span class="string">"在test1中，list1=%s"</span> % list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(list1, list2)</span>:</span></span><br><span class="line">    list1.append(<span class="number">44</span>)</span><br><span class="line">    list2.append(<span class="number">33</span>)</span><br><span class="line">    print(<span class="string">"在test2中，list1=%s"</span> % list1)</span><br><span class="line">    print(<span class="string">"在test2中，list2=%s"</span> % list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># target指定函数地址</span></span><br><span class="line">    <span class="comment"># args指定参数，必须是一个元组</span></span><br><span class="line">    t1 = threading.Thread(target=test1, args=(g_list1, ))  <span class="comment"># 当参数只有一个时，使用args=(temp, )的方式</span></span><br><span class="line">    t2 = threading.Thread(target=test2, args=(g_list1, g_list2))</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在test1中，list1=[11, 22, 33]</span><br><span class="line">在test2中，list1=[11, 22, 33, 44]</span><br><span class="line">在test2中，list2=[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁解决资源竞争"><a href="#互斥锁解决资源竞争" class="headerlink" title="互斥锁解决资源竞争"></a>互斥锁解决资源竞争</h2><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><ul>
<li>由于多线程共用资源，会产生资源竞争的问题，如下面的代码，让两个线程同时对全局变量执行加一的操作，若不存在资源竞争，应当结果为二者循环次数之和，而结果往往小于此</li>
<li>这是因为当一个线程拿到数据加一后，可能还未存放结果，这个数据就被另一个线程调用，这样就会使数值低于预期<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"thread2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_2</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"thread2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=add_1, args=(<span class="number">1000000</span>, ))</span><br><span class="line">    t2 = threading.Thread(target=add_2, args=(<span class="number">1000000</span>, ))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 确保执行完毕,每隔1s判断一次</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(threading.enumerate()) == <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">"main-----%d"</span> % g_num)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread2----<span class="number">-1197292</span></span><br><span class="line">thread2----<span class="number">-1253537</span></span><br><span class="line">main----<span class="number">-1253537</span>    <span class="comment"># 这个结果不一定，但往往小于预期的2000000</span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li><p>当对象被线程调用时给对象上锁，只有使用完成后才释放，保证同一资源只有一个线程在调用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建锁，默认未锁定</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上例中的<code>add_1()</code>为例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line">    print(<span class="string">"thread1-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_2()改变的格式同add_1()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread1----<span class="number">-1000000</span></span><br><span class="line">thread2----<span class="number">-2000000</span></span><br><span class="line">main----<span class="number">-2000000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的改动中将锁放在了循环之外，因而当一个线程抢到资源后后全部执行结束后才释放，在实际开发中，应当尽量减小锁的范围，本例中可将锁置于循环之中<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        mutex.acquire()</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()</span><br><span class="line">    print(<span class="string">"thread1-----%d"</span> % g_num)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread1----<span class="number">-1971999</span>     <span class="comment"># 两个线程交替拿到资源</span></span><br><span class="line">thread2----<span class="number">-2000000</span></span><br><span class="line">main----<span class="number">-2000000</span></span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，如<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexA.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexB.release()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>上例中，<code>test1()</code>先将<code>mutexA</code>上锁，<code>test2()</code>先将<code>mutexB</code>上锁<br>当休眠结束后，<code>test1()</code>要给<code>mutexB</code>上锁，之后才能释放<code>mutexA</code>，而<code>mutexB</code>已经被<code>test2()</code>上锁占用，因而要等待<code>test2()</code>释放<code>mutexB</code><br>而<code>test2()</code>要释放<code>mutexB</code>，又要等待<code>test1()</code>释放<code>mutexA</code>，这样两者都不会进行到下一步，从而产生了<strong>死锁</strong> </p>
</blockquote>
<ul>
<li>避免：<ul>
<li>程序设计中避免</li>
<li>添加超时算法等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>利用tcp下载文件</title>
    <url>/2019/09/19/%E5%88%A9%E7%94%A8tcp%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>即要接收文件的一方<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取服务器的ip port</span></span><br><span class="line">    dest_ip = input(<span class="string">"请输入对方的ip："</span>)</span><br><span class="line">    dest_port = input(<span class="string">"请输入对方的port："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接服务器</span></span><br><span class="line">    tcp_socket.connect((dest_ip, int(dest_port)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取下载的文件名称</span></span><br><span class="line">    download_file_name = input(<span class="string">"请输入要下载的文件名："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将文件名字发送到服务器</span></span><br><span class="line">    tcp_socket.send(download_file_name.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收文件数据</span></span><br><span class="line">    recv_data = tcp_socket.recv(<span class="number">1024</span>*<span class="number">1024</span>)  <span class="comment"># 1k*1024=1M</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存接收到的数据到一个文件中，如果内容为空则不创建文件</span></span><br><span class="line">    <span class="keyword">if</span> recv_data:</span><br><span class="line">        <span class="keyword">with</span> open (<span class="string">"[new]"</span>+download_file_name, <span class="string">"wb"</span>) <span class="keyword">as</span> d_file:</span><br><span class="line">            d_file.write(recv_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file_to_client</span><span class="params">(client_socket, client_addr)</span>:</span></span><br><span class="line">    <span class="comment"># 接收客户端要下载的文件名</span></span><br><span class="line">    file_name = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(<span class="string">"客户端&#123;0&#125;要下载的文件是&#123;1&#125;"</span>.format(client_addr, file_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开文件读取数据</span></span><br><span class="line">    file_content = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dl_file = open(file_name, <span class="string">"rb"</span>)</span><br><span class="line">        file_content = dl_file.read()</span><br><span class="line">        dl_file.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"没有该文件(%s)"</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close</span></span><br><span class="line">    <span class="keyword">if</span> file_content:</span><br><span class="line">        <span class="comment"># 回送数据</span></span><br><span class="line">        client_socket.send(file_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_serve_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定本地信息</span></span><br><span class="line">    tcp_serve_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让默认套接字由主动变为被动,listen</span></span><br><span class="line">    tcp_serve_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待客户端的连接accept,未连接到客户端会进入堵塞</span></span><br><span class="line">        print(<span class="string">"等待客户端连接..."</span>)</span><br><span class="line">        client_socket, client_addr = tcp_serve_socket.accept()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送文件</span></span><br><span class="line">        send_file_to_client(client_socket, client_addr)</span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">"已为客户服务完成"</span>)</span><br><span class="line"></span><br><span class="line">    tcp_serve_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>首先先在当前目录下新建一个文件，以供调试使用，假设新建一个名为<code>test.txt</code>的文件，并在里面写下一些内容，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is some text</span><br><span class="line">这是一写文本</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看自己的ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般使用</span></span><br><span class="line">ifconfig | grep inet</span><br><span class="line"><span class="comment"># archlinux使用</span></span><br><span class="line">ip addr | grep inet</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>记住ip地址，假设为<code>123.12.10.154</code></p>
</blockquote>
<h3 id="同时运行两端代码"><a href="#同时运行两端代码" class="headerlink" title="同时运行两端代码"></a>同时运行两端代码</h3><ul>
<li><p>客户端依次输入ip地址，端口号(程序中指定了7788，可更改为1024–65535之间的其他数字)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入对方的ip：123.12.10.154</span><br><span class="line">请输入对方的port：7788</span><br><span class="line">请输入要下载的文件名：test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器中自动打印出了如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">等待客户端连接...</span><br><span class="line">客户端(&apos;10.128.150.40&apos;, 34878)要下载的文件是test.txt</span><br><span class="line">已为客户服务完成</span><br><span class="line">等待客户端连接...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>打开文件管理器，发现在当前目录下出现了一个名为<code>[new]test.txt</code>的文件，打开，查看内容，发现与<code>test.txt</code>中内容一致，说明代码执行成功</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>enumerate()函数和推导式生成列表</title>
    <url>/2019/09/17/enumerate-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8E%A8%E5%AF%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul>
<li><code>enumerate()</code> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>以下是 enumerate() 方法的语法:<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数</p>
<blockquote>
<p>sequence – 一个序列、迭代器或其他支持迭代对象。<br>start – 下标起始位置。<br>返回值<br>返回 enumerate(枚举) 对象。</p>
</blockquote>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">letters = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">gnt = enumerate(letters, start=<span class="number">1</span>)</span><br><span class="line">print(gnt)</span><br><span class="line"><span class="comment"># 需要调用list方法</span></span><br><span class="line">my_enum = list(gnt)</span><br><span class="line">print(my_enum)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;enumerate object at <span class="number">0x7f67e867f2d0</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="实现给文件的每行增加行号"><a href="#实现给文件的每行增加行号" class="headerlink" title="实现给文件的每行增加行号"></a>实现给文件的每行增加行号</h2><ul>
<li><p>新建文本文件<code>test.txt</code>，里面写上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗前明月光</span><br><span class="line">疑是地上霜</span><br><span class="line">举头望明月</span><br><span class="line">低头思故乡</span><br></pre></td></tr></table></figure>
</li>
<li><p>在python文件写入以下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    lines = my_file.readlines()</span><br><span class="line">    lines = [<span class="string">"#"</span>+str(index+<span class="number">1</span>)+<span class="string">" "</span>+line <span class="keyword">for</span> index, line <span class="keyword">in</span> list(enumerate(lines))]  <span class="comment"># 推导式生成推导式</span></span><br><span class="line">    <span class="comment"># 也可写成lines = ["#"+str(index+1)+" "+line for index, line in enumerate(lines)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    my_file.writelines(lines)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>打开<code>test.txt</code>查看执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 窗前明月光</span><br><span class="line">#2 疑是地上霜</span><br><span class="line">#3 举头望明月</span><br><span class="line">#4 低头思故乡</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>close()关闭流</title>
    <url>/2019/09/17/close-%E5%85%B3%E9%97%AD%E6%B5%81/</url>
    <content><![CDATA[<a id="more"></a>
<ul>
<li>为了确保打开的文件对象正常关闭，一般结合异常机制的<code>finally</code>或者<code>with</code>关键字实现无论何种情况都能关闭打开的文件对象</li>
</ul>
<h2 id="使用finally"><a href="#使用finally" class="headerlink" title="使用finally"></a>使用finally</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">r"my_text.txt"</span>, <span class="string">"a"</span>)</span><br><span class="line">    my_str = <span class="string">"hello"</span></span><br><span class="line">    f.write(str)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h2 id="使用with"><a href="#使用with" class="headerlink" title="使用with"></a>使用with</h2><ul>
<li><code>with</code>关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出<code>with</code>块，都能确保文件正常的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    my_file.write(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行完后，可以自动关闭文件</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数嵌套</title>
    <url>/2019/09/17/python%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>封装——数据隐藏,外部无法访问<strong>嵌套函数</strong></li>
<li>提高代码复用率</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"f2"</span>)</span><br><span class="line"></span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"><span class="comment"># f2() 不可在外部调用</span></span><br></pre></td></tr></table></figure>

<h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><ul>
<li><strong>global</strong>声明全局变量</li>
<li><strong>ninlocal</strong>声明外部变量</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> b</span><br><span class="line">        b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zip()并行迭代</title>
    <url>/2019/09/17/%E4%BD%BF%E7%94%A8zip-%E5%B9%B6%E8%A1%8C%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li><p>实例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = (<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>)</span><br><span class="line">ages = (<span class="number">20</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>)</span><br><span class="line">jobs = (<span class="string">"老师"</span>, <span class="string">"工程师"</span>, <span class="string">"程序员"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, age, job <span class="keyword">in</span> zip(names, ages, jobs):</span><br><span class="line">    print(<span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(name, age, job))</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-20-老师</span><br><span class="line">李四-30-工程师</span><br><span class="line">王五-35-程序员</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>当示例中一个元组<code>job</code>遍历结束后整个遍历就结束了，因而没有输出<code>赵六</code>的信息</p>
</blockquote>
<ul>
<li>不使用<code>zip()</code>实现上述功能的代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(names[i], ages[i], jobs[i]))</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>__call__方法</title>
    <url>/2019/09/17/call-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>Python中，如果在创建类的时候写了<code>__call__()</code>方法， 那么该类实例化出实例后， <code>实例名()</code>就是调用<code>__call__()</code>方法。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span></span><br><span class="line">    <span class="string">"""工资计算类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span></span><br><span class="line">        print(<span class="string">"发工资"</span>)</span><br><span class="line">        year_salary = salary*<span class="number">12</span></span><br><span class="line">        day_salary = salary//<span class="number">22.5</span></span><br><span class="line">        hour_salary = day_salary//<span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dict(year_salary=year_salary, month_salary=salary, day_salary=day_salary, hour_salary=hour_salary)</span><br><span class="line"></span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">发工资</span><br><span class="line">&#123;<span class="string">'year_salary'</span>: <span class="number">36000</span>, <span class="string">'month_salary'</span>: <span class="number">3000</span>, <span class="string">'day_salary'</span>: <span class="number">133.0</span>, <span class="string">'hour_salary'</span>: <span class="number">16.0</span>&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp网络编程</title>
    <url>/2019/09/16/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin" target="_blank" rel="noopener">TCP百度百科</a></p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>TCP通信需要经过<strong>创建链接，数据传送，终止连接</strong>三个步骤</li>
<li>通信双方都必须先建立连接才能进行通讯，双方都要为连接分配必要的系统内核资源，以管理连接的状态和传输</li>
<li>TCP的连接是一对一的，因此，<strong>基于广播的应用程序应使用UDP</strong>，</li>
</ul>
<h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><ul>
<li>TCP严格区分服务器和客户端，服务器就是提供服务的一方，客户端就是需要服务的一方，而UDP不区分</li>
</ul>
<h3 id="TCP客户端构建流程"><a href="#TCP客户端构建流程" class="headerlink" title="TCP客户端构建流程"></a>TCP客户端构建流程</h3><ul>
<li>代码流程<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建tcp的套接字</span></span><br><span class="line">    tcp_client_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接服务器</span></span><br><span class="line">    serve_ip = input(<span class="string">"请输入服务器ip："</span>)</span><br><span class="line">    serve_port = input(<span class="string">"请输入服务器port："</span>)</span><br><span class="line">    serve_addr = (serve_ip, int(serve_port))</span><br><span class="line">    tcp_client_socket.connect(serve_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送/接收数据,使用send方法，不需要多次指定套接字</span></span><br><span class="line">    send_data = input(<span class="string">"请输入要发送的数据："</span>)</span><br><span class="line">    tcp_client_socket.send(send_data.encode(<span class="string">"gbk"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_serve_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定本地信息</span></span><br><span class="line">    tcp_serve_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让默认套接字由主动变为被动,listen</span></span><br><span class="line">    <span class="comment"># 使用socket创建的套接字默认的属性是主动的，使用listen可将其变为被动，这样就可以接收别人的连接了</span></span><br><span class="line">    tcp_serve_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环为多个客户端服务</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待客户端的连接accept,未连接到客户端会进入堵塞</span></span><br><span class="line">        <span class="comment"># 如果有新的客户端来连接服务器，那么就产生一个新的套接字专门为这个客户端服务</span></span><br><span class="line">        <span class="comment"># client_socket用来为这个客户端服务</span></span><br><span class="line">        <span class="comment"># tcp_serve_socket就可以省下来专门等待其他新的客户端的连接</span></span><br><span class="line">        print(<span class="string">"等待客户端连接..."</span>)</span><br><span class="line">        client_socket, client_addr = tcp_serve_socket.accept()</span><br><span class="line">        print(<span class="string">"新的客户端已连接：%s"</span> % str(client_addr))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环为同一个客户端服务</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 接收客户端请求,会进入堵塞</span></span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"客户端请求是：%s"</span> % recv_data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close</span></span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">                <span class="comment"># 回送数据</span></span><br><span class="line">                client_socket.send(<span class="string">"hello"</span>.encode(<span class="string">"gbk"</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">"已为客户服务完成"</span>)</span><br><span class="line"></span><br><span class="line">    tcp_serve_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>udp网络编程</title>
    <url>/2019/09/15/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/UDP/33012?fr=aladdin" target="_blank" rel="noopener">UDP百度百科</a></p>
<a id="more"></a>

<h2 id="创建udp套接字"><a href="#创建udp套接字" class="headerlink" title="创建udp套接字"></a>创建udp套接字</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.DGRAM)</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>使用<code>sendto()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">send_data = input(<span class="string">"please input:"</span>)</span><br><span class="line"><span class="comment"># 发送的数据(utf-8编码)  (ip地址, 端口)</span></span><br><span class="line">udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (<span class="string">"X.X.X.X"</span>, port))  <span class="comment"># 如果发送方未绑定端口，系统会随机分配1024-65535</span></span><br></pre></td></tr></table></figure>

<h2 id="获取端口"><a href="#获取端口" class="headerlink" title="获取端口"></a>获取端口</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组，ip地址和端口号</span></span><br><span class="line">local_addr = (<span class="string">""</span>, <span class="number">7788</span>)    <span class="comment"># ip地址一般不用写，表示本机的任意一个ip</span></span><br><span class="line"><span class="comment"># 绑定</span></span><br><span class="line">udp_socket.bind(local_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序实例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""发送数据"""</span></span><br><span class="line">    dest_ip = input(<span class="string">"请输入对方的ip："</span>)</span><br><span class="line">    dest_port = input(<span class="string">"请输入对方的port："</span>)</span><br><span class="line">    send_data = input(<span class="string">"请输入发送的消息："</span>)</span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (dest_ip, int(dest_port)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""接收数据"""</span></span><br><span class="line">    <span class="comment"># 接收数据,1024是本次接收的最大字节数，如果未接收到会进入阻塞状态</span></span><br><span class="line">    recv_data = udp_socket.recvfrom(<span class="number">1024</span>)  <span class="comment"># 会接收到数据和发送方的ip地址和端口</span></span><br><span class="line">    recv_msge = recv_data[<span class="number">0</span>]</span><br><span class="line">    send_addr = recv_data[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印接收到的数据, 需要指定解码，如果是windows发送，应当使用gbk解码</span></span><br><span class="line">    print(<span class="string">"接收到的数据是：%s 来源于：%s"</span> % (recv_msge.decode(<span class="string">"utf-8"</span>), str(send_addr)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 绑定信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"0退出，1发送，2接收"</span>)</span><br><span class="line">        option = input(<span class="string">"请输入指令："</span>)</span><br><span class="line">        <span class="keyword">if</span> option == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> option == <span class="string">"1"</span>:</span><br><span class="line">            <span class="comment"># 发送</span></span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        <span class="keyword">elif</span> option == <span class="string">"2"</span>:</span><br><span class="line">            <span class="comment"># 接收并显示</span></span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入错误，请重新输入"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>socket</code>套接字是<strong>全双工</strong>工作模式，即可以同时收发</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络的一些基本概念</title>
    <url>/2019/09/12/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="ip地址的分类"><a href="#ip地址的分类" class="headerlink" title="ip地址的分类"></a>ip地址的分类</h2><h3 id="ipv4-百度百科"><a href="#ipv4-百度百科" class="headerlink" title="ipv4(百度百科)"></a>ipv4(<a href="https://baike.baidu.com/item/IPv4/422599?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</h3><ul>
<li><code>internet protocol version 4</code>指互联网协议的第四种版本，<code>ipv1</code>，<code>ipv2</code>，<code>ipv3</code>是实验版本</li>
<li>特点： <ul>
<li>由四组数字组成：如<code>127.168.8.32</code>，其中每组最大值是255<h3 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h3></li>
</ul>
</li>
<li><code>internet protocol version 6</code>指第六种版本，<code>ipv5</code>是实验版本</li>
<li>表示方法：(引自<a href="https://baike.baidu.com/item/IPv6/172297?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</li>
</ul>
<ol>
<li><strong>冒分十六进制表示法</strong><blockquote>
<p>格式为<code>X:X:X:X:X:X:X:X</code>，其中每个X表示地址中的16b，以十六进制表示，例如：<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>这种表示法中，每个X的前导0是可以省略的，例如：<code>2001:0DB8:0000:0023:0008:0800:200C:417A</code>→ <code>2001:DB8:0:23:8:800:200C:417A</code></p>
</blockquote>
</li>
<li><strong>0位压缩表示法</strong><blockquote>
<p>在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为<code>::</code>。但为保证地址解析的唯一性，地址中<code>::</code>只能出现一次，例如：<code>FF01:0:0:0:0:0:0:1101</code> → <code>FF01::1101</code>，<code>0:0:0:0:0:0:0:1</code> → <code>::1</code>，<code>0:0:0:0:0:0:0:0</code> → <code>::</code></p>
</blockquote>
</li>
<li><strong>内嵌IPv4地址表示法</strong><blockquote>
<p>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：<code>X:X:X:X:X:X:d.d.d.d</code>，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如<code>::192.168.0.1</code>与<code>::FFFF:192.168.0.1</code>就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用</p>
</blockquote>
</li>
</ol>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li>ip用来标识主机，端口(port)用来指定数据传输的主机程序</li>
</ul>
<h3 id="知名端口-Well-Known-Ports"><a href="#知名端口-Well-Known-Ports" class="headerlink" title="知名端口(Well Known Ports)"></a>知名端口(Well Known Ports)</h3><ul>
<li>知名端口是众所周知的端口号，范围从0到1023，如：<ul>
<li><code>80</code>端口分配给HTTP服务</li>
<li><code>21</code>端口分配给FTP服务<h3 id="动态端口-Dynamic-Ports"><a href="#动态端口-Dynamic-Ports" class="headerlink" title="动态端口(Dynamic Ports)"></a>动态端口(Dynamic Ports)</h3></li>
</ul>
</li>
<li>动态端口范围是1024-65535</li>
<li>之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配<blockquote>
<p>动态分配：程序需要网络通信时，它向主机申请一个端口，主机从可用的端口中为它分配一个，当这个程序关闭时，同时也就释放了它所占用的端口</p>
</blockquote>
</li>
</ul>
<h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><ul>
<li>网络套接字是IP地址与端口的组合。套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信.</li>
</ul>
<h3 id="在python中使用socket"><a href="#在python中使用socket" class="headerlink" title="在python中使用socket"></a>在python中使用socket</h3><ul>
<li>在python中使用socket模块即可<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数说明</p>
<blockquote>
<p>AddressFamily: 可以选择<code>AF_INET</code>(用于Internet进程间通讯)或者<code>AF_UNIX</code>(用于同一台机器进程间通讯)，实际工作中常用<code>AF_INET</code><br>Type: 套接字类型，可以是<code>SOCK_STREAM</code>(流式套接字，主要用于<strong>TCP协议</strong>)，或者<code>SOCK_DGRAM</code>(数据报套接字，主要用于<strong>UDP协议</strong>)</p>
</blockquote>
</blockquote>
<ul>
<li>创建一个tcp套接字<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建tcp的套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用套接字的功能</span></span><br><span class="line"><span class="meta">... </span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可以发现，它的基本流程与文件的操作大致相同</p>
</blockquote>
<ul>
<li>创建一个udp套接字<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""测试udp发送数据"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建udp套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 接收要发送的数据</span></span><br><span class="line">    send_data = input(<span class="string">"请输入发送的数据："</span>)</span><br><span class="line">    <span class="comment"># 发送数据  使用utf-8编码，后接元组(ip地址，端口)</span></span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (<span class="string">"192.168.32.32"</span>, <span class="number">8080</span>))</span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>@property装饰器</title>
    <url>/2019/09/11/property%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>@property</code>装饰器可以让方法像属性一样进行调用</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="不使用-property装饰器"><a href="#不使用-property装饰器" class="headerlink" title="不使用@property装饰器"></a>不使用@property装饰器</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">jack = Person(<span class="number">18</span>)</span><br><span class="line">print(jack.get_age())</span><br><span class="line">jack.set_age(<span class="number">20</span>)</span><br><span class="line">print(jack.get_age())</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.__age</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意这里是age.setter</span></span><br><span class="line"><span class="meta">	@age.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">jack = Person(<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 像属性一样调用方法</span></span><br><span class="line">print(jack.age)</span><br><span class="line"><span class="comment"># 像属性一样调用方法</span></span><br><span class="line">jack.age = <span class="number">20</span></span><br><span class="line">print(jack.age)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>property装饰器</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>eval()函数</title>
    <url>/2019/09/10/eval-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数学计算</span></span><br><span class="line">input:  eval(<span class="string">"1+1"</span>)</span><br><span class="line">output: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串重复</span></span><br><span class="line">input:  eval(<span class="string">"'*' * 10"</span>)</span><br><span class="line">output: **********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转化为列表</span></span><br><span class="line">input:  type(eval(<span class="string">"[1, 2, 3, 4]"</span>))</span><br><span class="line">output: list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为字典</span></span><br><span class="line">input:  type(eval(<span class="string">"&#123;'name': 'xiaoming', 'age': 18&#125;"</span>))</span><br><span class="line">output: dict</span><br></pre></td></tr></table></figure>

<h3 id="演示案例：计算器"><a href="#演示案例：计算器" class="headerlink" title="演示案例：计算器"></a>演示案例：计算器</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(eval(input(<span class="string">"请输入计算式: "</span>)))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入计算式: <span class="number">5</span>+<span class="number">2</span>*<span class="number">5</span>**<span class="number">2</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="不要滥用eval"><a href="#不要滥用eval" class="headerlink" title="不要滥用eval"></a>不要滥用eval</h3><ul>
<li><p>使用eval()直接转换输入结果可能导致安全漏洞，如上例中用户输入<code>__import__(&#39;os&#39;).system(&#39;ls&#39;)</code></p>
</li>
<li><p>等价于</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">"ls"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入计算式: __import__(<span class="string">'os'</span>).system(<span class="string">'ls'</span>)</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出了当前目录下文件列表，同理也可执行其他增删改的终端命令，很不安全</p>
</blockquote>
<ul>
<li>执行成功，返回0</li>
<li>执行失败，返回错误信息</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>eval</tag>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python的文件操作</title>
    <url>/2019/09/09/python%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><h3 id="操作文件的函数-方法"><a href="#操作文件的函数-方法" class="headerlink" title="操作文件的函数/方法"></a>操作文件的函数/方法</h3><table>
<thead>
<tr>
<th>函数/方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>打开文件，并返回操作对象</td>
</tr>
<tr>
<td>read</td>
<td>将文件读取到内存</td>
</tr>
<tr>
<td>write</td>
<td>将指定内容写入文件</td>
</tr>
<tr>
<td>writeLines</td>
<td>将指定内容写入文件，不填加换行符</td>
</tr>
<tr>
<td>fiush</td>
<td>把缓冲区的内容写入文件，但不关闭文件</td>
</tr>
<tr>
<td>close</td>
<td>把缓冲区的内容写入文件，并关闭文件</td>
</tr>
</tbody></table>
<blockquote>
<p><code>read</code> <code>write</code> <code>close</code>三者都要通过<strong>文件对象</strong>来进行调用</p>
</blockquote>
<h3 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h3><ul>
<li><code>open()</code>第一个参数是要打开的文件名(区分大小写)</li>
<li>打开后操作完成要使用<code>close()</code>关闭，否则会消耗系统资源，影响后续对文件的访问</li>
<li>通常先编写打开和关闭文件代码，在编写中间的读写操作</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开</span></span><br><span class="line">file = open(<span class="string">"文件名"</span>)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">text = file.read()</span><br><span class="line">print(text)</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>关于文件指针<ul>
<li>python中读取完内容后会将指针移动到读取内容的末尾，默认是文件末尾</li>
<li><strong>连续两次读取文件，由于第一次读完指针已经在末尾，因而第二次读不到内容</strong></li>
</ul>
</li>
</ul>
<h3 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h3><ul>
<li><code>open()</code>默认以只读打开</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"文件名"</span>, <span class="string">"访问方式"</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>访问方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读，指针在文件开头，不存在会抛出异常</td>
</tr>
<tr>
<td>w</td>
<td>只写，若文件存在则覆盖，不存在则创建</td>
</tr>
<tr>
<td>a</td>
<td>追加，文件存在，指针就放在文件末尾，不存在，抛出异常</td>
</tr>
<tr>
<td>r+</td>
<td>读写，文件指针在开头，若不存在，抛出异常</td>
</tr>
<tr>
<td>w+</td>
<td>读写，文件存在则覆盖，不存在就创建</td>
</tr>
<tr>
<td>a+</td>
<td>读写，文件存在则指针放在末尾，文件不存在，创建新文件</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式，可与其他模式组合</td>
</tr>
</tbody></table>
<ul>
<li>使用<strong>读写方式</strong>打开，会影响文件读写效率，开发中更多的是<strong>以只读，只写的方式</strong>打开</li>
<li>对于二进制文件需要加<code>b</code>，如打开模式为<code>wb</code>，<code>rb</code></li>
</ul>
<h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><ul>
<li><code>read()</code>方法默认读取全部，读取大文件对于系统内存占用会非常严重</li>
</ul>
<h4 id="readLine方法"><a href="#readLine方法" class="headerlink" title="readLine方法"></a>readLine方法</h4><ul>
<li>一次读取一行，方法执行后，指针向下移动一行</li>
<li>读取大文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行</span></span><br><span class="line">    text = file.readLine()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#判断是否读取到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#每读到一行末尾已经有"\n"</span></span><br><span class="line">    print(text, end=<span class="string">""</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file_r = open(<span class="string">"test"</span>)</span><br><span class="line">file_w = open(<span class="string">"test_copy"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    text = file_r.readLine()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    file_w.write(text)</span><br><span class="line"></span><br><span class="line">file_r.close()</span><br><span class="line">file_w.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后打开<code>file_w</code>文件，发现已经复制了<code>file_r</code>的内容</li>
</ul>
<h2 id="文件-目录的常用管理操作"><a href="#文件-目录的常用管理操作" class="headerlink" title="文件/目录的常用管理操作"></a>文件/目录的常用管理操作</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>rename</td>
<td>重命名文件</td>
<td>os.rename(“源文件名”, “目标文件名”)</td>
</tr>
<tr>
<td>remove</td>
<td>删除文件</td>
<td>os.remove(“文件名”)</td>
</tr>
</tbody></table>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入os模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>listdir</td>
<td>目录列表</td>
<td>os.listdir(“目录名”)</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
<td>os.mkdir(“目录名”)</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除目录</td>
<td>os.rmdir(“目录名”)</td>
</tr>
<tr>
<td>getcwd</td>
<td>获取当前目录</td>
<td>os.getcwd()</td>
</tr>
<tr>
<td>chdir</td>
<td>修改工作目录</td>
<td>os.chdir(“目标目录”)</td>
</tr>
<tr>
<td>path.isdir</td>
<td>判断是否为目录</td>
<td>os.path.isdir(“文件路径”)</td>
</tr>
</tbody></table>
<h3 id="python编码"><a href="#python编码" class="headerlink" title="python编码"></a>python编码</h3><blockquote>
<ul>
<li>python2默认使用ascii编码，不支持中文</li>
<li>python3默认使用utf-8编码，支持中文</li>
</ul>
</blockquote>
<ul>
<li>改变python2的编码格式，使支持中文，将下句代码写在文件开头<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf-8 *-*</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或者</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>另外，使用python2输出中文时，会出现乱码，这是因为解释器会一个字节一个字节的输出，而中文一般是三个字节</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># *-* coding: utf-8 *-*</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">"hello, 你好"</span></span><br><span class="line">print(my_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> my_str:</span><br><span class="line">    print(letter)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hello, 你好</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">,</span><br><span class="line"></span><br><span class="line">�</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">�</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出乱码</p>
</blockquote>
<ul>
<li><p>解决方法：定义字符串时，前面加上字母<code>u</code>，说明这是utf-8格式的字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">u"hello, 你好"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次运行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello, 你好</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">,</span><br><span class="line"></span><br><span class="line">你</span><br><span class="line">好</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>不再乱码</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python的模块和包</title>
    <url>/2019/09/06/python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>每一个以<code>py</code>结尾的python源代码文件都是一个模块</p>
<a id="more"></a>

<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><h3 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a>import导入</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li><p>不推荐格式：将几个模块放在一行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推荐:每个模块单独占一行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入之后可以通过<code>模块名.</code>的方式使用模块提供的工具：<strong>全局变量，类，函数</strong></p>
</li>
</ul>
<h4 id="使用as指定模块别名"><a href="#使用as指定模块别名" class="headerlink" title="使用as指定模块别名"></a>使用as指定模块别名</h4><ul>
<li>如果模块名字太长就可以使用<code>as</code>来指定别名，方便实用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>模块别名应该符合<strong>大驼峰命名法</strong></p>
</blockquote>
<h3 id="from…import导入"><a href="#from…import导入" class="headerlink" title="from…import导入"></a>from…import导入</h3><ul>
<li>如果希望从某一个模块中，导入<strong>部分工具</strong>，就可以使用这种方式</li>
<li>语法格式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>导入之后不需要通过<code>模块名.</code>就可以直接使用模块的工具<br>如果两个模块存在<strong>同名的函数</strong>，那么后导入模块的函数，会<strong>覆盖掉先导入的函数</strong></p>
</blockquote>
<ul>
<li>可以通过<code>as</code>别名的方式调用前面导入的函数<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pkg1 <span class="keyword">import</span> test <span class="keyword">as</span> pkg1_test  <span class="comment">#给test()函数起别名</span></span><br><span class="line"><span class="keyword">from</span> pkg2 <span class="keyword">import</span> test   <span class="comment"># pkg1和pkg2中同时含有test()方法</span></span><br><span class="line"></span><br><span class="line">pkg1_test()     <span class="comment">#调用pkg1的test()</span></span><br><span class="line">test()      <span class="comment">#调用pkg2的test()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="导入全部"><a href="#导入全部" class="headerlink" title="导入全部"></a>导入全部</h4><ul>
<li>语法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 模块 导入 所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>不推荐使用，因为函数重名不好排查</p>
</blockquote>
<h2 id="python导入模块的顺序"><a href="#python导入模块的顺序" class="headerlink" title="python导入模块的顺序"></a>python导入模块的顺序</h2><ol>
<li>搜索<strong>当前目录</strong>指定模块名的文件，如果有就直接导入</li>
<li>如果没有，再搜索系统目录<blockquote>
<p>在开发时创建文件，命名不要和系统模块文件重名，否则调用系统方法时会因为当前目录下存在该模块而不去搜索系统目录，使程序无法正确执行</p>
</blockquote>
</li>
</ol>
<ul>
<li>使用内置方法<code>__file__</code>可查看文件完整路径<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(模块名.__file__)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="关于模块导入"><a href="#关于模块导入" class="headerlink" title="关于模块导入"></a>关于模块导入</h2><ul>
<li>在导入模块时，文件中没有缩进的代码<strong>都会被执行一遍</strong><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是test1模块中的内容</span></span><br><span class="line">print(<span class="string">"这是模块一"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是test2模块中的内容</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(<span class="string">"这是模块二"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在模块test2中<code>run</code>，执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">这是模块一</span><br><span class="line">这是模块二</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而有时开发中开发者要做一些测试，写的一些代码只希望在本文件内执行而不想在被导入时执行</p>
<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a><code>__name__</code>属性</h3><blockquote>
<p><code>__name__</code>属性可以做到，测试模块的代码只在测试时执行，在被导入时不执行</p>
</blockquote>
<ul>
<li><code>__name__</code>属性是python的一个内置属性，记录着一个字符串</li>
<li>如果是被其他文件导入的，则记录的是<strong>模块名</strong></li>
<li>如果是当前执行的程序，<code>__name__</code>是<code>__main__</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test1中</span></span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test2中</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在test2中<code>run</code>，运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1</span><br><span class="line">__main__</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以在测试时可以通过<code>__name__</code>来实现代码仅在测试时执行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test1中</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"这是模块一"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test2中</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(<span class="string">"这是模块二"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在模块test2中<code>run</code>，运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">这是模块二</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写代码格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件末尾，编写本地测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul>
<li><strong>包</strong>是一个包含多个模块的<strong>特殊目录</strong></li>
<li>目录下有一个特殊的文件<strong><code>__init__.py</code></strong></li>
<li>包的命名和变量一致，使用<code>小写字母</code>和<code>_</code>，如<code>this_is_a_pkg</code></li>
<li>可以使用<code>import 包名</code>的方式，一次性导入包中所有的模块</li>
<li>在pycharm中鼠标停在工程名上点击鼠标右键<ul>
<li>选择new –&gt; Python Package可以建立包并自动创建<code>__init__.py</code>空文件</li>
<li>或选择new –&gt; Directory创建文件目录，再自行创建<code>__init__.py</code>文件</li>
</ul>
</li>
<li><code>__init__.py</code>文件<ul>
<li>包中可以对外界使用的模块，需要在<code>__init__.py</code>中写出列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 当前目录 导入 模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名称<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名称<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="发布模块包的步骤"><a href="#发布模块包的步骤" class="headerlink" title="发布模块包的步骤"></a>发布模块包的步骤</h1><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><ul>
<li>创建<code>setup.py</code>文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">"pkg_name"</span>,  <span class="comment"># 包名</span></span><br><span class="line">      version=<span class="string">"1.0"</span>,  <span class="comment"># 版本</span></span><br><span class="line">      description=<span class="string">"some text"</span>,  <span class="comment"># 描述信息</span></span><br><span class="line">      long_description=<span class="string">"完整的发送和接收消息模块"</span>,  <span class="comment"># 完整描述信息</span></span><br><span class="line">      author=<span class="string">"itheima"</span>,  <span class="comment"># 作者</span></span><br><span class="line">      author_email=<span class="string">"abc.com"</span>,  <span class="comment"># 作者邮箱</span></span><br><span class="line">      url=<span class="string">"www.abc.com"</span>,  <span class="comment"># 主页</span></span><br><span class="line">      py_modules=[<span class="string">"包名.模块名1"</span>,  <span class="comment">#要分享的模块</span></span><br><span class="line">                  <span class="string">"包名.模块名2"</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关字典参数的详细信息，可以参阅<a href="https://docs.python.org/2/distutils/apiref.html" target="_blank" rel="noopener">官方网站</a> </p>
<ul>
<li><p>构建模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py build</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成发布压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py sdist</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！</p>
</blockquote>
<h2 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h2><ul>
<li><p>安装模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf 压缩包名.tar.gz </span><br><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载模块<br>直接从安装目录下，把安装模块的目录删除就可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.7/dist-packages/</span><br><span class="line">sudo rm -r 包名*</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用pip安装第三方模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将第三方模块安装到python2.x环境</span></span><br><span class="line">sudo pip install 模块</span><br><span class="line">sudo pip uninstall 模块</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第三方模块安装到python3.x环境</span></span><br><span class="line">sudo pip3 install 模块</span><br><span class="line">sudo pip3 uninstall 模块</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的异常</title>
    <url>/2019/09/06/python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>程序开发时很难将所有特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件集中处理，从而保证程序的稳定性和健壮性</p>
<a id="more"></a>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="简单捕获"><a href="#简单捕获" class="headerlink" title="简单捕获"></a>简单捕获</h3><ul>
<li>格式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    尝试执行的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现错误的处理</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行后会继续执行下方的代码</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	print(<span class="string">"请输入正确的整数"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"继续执行了下方代码"</span>)</span><br></pre></td></tr></table></figure>

<p>执行程序：用户输入了aaa，无法转化为整数</p>
<blockquote>
<p>请输入一个整数:  aaa</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入正确的整数</span><br><span class="line">继续执行了下方代码</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="错误类型捕获"><a href="#错误类型捕获" class="headerlink" title="错误类型捕获"></a>错误类型捕获</h3><ul>
<li><p>针对不同类型的异常，作出不同的相应</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment">#针对类型1处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment">#针对类型2和3处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 捕获未知错误，可以改变result的名字</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取错误类型：出错时，控制台提示的最后一行就是错误类型，找到错误类型就可针对不同的错误进行不同的操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">result = <span class="number">10</span>/num</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行程序，用户输入0</p>
<blockquote>
<p>请输入一个整数:  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/duguosheng/PycharmProjects/190902/d2_excpt.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    result = <span class="number">10</span>/num</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>则<strong>ZeroDivisionError</strong>就是输入零时的错误类型，同理可得，输入字母时的错误类型是<strong>ValueError</strong></p>
</blockquote>
<ul>
<li><p>针对不同错误类型的处理</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">	result = <span class="number">10</span> / num</span><br><span class="line">	print(result)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">	print(<span class="string">"请不要输入0作为除数"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	print(<span class="string">"请输入数字"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获未知异常:假设未能预计到输入零的情况</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">	result = <span class="number">10</span> / num</span><br><span class="line">	print(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	print(<span class="string">"请输入数字"</span>)</span><br><span class="line"><span class="comment"># 捕获未知异常</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>用户输入0</p>
<blockquote>
<p>请输入一个整数:  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">未知错误 division by zero</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="headerlink" title="异常捕获完整语法"></a>异常捕获完整语法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#没有异常才会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment">#无论是否有异常，都会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h2><ul>
<li>当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方</li>
<li>如果<strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会终止<blockquote>
<p>开发中可以在主函数中增加异常捕获，这样就可以大大减少异常捕获代码，使代码整洁</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/int(input(<span class="string">"请输入一个整数：  "</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> test1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#只在主函数中增加异常捕获</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	print(test2())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输入0</p>
<blockquote>
<p>请输入一个整数：  0</p>
</blockquote>
<ul>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">未知错误 division by zero</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功捕获异常并处理</p>
</li>
</ul>
<h2 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h2><blockquote>
<p>当前函数只负责某项功能，主动抛出异常后，让其他函数再处理</p>
</blockquote>
<ul>
<li><p>主动抛出异常的方法</p>
<ul>
<li>创建一个<code>Exception</code>对象</li>
<li>使用<code>raise</code>关键字抛出异常对象</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数：  "</span>))</span><br><span class="line">	<span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>/num</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#主动抛出异常</span></span><br><span class="line">	exception = Exception(<span class="string">"请不要输入0"</span>)</span><br><span class="line">	<span class="keyword">raise</span> exception</span><br><span class="line"></span><br><span class="line"><span class="comment">#只在主函数中增加异常捕获</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	print(test())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输入0</p>
<blockquote>
<p>请输入一个整数：  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请不要输入<span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/09/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式是为了可重用代码，让代码易于理解，保证可靠性</p>
<a id="more"></a>

<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul>
<li>让类创建的对象，在系统中只有<strong>惟一的一个实例</strong></li>
<li>每一次执行<code>类名()</code>返回的对象，<strong>内存地址是相同的</strong></li>
</ul>
<h2 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__方法"></a><code>__new__</code>方法</h2><ul>
<li><p>创建对象时，首先会使用<code>__new__</code>方法为对象分配内存空间</p>
</li>
<li><p><code>__new__</code>方法：</p>
<ol>
<li>在内存中为对象分配空间</li>
<li>返回对象的引用</li>
</ol>
</li>
<li><p>python解释器获得对象的引用之后，将引用作为<strong>第一个参数</strong>，传递给<code>__init__</code>方法</p>
</li>
<li><p><strong><em>重写<code>__new__</code>方法的代码非常固定</em></strong></p>
</li>
<li><p><code>__new__</code>是一个静态方法，调用时需要主动传递<code>cls</code>参数</p>
</li>
<li><p>重写<code>__new__</code><strong>一定要`return super().<strong>new</strong>(cls)</strong></p>
<ul>
<li>否则解释器得不到分配了空间的对象引用，就<strong>不会调用<code>__init__</code></strong>方法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"分配空间"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"创建对象"</span>)</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">print(a1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">分配空间</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见自动执行了<code>__new__</code>而没有执行<code>__init__</code>，且<code>a1</code>没有内存空间</p>
</blockquote>
<h2 id="python中的单例"><a href="#python中的单例" class="headerlink" title="python中的单例"></a>python中的单例</h2><ol>
<li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录单例对象的引用</li>
<li>重写<code>__new__</code>方法</li>
<li>如果属性<code>is None</code>，调用父类的方法分配空间，并在类属性中记录结果</li>
<li>返回类属性中记录的对象引用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="comment"># 创建类属性记录对象引用</span></span><br><span class="line">	instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 重写__new__</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="comment">#判断是否为空对象</span></span><br><span class="line">		<span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># is None则分配空间</span></span><br><span class="line">			cls.instance = super().__new__(cls)</span><br><span class="line">		<span class="comment">#返回对象引用</span></span><br><span class="line">		<span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line">print(a1)</span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;__main__.A object at <span class="number">0x7f701d71e690</span>&gt;</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f701d71e690</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见a1与a2地址是相同的，是同一个对象</p>
</blockquote>
<h2 id="只执行一次初始化"><a href="#只执行一次初始化" class="headerlink" title="只执行一次初始化"></a>只执行一次初始化</h2><ul>
<li><p>上例中每创建一个对象就会调用一次<code>__init__</code></p>
</li>
<li><p>设立类属性标志位，在<code>__init__</code>中判断</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="comment"># 创建类属性记录对象引用</span></span><br><span class="line">	instance = <span class="literal">None</span></span><br><span class="line">	init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 重写__new__,静态方法需要传入cls以访问类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="comment">#判断是否为空对象</span></span><br><span class="line">		<span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># is None则分配空间</span></span><br><span class="line">			cls.instance = super().__new__(cls)</span><br><span class="line">		<span class="comment">#返回类属性</span></span><br><span class="line">		<span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="comment"># 使用类名.的方式访问类属性</span></span><br><span class="line">		<span class="keyword">if</span> A.init_flag:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		A.init_flag = <span class="literal">True</span></span><br><span class="line">		print(<span class="string">"初始化"</span>)</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line">print(a1)</span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f1aa35baa50</span>&gt;</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f1aa35baa50</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>只被初始化了一次</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>类属性，类方法，静态方法</title>
    <url>/2019/09/05/%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h1><a id="more"></a>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol>
<li>创建出来的对象叫<strong>实例</strong></li>
<li>创建对象的动作叫<strong>实例化</strong></li>
<li>对象的属性叫做<strong>实例属性</strong></li>
<li>对象调用的方法叫<strong>实例方法</strong></li>
</ol>
<ul>
<li>每一个对象都有自己独立的内存空间，保存各自不同的属性</li>
<li>多个对象的方法，在内存中只有一份，调用方法时，需要把<strong>对象的引用</strong>传递到方法内部</li>
</ul>
<h4 id="类是特殊的对象"><a href="#类是特殊的对象" class="headerlink" title="类是特殊的对象"></a>类是特殊的对象</h4><ul>
<li>python中一切皆对象<ul>
<li><code>class A</code>定义的类属于<strong>类对象</strong></li>
<li><code>aa = A()</code>属于实例对象</li>
</ul>
</li>
<li>在程序运行时，类也会被<strong>加载到内存</strong><ul>
<li>类对象在内存中<strong>只有一份</strong>，使用一个类可以创建出很多对象实例</li>
<li>除了实例的属性和方法外，类对象还可以拥有自己的属性和方法<ul>
<li>类属性</li>
<li>类方法</li>
<li>通过<code>类名.</code>的方式可以访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>类属性旧式给<strong>类对象</strong>定义的属性，通常用它来记录与这个类相关的特征</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">print(A.count)</span><br><span class="line">a2 = A()</span><br><span class="line">print(A.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性获取机制"><a href="#属性获取机制" class="headerlink" title="属性获取机制"></a>属性获取机制</h3><ul>
<li>访问属性有两种方式<ul>
<li>类名.类属性</li>
<li>对象.类属性（不推荐）</li>
</ul>
</li>
<li>在python中使用<code>对象.属性</code>时<ul>
<li>先从对象内部查找对象属性，如果没有就会向上寻找类属性<blockquote>
<p>上例中也可写作</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"a1.count"</span>)</span><br><span class="line">print(<span class="string">"a2.count"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="不要使用对象访问类属性"><a href="#不要使用对象访问类属性" class="headerlink" title="不要使用对象访问类属性"></a>不要使用对象访问类属性</h4><ul>
<li><p>使用<code>对象.类属性</code>的方式给类属性赋值时，会给<strong>添加一个属性</strong>，<strong>不会影响到类属性</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a1.count = <span class="number">5</span></span><br><span class="line">print(A.count)</span><br><span class="line">print(a1.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul>
<li><p>定义类方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>cls.</code>访问类的属性和方法</p>
</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote>
<p>在开发时<strong>既不需要访问实例属性和实例方法，也不需要访问类方法和类属性</strong>，就可定义为静态方法</p>
</blockquote>
<ul>
<li><p>语法如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法名后面直接跟<code>()</code>，不需要加<code>self</code>或<code>cls</code></p>
</li>
<li><p>通过<code>类名.静态方法</code>调用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">"hello"</span>)</span><br><span class="line">A.test()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_多态</title>
    <url>/2019/09/05/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<ul>
<li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码灵活度</li>
</ul>
<a id="more"></a>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"跑跑跳跳"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xtq</span><span class="params">(Dog)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span>     <span class="comment">#重写父类方法</span></span><br><span class="line">		print(<span class="string">"飞到天上"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play_with_dog</span><span class="params">(self, dog)</span>:</span></span><br><span class="line">		print(<span class="string">"快乐玩耍"</span>)</span><br><span class="line">		dog.play()</span><br><span class="line"></span><br><span class="line">wangcai = Dog() <span class="comment">#普通狗旺财</span></span><br><span class="line">xiaotian = Xtq() <span class="comment">#哮天犬</span></span><br><span class="line">xiaoming = Person()</span><br><span class="line">xiaoming.play_with_dog(wangcai)	</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">30</span>)</span><br><span class="line">xiaoming.play_with_dog(xiaotian)	<span class="comment">#使用方法不变，传入另一个对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">快乐玩耍</span><br><span class="line">跑跑跳跳</span><br><span class="line">******************************</span><br><span class="line">快乐玩耍</span><br><span class="line">飞到天上</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_继承</title>
    <url>/2019/09/05/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<ul>
<li>继承：实现<strong>代码的重用</strong>，相同的代码不需要重复编写</li>
</ul>
<a id="more"></a>

<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类<span class="params">(父类)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>继承的传递性：A继承自B，B继承自C，则A也拥有C的属性和方法</li>
<li>子类不能访问父类的私有属性或方法，但可以在父类方法中访问自身私有内容，子类调用该方法来间接访问</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul>
<li><p>语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类<span class="params">(父类<span class="number">1</span>, 父类<span class="number">2</span>)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：如果多继承中，不同的父类方法重名，则会优先使用继承顺序靠前的父类方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"A--test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"A--demo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"B--test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"B--demo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, A)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"继承顺序是先A后B"</span>)</span><br><span class="line">cc = C()</span><br><span class="line">cc.test()</span><br><span class="line">cc.demo()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"继承顺序是先B后A"</span>)</span><br><span class="line">dd = D()</span><br><span class="line">dd.test()</span><br><span class="line">dd.demo()</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">继承顺序是先A后B</span><br><span class="line">A--test</span><br><span class="line">A--demo</span><br><span class="line">继承顺序是先B后A</span><br><span class="line">B--test</span><br><span class="line">B--demo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>尽管不会报错，但不利于程序的阅读和理解，所以尽量不要使用多继承，使用时，也尽量保证属性方法不重名</p>
</blockquote>
<h3 id="mro"><a href="#mro" class="headerlink" title="__mro__"></a><code>__mro__</code></h3><ul>
<li><p>用于查看方法搜索顺序<code>类名.__mro__</code> </p>
</li>
<li><p>如在上例中使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(C.__mro__)</span><br><span class="line">print(D.__mro__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重写方法override"><a href="#重写方法override" class="headerlink" title="重写方法override"></a>重写方法override</h2><ul>
<li><p>在子类中直接编写与父类中同名的方法即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"叫"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"吃"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"喵喵喵"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()</span><br><span class="line">tom.voice()</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">吃</span><br><span class="line">喵喵喵</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对父类方法进行扩展"><a href="#对父类方法进行扩展" class="headerlink" title="对父类方法进行扩展"></a>对父类方法进行扩展</h2><ul>
<li><p>调用父类方法</p>
<ol>
<li><code>super().方法名</code></li>
<li><code>父类名.方法(self)</code>  不推荐使用，因为当父类名改变时，语句也要改变<blockquote>
<p>将上例中<code>Cat</code> 类中voice方法改成</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		super().voice() <span class="comment">#第一种方法调用父类方法</span></span><br><span class="line">        Animal.voice(self)  <span class="comment">#第二种方法</span></span><br><span class="line">		print(<span class="string">"喵喵喵"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">吃</span><br><span class="line">叫</span><br><span class="line">叫</span><br><span class="line">喵喵喵</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h2><ul>
<li>新式类：以<code>object</code> 为基类的类，推荐使用</li>
<li>旧式类：不以<code>object</code> 为基类的类，不推荐使用</li>
<li>python3中默认使用object类作为基类，即python3中定义的类全部是<strong>新式类</strong> </li>
<li>python2中如果没有指定父类，不会使用object类作为基类<blockquote>
<p>新旧类会影响方法搜索顺序<br>保证python2与python3的统一，可以写作</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><ul>
<li>旧式类：父类名称.<strong>init</strong>(self,参数1，参数2，…)</li>
<li>新式类：super(子类，self).<strong>init</strong>(参数1，参数2，….)</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类初始化方法</span></span><br><span class="line">		super(B, self).__init__(name)</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bb = B(<span class="string">"das"</span>, <span class="number">17</span>)</span><br><span class="line">print(bb.name)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_封装</title>
    <url>/2019/09/04/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<ul>
<li>封装：根据职责，将<strong>方法</strong> 和<strong>属性</strong> 封装到一个类中</li>
</ul>
<a id="more"></a>

<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><ul>
<li><p>使用dir()可以查看一个对象所有的可用方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""this is a example"""</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    </span><br><span class="line">print(dir(test))    <span class="comment">#查看可用方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">'__bool__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这些方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(test.__doc__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> a example</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>返回了函数注释信息</p>
</blockquote>
<h2 id="定义简单类-只包含方法"><a href="#定义简单类-只包含方法" class="headerlink" title="定义简单类-只包含方法"></a>定义简单类-只包含方法</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span></span></span><br><span class="line"><span class="function">        <span class="title">pass</span></span></span><br><span class="line"><span class="function">    <span class="title">def</span> 方法2<span class="params">(self, 参数列表)</span></span></span><br><span class="line"><span class="function">        <span class="title">pass</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>类名使用<strong>大驼峰命名法</strong> 命名，首字母大写</li>
<li>类中的方法第一个参数必须是<code>self</code>，没有参数也要写<code>self</code> </li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">对象变量 = 类名()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先给创建出的对象开辟内存空间，再使<code>对象变量</code> 指向该地址</p>
</blockquote>
<blockquote>
<p>多次创建会开辟不同的内存空间</p>
</blockquote>
<ul>
<li><p>使用print()可以查看：对象的类和内存地址</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"i love fish"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Cat object at <span class="number">0x7f9c62f67290</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="给对象增加属性"><a href="#给对象增加属性" class="headerlink" title="给对象增加属性"></a>给对象增加属性</h2><ul>
<li>可以直接使用赋值语句，继续使用上个例子中创建的<code>tom</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tom.name = <span class="string">"汤姆"</span>   <span class="comment">#这样tom就获得了一个name的属性</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>这种方式不推荐使用，应当把属性封装在类中</p>
</blockquote>
<h3 id="关于self"><a href="#关于self" class="headerlink" title="关于self"></a>关于<code>self</code></h3><ul>
<li><p>哪一个对象调用的方法，<code>self</code>就是哪一个对象的引用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s 爱吃鱼"</span> % self.name)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">jf = Cat()</span><br><span class="line">tom.name = <span class="string">"汤姆"</span></span><br><span class="line">jf.name = <span class="string">"加菲"</span></span><br><span class="line">tom.eat()</span><br><span class="line">jf.eat()</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">汤姆 爱吃鱼</span><br><span class="line">加菲 爱吃鱼</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见<code>self.name</code> 返回的是各自的属性</p>
</blockquote>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul>
<li><p>当使用类名创建对象时，自动执行</p>
<ol>
<li>创建对象：在内存中分配空间</li>
<li>初始化：执行<code>__init__</code>方法，<code>__init__</code>是专门用来定义一个类具有那些属性的方法</li>
</ol>
</li>
<li><p>自动执行<code>__init__</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"自动执行了__init__方法"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">自动执行了__init__方法</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="在初始化内部定义属性"><a href="#在初始化内部定义属性" class="headerlink" title="在初始化内部定义属性"></a>在初始化内部定义属性</h3><ul>
<li><p>在<code>__init__</code> 内部使用<code>self.属性名 = 属性初始值</code> 就可以定义属性</p>
</li>
<li><p>定义属性后，使用类名创建的对象都将拥有该属性</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样创建的对象<code>name</code> 属性是相同的，若想创建的同时给对象指定不同的属性，可以给<code>__init</code> <strong>加入参数</strong> </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="内置方法和属性"><a href="#内置方法和属性" class="headerlink" title="内置方法和属性"></a>内置方法和属性</h2><h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><ul>
<li>初始化时自动调用</li>
</ul>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><ul>
<li><p>当对象被从内存中销毁前，会自动调用<code>__del__</code> 方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		print(<span class="string">"%s被创建了"</span> % name)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"对象被销毁了"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line">print(<span class="string">"*"</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TOM被创建了</span><br><span class="line">******************************</span><br><span class="line">对象被销毁了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用del-关键字可以删除对象"><a href="#使用del-关键字可以删除对象" class="headerlink" title="使用del 关键字可以删除对象"></a>使用<code>del</code> 关键字可以删除对象</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line"><span class="keyword">del</span> tom</span><br><span class="line">print(<span class="string">"*"</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TOM被创建了</span><br><span class="line">对象被销毁了</span><br><span class="line">******************************</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可以使用<code>del</code> 关键字可以调用<code>__del__</code> 方法</p>
</blockquote>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><ul>
<li><p>python中使用<code>print()</code> 输出对象，默认返回类和地址</p>
</li>
<li><p>可以使用<code>__str__</code> 自定义返回内容</p>
</li>
<li><p><code>__str</code> 必须返回一个字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"i am %s"</span> % self.name</span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i am TOM</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="一个对象的属性可以是另一个类创建的对象"><a href="#一个对象的属性可以是另一个类创建的对象" class="headerlink" title="一个对象的属性可以是另一个类创建的对象"></a>一个对象的属性可以是另一个类创建的对象</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, mouse)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.mouse = mouse</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">catch</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s抓住了%s"</span> % (self.name, self.mouse.name))</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">jerry = Mouse(<span class="string">"Jerry"</span>)</span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>, jerry)</span><br><span class="line">tom.catch()</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tom抓住了Jerry</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="None-关键字"><a href="#None-关键字" class="headerlink" title="None 关键字"></a><code>None</code> 关键字</h2><ul>
<li>当不知道给参数什么初值时，可以使用<code>None</code>，他表示一个没有方法和属性的空对象，是一个特殊的常量</li>
<li>可以给任意一个变量赋<code>None</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line">self.name = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="身份运算符is-与is-not"><a href="#身份运算符is-与is-not" class="headerlink" title="身份运算符is 与is not"></a>身份运算符<code>is</code> 与<code>is not</code></h2><ul>
<li><p>身份运算符用于比较两个对象的<strong>内存地址</strong>是否一致–是否是对于同一个对象的引用</p>
</li>
<li><p>在python中使用<code>None</code> 比较时，建议使用<code>is</code> 和<code>is not</code> </p>
</li>
<li><p><code>is</code> 与<code>==</code> 的区别</p>
<ul>
<li><code>is</code> 判断是否为同一个对象</li>
<li><code>==</code> 判断值是否相等<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(a == b)</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h2><ul>
<li><p>定义方法：在定义属性或方法时，在名字前增加<strong>两个下划线</strong><code>__</code> </p>
</li>
<li><p>私有属性：在对象的方法内部可以访问，在外界不能直接访问</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, mouse)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__mouse = mouse</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.__mouse:	<span class="comment"># 在对象内部方法可以访问私有属性</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"yes"</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>, <span class="literal">True</span>)</span><br><span class="line">print(tom.name)</span><br><span class="line"><span class="comment"># print(tom.__mouse) 访问不到私有属性__mouse</span></span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tom</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="伪私有属性和方法"><a href="#伪私有属性和方法" class="headerlink" title="伪私有属性和方法"></a>伪私有属性和方法</h3><ul>
<li><p>在python中，实际上没有完全的私有，对于私有属性和方法，在外部可以通过在属性或方法名前加<code>_类名</code>(下划线加类名)的方法访问，但尽量不要使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = <span class="number">18</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s 年龄是%d"</span> % (self.name, self.__age))</span><br><span class="line"></span><br><span class="line">mary = Women(<span class="string">"玛丽"</span>)</span><br><span class="line">print(mary._Women__age)</span><br><span class="line">mary._Women__secret()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line">玛丽 年龄是<span class="number">18</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/2019/09/03/python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><a id="more"></a>

<ul>
<li><p>利用元组返回多个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    str = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">return</span> (num, str)</span><br><span class="line">    </span><br><span class="line">temp = test()         <span class="comment">#则temp是一个元组类型，对于不同的内容要使用对应索引调用，容易出错</span></span><br><span class="line">temp1, temp2 = test() <span class="comment">#或使用多个变量接收返回值，方便管理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同理，可利用元组交换数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = (b, a)</span><br><span class="line">a, b = b, a     <span class="comment"># =右边是省略括号的元组</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><h5 id="在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用"><a href="#在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用" class="headerlink" title="在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用"></a>在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num, my_list)</span>:</span></span><br><span class="line">    print(<span class="string">"函数内部："</span>)</span><br><span class="line">    <span class="comment">#赋值</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    my_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(num)</span><br><span class="line">    print(my_list)</span><br><span class="line">    </span><br><span class="line">g_num = <span class="number">5</span></span><br><span class="line">g_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test(g_num, g_list)</span><br><span class="line">print(<span class="string">"执行完成后"</span>)</span><br><span class="line">print(g_num)</span><br><span class="line">print(g_list)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">函数内部：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">执行完成后</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>实参未改变，其原因是变量与数据是分开存储的，<code>g_num</code> 指向数据<code>5</code> 的地址，当将<code>g_num</code>传入test函数是，实则是传入了数据<code>5</code> 的地址，而当使用赋值语句时，局部变量<code>num</code>指向新的数据<code>10</code> ，但<code>g_num</code>仍然指向<code>5</code> </p>
</blockquote>
<h5 id="如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据"><a href="#如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据" class="headerlink" title="如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据"></a>如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(my_list)</span>:</span></span><br><span class="line">	print(<span class="string">"函数内部："</span>)</span><br><span class="line">	my_list.append(<span class="number">9</span>)</span><br><span class="line">	print(my_list)</span><br><span class="line"></span><br><span class="line">g_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test1(g_list)</span><br><span class="line">print(<span class="string">"程序结束：%s"</span> % g_list)</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">函数内部：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">程序结束：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见外部参数也被修改，其原因是使用数据的自身方法不会创建新的数据，而是在原有数据上的修改，外部变量和局部变量同时指向该地址，因而在函数内部使用方法修改后会影响外部参数</p>
</blockquote>
<h5 id="对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend-方法"><a href="#对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend-方法" class="headerlink" title="+=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法"></a>+=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(num, my_list)</span>:</span></span><br><span class="line">	num += <span class="number">10</span></span><br><span class="line">	print(<span class="string">"不可变类型函数内部+=结果%d"</span> % num)</span><br><span class="line">	my_list += [<span class="number">8</span>]</span><br><span class="line">	print(<span class="string">"可变类型函数内部+=结果%s"</span> % my_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_number = <span class="number">5</span></span><br><span class="line">g_l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test2(g_num,g_l1)</span><br><span class="line">print(<span class="string">"不可变类型外部结果%d"</span> % g_number)</span><br><span class="line">print(<span class="string">"可变类型外部结果%s"</span> % g_l1)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">不可变类型函数内部+=结果<span class="number">15</span></span><br><span class="line">可变类型函数内部+=结果[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">不可变类型外部结果<span class="number">5</span></span><br><span class="line">可变类型外部结果[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见前者外部未改变，后者外部改变</p>
</blockquote>
<hr>
<h2 id="给函数添加缺省值"><a href="#给函数添加缺省值" class="headerlink" title="给函数添加缺省值"></a>给函数添加缺省值</h2><ul>
<li><p>在函数定义时可在参数后面加<code>=</code> 并添加缺省值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(name, gender=True)</span>:</span>   <span class="comment">#True是gender的缺省值</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	输入姓名和性别</span></span><br><span class="line"><span class="string">	:param name: 姓名</span></span><br><span class="line"><span class="string">	:param gender: 性别 True男生 False女生</span></span><br><span class="line"><span class="string">	:return: null</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	gender_text = <span class="string">"男生"</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">		gender_text = <span class="string">"女生"</span></span><br><span class="line">	print(name+<span class="string">"是"</span>+gender_text)</span><br><span class="line"></span><br><span class="line">test3(<span class="string">"小明"</span>)           <span class="comment">#gender未输入，则使用缺省值</span></span><br><span class="line">test3(<span class="string">"小美"</span>, <span class="literal">False</span>)    <span class="comment">#指定gender</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">小明是男生</span><br><span class="line">小美是女生</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：带有缺省值的参数必须放在参数列表的末尾</p>
</li>
<li><p>当有多个缺省参数而需要指定特定的某个参数值时，需要同时输入参数名</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">(name, gender=True, grade=<span class="string">"大一"</span>)</span>:</span></span><br><span class="line">    <span class="comment">#代码块</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果指定gender</span></span><br><span class="line">test4(<span class="string">"小美"</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果指定grade</span></span><br><span class="line">test4(<span class="string">"小明"</span>, grade=<span class="string">"大二"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h2><ul>
<li>有时一个函数传入的参数个数是不确定的，这个时候就可以使用<strong>多值参数</strong> </li>
<li>python中有两种多值参数<ul>
<li>参数名前加<strong>一个</strong> <code>*</code>可以接收<strong>元组</strong> </li>
<li>参数名前加<strong>两个</strong> <code>*</code> 可以接收<code>字典</code> </li>
</ul>
</li>
<li>一般给多值参数命名时，习惯使用以下名字<ul>
<li><code>*args</code> – 存放元组  arguments(变量)</li>
<li><code>**kwargs</code> –存放字典  kw是keyword<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">(num, *args, **kwargs)</span>:</span></span><br><span class="line">	print(num)</span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">demo1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">"小明"</span>, age=<span class="number">18</span>)   <span class="comment">#这种写法无须拆包</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>键不需要加分号，并用=连接</p>
</blockquote>
<ul>
<li>输出结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="元组和字典的拆包"><a href="#元组和字典的拆包" class="headerlink" title="元组和字典的拆包"></a>元组和字典的拆包</h2><ul>
<li>在调用有多致参数的函数时，如果希望<ul>
<li>将元组直接传给<code>args</code> </li>
<li>将字典直接传给<code>kwargs</code></li>
</ul>
</li>
<li>就可以使用拆包<ul>
<li>在元组变量前加<strong>一个</strong><code>*</code></li>
<li>在字典变量前加<strong>两个</strong> <code>*</code></li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">g_nums = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">g_dict = &#123;<span class="string">"姓名"</span>:<span class="string">"小明"</span>, <span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">demo2(g_nums, g_dict)</span><br><span class="line">demo2(g_nums, **g_dict)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), &#123;<span class="string">'姓名'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),)</span><br><span class="line">&#123;<span class="string">'姓名'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见前者字典也被传给了<code>args</code>，与期望不符，而后者加了<code>**</code> 实现预期</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python中关于全局变量</title>
    <url>/2019/09/03/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="python中不允许直接修改全局变量的值"><a href="#python中不允许直接修改全局变量的值" class="headerlink" title="python中不允许直接修改全局变量的值"></a>python中不允许直接修改全局变量的值</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span>     <span class="comment">#定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<ul>
<li>按照其他语言的逻辑，全局变量在test1()中被修改为2，则在test2()中也输出2，而最终的输出结果是</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并未如所想，其原因是python不允许直接修改全局变量的值，如果使用赋值语句，会在函数内部创建一个同名局部变量，而此局部变量在函数执行完成后就会被系统回收</p>
</blockquote>
<h2 id="全局变量的修改"><a href="#全局变量的修改" class="headerlink" title="全局变量的修改"></a>全局变量的修改</h2><ul>
<li>使用<code>global</code> 声明变量即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span>     <span class="comment">#定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="什么时候使用global"><a href="#什么时候使用global" class="headerlink" title="什么时候使用global"></a>什么时候使用global</h3><ul>
<li>当对全局变量的指向进行修改的时候，需要使用<code>global</code>修饰，如果指向没有改变，则不需要，如：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">num_list1 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">num_list2 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> num_list2</span><br><span class="line">    num = <span class="number">20</span>  <span class="comment"># 改变指向，需要声明</span></span><br><span class="line">    num_list1.append(<span class="number">33</span>)  <span class="comment"># 不改变指向，不需声明</span></span><br><span class="line">    num_list2 += [<span class="number">33</span>, <span class="number">44</span>]  <span class="comment"># 执行+=必须要声明global，因为这也是需要改变指向的操作，如果未声明程序就会崩溃</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list1)</span><br><span class="line">    print(num_list2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]  <span class="comment"># 使用append()方法没有改变指向，成功达到预期执行结果</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>

<h2 id="全局变量的命名"><a href="#全局变量的命名" class="headerlink" title="全局变量的命名"></a>全局变量的命名</h2><ul>
<li>可以在全局变量前加<code>g_</code> 或<code>gl_</code> 的前缀</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python的高级数据类型</title>
    <url>/2019/09/03/python%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="获取元素类型"><a href="#获取元素类型" class="headerlink" title="获取元素类型"></a>获取元素类型</h2><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用type()获取数据类型</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(type(my_list))</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>类似于其他数据类型中的<strong>数组</strong></li>
<li>列表使用<code>[]</code>括起来</li>
<li>列表中可以存储不同类型的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>]</span><br><span class="line">print(my_list[<span class="number">0</span>])   <span class="comment">#取值</span></span><br><span class="line">print(my_list.index(<span class="string">"aaa"</span>)) <span class="comment">#取索引</span></span><br><span class="line"></span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">"ddd"</span>  <span class="comment">#修改</span></span><br><span class="line"></span><br><span class="line">my_list.append(<span class="string">"eee"</span>)   <span class="comment">#增加数据</span></span><br><span class="line">my_list.insert(<span class="number">1</span>,<span class="string">"fff"</span>) <span class="comment">#插入数据在my_list[1]，后面的数据后移</span></span><br><span class="line">temp_list = [<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">my_list.extend(temp_list)   <span class="comment">#将另一个列表扩展进来</span></span><br><span class="line"></span><br><span class="line">my_list.remove(<span class="string">"bbb"</span>)   <span class="comment"># 删除指定元素,如果出现多次，删除第一个</span></span><br><span class="line">my_list.pop()       <span class="comment">#默认删除最后一个元素（出栈）</span></span><br><span class="line">my_list.pop(<span class="number">3</span>)      <span class="comment">#删除my_list[3]</span></span><br><span class="line">my_list.clear       <span class="comment">#清空列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]      <span class="comment">#利用del删除（直接从内存中删除，后续代码不可使用该变量）</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line">length = len(my_list)   <span class="comment">#读取列表大小</span></span><br><span class="line">time = my_list.count(<span class="string">"aaa"</span>)     <span class="comment">#读取aaa出现的次数</span></span><br><span class="line"></span><br><span class="line">my_list.sort()      <span class="comment">#升序排序</span></span><br><span class="line">my_list.sort(reverse=<span class="literal">True</span>)  <span class="comment">#降序排序</span></span><br><span class="line">my_list.reverse()   <span class="comment">#逆序反转</span></span><br></pre></td></tr></table></figure>

<ul>
<li>迭代遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> temp_name <span class="keyword">in</span> my_list:</span><br><span class="line">    print(<span class="string">"the name is %s"</span> % temp_name)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="创建列表的方式"><a href="#创建列表的方式" class="headerlink" title="创建列表的方式"></a>创建列表的方式</h3><ul>
<li><p>基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>list()</code>创建</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list1 = list(<span class="string">"abcde"</span>)</span><br><span class="line">my_list2 = list(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">print(my_list1)</span><br><span class="line">print(my_list2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用<code>range()</code>可以快速创建整数列表，其格式为<code>range([start,] end [,step])</code>，它返回的是一个range对象</p>
<blockquote>
<p><code>start</code>：起始数字，默认0<br><code>end</code>：结尾数字，必须指定<br><code>step</code>：步长，默认1</p>
</blockquote>
</blockquote>
<ul>
<li>推导式生成列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list3 = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">my_list4 = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>) <span class="keyword">if</span> x%<span class="number">5</span>==<span class="number">0</span>]</span><br><span class="line">my_list5 = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">if</span> y%<span class="number">3</span>==<span class="number">0</span>]</span><br><span class="line">my_list6 = [a <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"hello"</span>]</span><br><span class="line">print(my_list3)</span><br><span class="line">print(my_list4)</span><br><span class="line">print(my_list5)</span><br><span class="line">print(my_list6)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">225</span>, <span class="number">400</span>, <span class="number">625</span>, <span class="number">900</span>, <span class="number">1225</span>, <span class="number">1600</span>, <span class="number">2025</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">0</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li><p>元组与列表相似，不同之处在于元组的元素<strong>不能修改</strong> </p>
</li>
<li><p>使用<code>()</code> 定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单元素元组</span></span><br><span class="line">single_tuple = (<span class="number">5</span>)   <span class="comment">#这样定义得到的single_tuple是int类型</span></span><br><span class="line">single_tuple = (<span class="number">5</span>,)  <span class="comment">#正确</span></span><br><span class="line"></span><br><span class="line">my_tuple(<span class="number">1</span>)     <span class="comment"># 取值</span></span><br><span class="line">my_tuple.index(<span class="string">"aaa"</span>)   <span class="comment">#取索引</span></span><br><span class="line">my_tuple.count(<span class="string">"aaa"</span>)   <span class="comment">#统计aaa出现次数</span></span><br><span class="line">len(my_tuple)       <span class="comment">#统计长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> temp_info <span class="keyword">in</span> my_tuple:</span><br><span class="line">    执行代码</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="元组的应用"><a href="#元组的应用" class="headerlink" title="元组的应用"></a>元组的应用</h3><ul>
<li><p>拼接字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">175.5</span>)</span><br><span class="line">print(<span class="string">"%s的年龄是%d,身高是%f"</span> % my_tuple)</span><br><span class="line"></span><br><span class="line">my_str = <span class="string">"%s的年龄是%d,身高是%f"</span> % my_tuple</span><br><span class="line">print(my_str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>保护列表安全</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_tuple1 = tuple(my_list)      <span class="comment">#使用tuple()将list转换成tuple</span></span><br><span class="line">my_list2 = list(my_tuple1)      <span class="comment">#使用list()将tuple转换成list</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用元组返回多个值(同理也可使用列表，字典，集合)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    str = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">return</span> (num, str)</span><br><span class="line">    </span><br><span class="line">temp = test()       <span class="comment">#则temp是一个元组类型</span></span><br><span class="line">temp1, temp2 = test() <span class="comment">#多个变量接收返回值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交换数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = (b, a)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="生成器推导式生成元组"><a href="#生成器推导式生成元组" class="headerlink" title="生成器推导式生成元组"></a>生成器推导式生成元组</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_tp1 = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line">my_tp2 = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>) <span class="keyword">if</span> x%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 打印生成器</span></span><br><span class="line">print(my_tp1)</span><br><span class="line">print(my_tp2)</span><br><span class="line"><span class="comment"># 打印生成的元组，注意只能调用一次tuple()</span></span><br><span class="line">print(tuple(my_tp1))</span><br><span class="line">print(tuple(my_tp2))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc850&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc8d0&gt;</span><br><span class="line">(0, 2, 4, 6, 8)</span><br><span class="line">(0, 25, 100, 225, 400, 625, 900, 1225, 1600, 2025)</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul>
<li>使用<code>{}</code>定义</li>
<li>列表是有序的数据集合</li>
<li>字典是无序的数据集合</li>
<li>使用<code>键值对</code>存储数据<ul>
<li><strong>键</strong> <em>(key)</em> 是索引，必须<strong>唯一</strong> ，只能是<strong>字符串，数字，或者元组</strong> </li>
<li><strong>值</strong> <em>(value)</em> 是数据，可以是任意数据类型</li>
<li><em>key</em> 和<em>value</em> 之间使用<code>:</code> 分隔</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于字典无序，通常使用print()打印的结果与定义的顺序不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义</span></span><br><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>, </span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>, </span><br><span class="line">            <span class="string">"height"</span>: <span class="number">175</span>&#125;</span><br><span class="line">            </span><br><span class="line">xiaoming[<span class="string">"name"</span>]        <span class="comment">#取值</span></span><br><span class="line">xiaoming[<span class="string">"weight"</span>] = <span class="number">70</span> <span class="comment">#不存在则增加</span></span><br><span class="line">xiaoming[<span class="string">"age"</span>] = <span class="number">19</span>    <span class="comment">#若存在则修改</span></span><br><span class="line"></span><br><span class="line">xiaoming.pop(<span class="string">"weight"</span>)  <span class="comment">#删除</span></span><br><span class="line"></span><br><span class="line">len(xiaoming)           <span class="comment">#统计键值对数目</span></span><br><span class="line"></span><br><span class="line">temp_dict = &#123;<span class="string">"gender"</span>: boy, </span><br><span class="line">             <span class="string">"age"</span>: <span class="number">20</span>&#125;</span><br><span class="line">xiaoming.update(temp_dict)  <span class="comment">#若新增key不存在，则增加;若key重复，则会替换掉之前的value</span></span><br><span class="line"></span><br><span class="line">xiaoming.clear()        <span class="comment">#清空</span></span><br><span class="line">xiaoming.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">"name"</span>: <span class="string">"zhangsan"</span>, </span><br><span class="line">           <span class="string">"age"</span>: <span class="string">"18"</span>&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment"># 变量temp是my_dict中的key</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_dict:</span><br><span class="line">    print(<span class="string">"%s - %s"</span> % (temp,my_dict[temp]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用<br>先用字典存储复杂数据，再将多个字典放在一个列表中管理</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"zhangsan"</span>, </span><br><span class="line">     <span class="string">"qq"</span>: <span class="string">"12345"</span>&#125;</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"lisi"</span>, </span><br><span class="line">     <span class="string">"qq"</span>: <span class="string">"12412"</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> card_list:</span><br><span class="line">    print(info)</span><br></pre></td></tr></table></figure>

<h3 id="创建字典的几种方式"><a href="#创建字典的几种方式" class="headerlink" title="创建字典的几种方式"></a>创建字典的几种方式</h3><ul>
<li><p>使用{}基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict1 = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>, <span class="string">"age"</span>:<span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>dict()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict2 = dict(name=<span class="string">"张三"</span>, age=<span class="number">18</span>)</span><br><span class="line">my_dict3 = dict((<span class="string">"name"</span>, <span class="string">"张三"</span>), (<span class="string">"age"</span>, <span class="number">18</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>zip()</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_key = [<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>]</span><br><span class="line">my_value = [<span class="string">"张三"</span>, <span class="number">18</span>, <span class="string">"teacher"</span>]</span><br><span class="line">my_dict4 = dict(zip(my_key, my_value))</span><br><span class="line">print(my_dict4)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;job&apos;: &apos;teacher&apos;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>fromkeys</code>创建值为空的字典<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict5 = dict.fromkeys([<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>])</span><br><span class="line">print(my_dict5)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;name&apos;: None, &apos;age&apos;: None, &apos;job&apos;: None&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典推导式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用推导式统计字符出现次数</span></span><br><span class="line">my_text = <span class="string">"hello, world"</span></span><br><span class="line">my_dict6 = &#123;my_char:my_text.count(my_char) <span class="keyword">for</span> my_char <span class="keyword">in</span> my_text&#125;</span><br><span class="line">print(my_dict6)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">','</span>: <span class="number">1</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote>
<p>集合无序可变，<strong>元素不能重复</strong>，集合底层是字典实现，集合中的元素都是字典中的<code>键对象</code>，因此不可重复</p>
</blockquote>
<ul>
<li><p>使用{}创建集合对象，并使用<code>add()</code>添加元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">a.add(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>set()</code>可以将列表，元组等可迭代对象转化为集合，如果数据重复，只保存一个</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>]</span><br><span class="line">b = set(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>remove()</code>删除指定元素，<code>clear()</code>清空集合</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a.remove(<span class="string">"a"</span>)</span><br><span class="line">a.clear()</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合相关操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">2</span>, <span class="string">"a"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">print(a|b)</span><br><span class="line">print(a.union(b))</span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">print(a&amp;b)</span><br><span class="line">print(a.intersection(b))</span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">print(a-b)</span><br><span class="line">print(a.difference(b))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串定义：使用''或""括起来的内容</span></span><br><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">'world'</span>  <span class="comment">#为了和其他语言统一，尽量不使用单引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当需要字符串中包含引号时</span></span><br><span class="line">str3 = <span class="string">"my name is "</span>dgs<span class="string">""</span>   <span class="comment">#错误</span></span><br><span class="line">str4 = <span class="string">'my name is "dgs"'</span>   <span class="comment">#正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取值</span></span><br><span class="line">str = <span class="string">"abcdefabcbac"</span></span><br><span class="line">str[<span class="number">2</span>]  <span class="comment">#第三个字符</span></span><br><span class="line">str[<span class="number">-1</span>] <span class="comment">#倒数第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代遍历</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> str:</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line">len(str)        <span class="comment">#统计长度</span></span><br><span class="line">str.index(”e“)    <span class="comment">#获取索引</span></span><br><span class="line">str.count(”a“)    <span class="comment">#统计a出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串切片  字符串[开始索引:结束索引:步长]，不包含结尾处索引的内容</span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">6</span>]    <span class="comment">#截取第二个到第六个</span></span><br><span class="line">str[<span class="number">2</span>:]     <span class="comment">#从第二个到末尾</span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">-1</span>]   <span class="comment">#从第二个到倒数第一个</span></span><br><span class="line">str[:<span class="number">6</span>]     <span class="comment">#从开头到第六个</span></span><br><span class="line">str[::<span class="number">2</span>]    <span class="comment">#每隔一个截取一个</span></span><br><span class="line">str[<span class="number">-1</span>::<span class="number">-1</span>] <span class="comment">#获得字符串倒序</span></span><br></pre></td></tr></table></figure>

<h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td><code>del</code> 有两种方式<code>del(temp[1])</code> /<code>del(temp)</code></td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器元素最大值</td>
<td>字典只比较key</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器元素最小值</td>
<td>字典只比较key</td>
</tr>
<tr>
<td>cmp(item1, item2)</td>
<td>比较两个值，<code>-1</code> 小于，<code>0</code> 等于，<code>1</code> 大于</td>
<td>python3取消了cmp</td>
</tr>
</tbody></table>
<ul>
<li>字符串比较遵循：<code>0</code> &lt;<code>A</code> &lt;<code>a</code> </li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][::<span class="number">2</span>]</span><br><span class="line">t1 = (<span class="string">"s"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">5</span>)[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 字典不能切片</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>演示</th>
<th>结果</th>
<th>描述</th>
<th>支持类型</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>[1, 2]+[3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串，列表，元组</td>
</tr>
<tr>
<td>*</td>
<td>(“hi”)*3</td>
<td>(“hi”,”hi”,”hi”)</td>
<td>重复</td>
<td>同上</td>
</tr>
<tr>
<td>in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>是否存在，字典判断key</td>
<td>字符串，列表，元组，字典</td>
</tr>
<tr>
<td>not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>是否不存在，字典判断key</td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code> <code>&gt;</code> 等</td>
<td>(1, 2, 3)&lt;(2, 3, 4)</td>
<td>True</td>
<td>比较</td>
<td>字符串，列表，元组</td>
</tr>
</tbody></table>
<blockquote>
<p><code>+</code> 与<code>entend()</code> 方法的区别：前者生成一个新的变量，后者追加到调用该方法的变量</p>
</blockquote>
<ul>
<li><p>append()与extend()区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2.append(<span class="number">4</span>)</span><br><span class="line">print(l2)</span><br><span class="line"><span class="comment"># 不能l2.extend(5)，extend()只能传入容器</span></span><br><span class="line">l2.append([<span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">print(l2)</span><br><span class="line">l2.extend([<span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>]]        <span class="comment"># 将append([6, 7])当成了一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]  <span class="comment"># 将extend([8, 9])追加</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="完整的for循环"><a href="#完整的for循环" class="headerlink" title="完整的for循环"></a>完整的for循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过<span class="keyword">break</span>退出循环，遍历结束后就会执行</span><br></pre></td></tr></table></figure>

<ul>
<li>应用<br>遍历完成后，如果没有查询的就提示</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>对变量使用自身的方法进行增删改不会改变id，而重新赋值会改变，这时它的指针指向了另一个地址</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python的一些基础知识</title>
    <url>/2019/09/03/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="python的运算符"><a href="#python的运算符" class="headerlink" title="python的运算符"></a>python的运算符</h2><a id="more"></a>

<blockquote>
<p>与C,java等不同</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td>10 + 20 = 30</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td>10 - 20 = -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td>10 * 20 = 200</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除</td>
<td>10 / 20 = 0.5</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">取整除</td>
<td>返回除法的整数部分（商） 9 // 2 输出结果 4</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余数</td>
<td>返回除法的余数 9 % 2 = 1</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂</td>
<td>又称次方、乘方，2 ** 3 = 8</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">与</td>
<td>a &gt;= 1 and a &lt;= 4</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">或</td>
<td>a &gt; 1 or a &lt; 10</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">非</td>
<td>not a &lt; 1</td>
</tr>
<tr>
<td align="center"><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code></td>
<td align="center">赋值运算</td>
<td>a+=1等同于a=a+1</td>
</tr>
</tbody></table>
<h2 id="查看关键字"><a href="#查看关键字" class="headerlink" title="查看关键字"></a>查看关键字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a==<span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"aaa"</span>)</span><br><span class="line"><span class="keyword">elif</span> a==<span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"bbb"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"ccc"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>if</code>后面可以接<strong>布尔运算，数字，字符串，列表，元组，字典等</strong>，为真的条件是这些元素<strong>为True，非0，非None</strong></p>
</blockquote>
<ul>
<li>条件分行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用()将条件括起来，在布尔运算符前可分行</span></span><br><span class="line"><span class="keyword">if</span>((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">or</span> (a ==<span class="number">2</span> <span class="keyword">and</span> b ==<span class="number">3</span>)):</span><br><span class="line">    print(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义的函数要在使用前声明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(param1,param2)</span>:</span></span><br><span class="line">    封装代码</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数下方缩进后使用连续的三个'或“可以给函数编辑注释</span></span><br><span class="line"><span class="comment"># 如果此时直接按回车会生成带参数描述的文档注释</span></span><br><span class="line"><span class="comment"># 并且之后调用时可以使用Ctrl+Q快速查看</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''this is a test example'''</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># TODO(作者/邮件) 这是TODO注释，提醒接下来要做的工作，可以在pycharm左下角找到所有TODO项</span></span><br></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><ul>
<li><p>数字和字符串输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line">print(<span class="string">"you are %d"</span> % age)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个数字和字符串输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line">num3 = <span class="number">10.5</span></span><br><span class="line">print(<span class="string">"the number is %d , %d and %f"</span> % (num1,num2,num3))    <span class="comment">#实际上这是元组的应用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>%d是以十进制输出，可用%x以十六进制输出</p>
</blockquote>
<ul>
<li><p>使print不换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print()方法默认是在尾部添加了换行符，而如果不想换行可以加,end=""</span></span><br><span class="line">print(<span class="string">"hello"</span>,end=<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他使用</span></span><br><span class="line">print(<span class="string">"hellp"</span>,end=<span class="string">"***"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连续输出相同内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"*"</span> * <span class="number">50</span>)  <span class="comment">#连续输出50个*</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input(<span class="string">"请输入："</span>)</span><br></pre></td></tr></table></figure>

<p>控制台输入的内容是字符串，如果需要用于判断，则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = int(input(<span class="string">"请输入"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randint(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">#生成10-20间的随机整数</span></span><br></pre></td></tr></table></figure>

<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><ul>
<li>使用<code>import</code>关键字导入模块，所有以<code>.py</code>结尾的文件都可以看作一个模块</li>
<li>模块不能使用<strong>数字</strong>开头</li>
</ul>
<h3 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h3><ul>
<li>当使用import导入模块并编译后，会在编译文件夹中生成<code>.pyc</code>文件，这是使用<code>cpython</code>编译出的二进制文件，使得每次使用模块不需要反复解释，以提高执行性能</li>
</ul>
<h2 id="跳过"><a href="#跳过" class="headerlink" title="跳过"></a>跳过</h2><ul>
<li>如果写了判断或其他情况暂时不写某些代码时，可以使用<code>pass</code> 充当占位符，使编译器不报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br><span class="line">num = input(<span class="string">"please input:"</span>)</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="shebang符号"><a href="#shebang符号" class="headerlink" title="shebang符号"></a>shebang符号</h2><ul>
<li><code>#!</code> 是shebang符号，他后面加上解释器的路径即可在终端下通过输入文件地址而直接运行，且不影响在pycharm中运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /usr/bin/python3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><ul>
<li>id(变量/数据)   查看其内存地址</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年--在武大智能车</title>
    <url>/2019/09/01/%E8%BF%99%E4%B8%80%E5%B9%B4-%E5%9C%A8%E6%AD%A6%E5%A4%A7%E6%99%BA%E8%83%BD%E8%BD%A6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><h2 id="此刻"><a href="#此刻" class="headerlink" title="此刻"></a>此刻</h2></blockquote>

<a id="more"></a>

<p>  坐在电脑前，也许应该点燃<strong>一支烟</strong>，吸一口，神清气爽，<strong>念天地之悠悠</strong>，吐一口，烟云缭绕，<strong>独怆然而涕下</strong>。于烟云之端，闭上双眼，追古溯今，回味这身于其中恨其长，蓦然回首已惘然的一年。</p>
<p>  可是，我不会抽烟。</p>
<p>  所以，我不能在烟云中幻想，只能在现实中回望。</p>
<p>  回忆起来，尽管最终结果平平，但它仍旧不同以往，给大学生活添上了不寻常的一笔。</p>
<blockquote class="blockquote-center"><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2></blockquote> 

<p>  冬天的枝叶败落后，又在春天绿意盎然，如是想想，我也应该走出决赛失利的阴霾中，好好记录下这一年的高兴与惆怅，开怀与彷徨。</p>
<p>  从大一的那个暑假走来，转眼一年多过去了，校内赛前能装实验室汗流夹背的景象回想起来，仿佛就在昨天，那个时候想必是这一年最难熬的吧。周围都是陌生的面孔，大家都为了入队而不断学习。两个月的时间里，很多人坚持不下去走了，但更多的坚持了下来，走过11月的校内赛，成功进入智能车这个大家庭。</p>
<p>  那段时间应当感谢与我同行的两个同学，<strong>赵富强</strong>和<strong>雷飞</strong>，不如就合称<strong>赵雷</strong>吧，哈哈，感谢“赵雷“的陪伴，和赵雷的歌曲，陪我一步一步迈过那两个月的时光。</p>
<blockquote class="blockquote-center"><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2></blockquote> 

<p>  校内赛后，我选择了节能组，并负责软件部分，但由于组别的特殊性，我们组所有人都负责结构设计，华南赛前我花在结构设计上的时间甚至多于调试程序的时间。</p>
<p>  也许那个时候方向真是错了，也因此，每次开会，我们组都是被点名的那个。</p>
<p>  前后花了几个月，多方咨询，多次改稿，最终还真的设计出了一款机械能的车模。</p>
<p><img src="car3.png" alt="机械能车模"> </p>
<p>  然而，由于零件难以找到合适的，且直观感觉它并不会节省能量，最终在四月份刚拼起来就被舍弃，前功尽弃–想想有些可惜。</p>
<p>  这样，我们开始专心搭纯电履带车，我专心负责程序编写。</p>
<p>  之前只是大概写了个框架，没有几个月就要比赛了，那时候我有些慌了，尤其是在圆环的处理上，由于车身晃动太大和程序鲁棒性太差，总是出现各种问题，要不识别不到，要不识别过早，或者进去出不来，总之，问题百出。</p>
<p>  即使是华南赛就要来临，即使我们天天熬夜，但成功率仍旧不高，那个时候甚至一度怀疑是否能挺过华南赛，是不是拿个华二就结束了…</p>
<p>  然而，我也不敢大改程序，怕这一改便成仁了…</p>
<blockquote class="blockquote-center"><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2></blockquote> 

<p>  七月，空气中弥漫着潮湿的味道，智能车队整装出发。我们组内调侃：去旅个游就放假啦，好开心。</p>
<p>  不过我心里其实还存有一丝侥幸，10多分钟，总能成功的吧。</p>
<p>  试车：路障过不去，有些慌了</p>
<p>  预赛：电感坏了，心想凉了，还好临时修好，一次成功</p>
<p>  决赛：一次成功</p>
<p>  结果如我所愿，成功狗过华南赛，还拿了个第二名的成绩，但可以看出来，不论结构和程序都很不稳定。</p>
<ul>
<li><p>华南赛后合照<br><img src="car6.jpg" alt="合照">  <img src="car1.jpg" alt="合照"> </p>
<p>那几天的长沙天气不错，我们三五成群，晚上就出去逛街，喝过了网红饮品<strong>茶颜悦色</strong>，吃过了毛主席都爱吃的<strong>长沙臭豆腐</strong>，也算不虚此行。</p>
</li>
<li><p>和帅哥<em>茶颜悦色</em>打卡<br><img src="car11.jpg" alt="打卡"> </p>
<p>哦，对了，张老师摔得那下有点惨0.0当时都吓到我们了</p>
</li>
</ul>
<blockquote class="blockquote-center"><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2></blockquote> 

<p>  华南赛回来后，我决定重写程序，花了差不多十天左右的时间写完，调试。改完之后感觉良好，比之前的稳定很多，速度也从1.5提高到了1.68左右，用电池跑的时候，经常可以一次性跑五六圈都没有问题。</p>
<p>  但是不知道为什么，每辆车刚搭出来表现不错，越跑就越变的不尽如人意了，只能降低速度，但我想这不应该是程序的问题，试了试其他样式的履带，结果一般，最终没有改动车体结构，也没有去深究这个问题。</p>
<p>  剩下的二十天我调车的时间就下降了，和队里大部分人一样开始了<strong>养老生活</strong>。</p>
<p>  转眼间，就从珞珈山下踏到了渤海之边。</p>
<blockquote class="blockquote-center"><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2></blockquote> 

<p>  我们走过了沙滩，趟过了海浪，挖过了拖鞋，埋过了雷飞…然而我只想问：海边为什么都是中年油腻大爷大妈，和我想象的不太一样啊…</p>
<ul>
<li>我们在海滩</li>
</ul>
<p><img src="car8.jpeg" alt="沙滩"><br><img src="car9.jpeg" alt="沙滩"> </p>
<blockquote>
<p>快乐的玩耍</p>
</blockquote>
<p><img src="car10.jpeg" alt="快乐"></p>
<p>  比赛时，唉不想说了，一上场就发现和在实验室的差异了，实验室赛道较光滑，而威海的赛道摩擦力太大，以至于每次转弯车都要跳两下，出环岛时也不像在实验室那样顺滑，我在旁边胆战心惊。</p>
<p>  而预赛的下午场和决赛，又出现了莫名其妙的问题，好几次在直道弯道处就撞上路障夭折了…这种情况在实验室从未出现过，还有一次刚到路障直接停车了，不明所以，事后我们组觉得可能是车硬件有问题，但那块板子自从按上以后我每天只是稍微跑跑，所以没有暴露出来，而当在国赛时显露出来，也来不及补救了。</p>
<p>  于是最终拖了十四届的后腿，成为了唯一一个二等奖项。</p>
<p>  <strong>嘤嘤嘤</strong> …</p>
<blockquote class="blockquote-center"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote> 

<p>  这一年无论结果如何，也伴着专老师的点拨，张老师的关怀，杨老师的鸡汤和整个车队的陪伴走过去了。这一年终将永久存留于每位十四届智能车队员的心中，并在未来珍藏，回味，历久弥新…</p>
<p><img src="car2.jpg" alt="合影"> </p>
<p>  最后，盛年不重来，我们<strong>J</strong><del>in</del><strong>M</strong><del>a</del><strong>M</strong><del>en</del>见吧！(滑稽)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2019/08/30/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><a id="more"></a>

<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">...</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<ul>
<li>n#+文字 n级标题</li>
</ul>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">*斜体*</span><br><span class="line">==高亮==</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br><span class="line">^上标^</span><br><span class="line">~下标~</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序标题"><a href="#无序标题" class="headerlink" title="无序标题"></a>无序标题</h3><ul>
<li>使用”*”或者”+”后面跟空格，按一下回车会自动加标题，按两下会消失<blockquote>
<p>eg：</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- 一二三四五</span><br><span class="line">- 上山打老虎</span><br><span class="line">  - 下一级为空心圆</span><br><span class="line">    - 再下一级是实心方块</span><br><span class="line">      - 之后都是实心方块</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ul>
<li>一二三四五</li>
<li>上山打老虎<ul>
<li>下一级为空心圆<ul>
<li>再下一级是实心方块<ul>
<li>之后都是实心方块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序标题"><a href="#有序标题" class="headerlink" title="有序标题"></a>有序标题</h3><p>与word类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 一级</span><br><span class="line"><span class="number">2.</span> 二级</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ol>
<li>一级</li>
<li>二级</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>第二行要有连字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">| 姓名 | 学号 | 专业 | 班级 |</span><br><span class="line">|------|------|------|------|</span><br><span class="line">| 张三 | <span class="number">037</span>  | 机械 | 四班 |</span><br></pre></td></tr></table></figure>

<p>效果</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>专业</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>037</td>
<td>机械</td>
<td>四班</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; 大于号加引用内容</span><br><span class="line">&gt;&gt; 二级引用，可多级</span><br></pre></td></tr></table></figure>

<p>效果</p>
<blockquote>
<p>大于号加引用内容</p>
<blockquote>
<p>二级引用，可多级</p>
</blockquote>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用连字符，上一行不能有字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  上文</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">  下文</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>  上文</p>
<hr>
<p>  下文</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用``将代码括起来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`print(<span class="string">"hello"</span>) `</span><br></pre></td></tr></table></figure>

<h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;http://www.baidu.com&gt;</span><br><span class="line">2. [百度](http://www.baidu.com)</span><br><span class="line">3. 我经常用[百度][1]搜索，很少用[必应][2]</span><br><span class="line"></span><br><span class="line">[1]:http://www.baidu.com/ &quot;Baidu&quot;</span><br><span class="line">[2]:http://www.bing.com/ &quot;Bing&quot;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ol>
<li><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li>
<li><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></li>
<li>我经常用<a href="http://www.baidu.com/" title="Baidu" target="_blank" rel="noopener">百度</a>搜索，很少用<a href="http://www.bing.com/" title="Bing" target="_blank" rel="noopener">必应</a></li>
</ol>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![狮子](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&amp;fm=26&amp;gp=0.jpg &quot;this is a lion&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&fm=26&gp=0.jpg" alt="狮子" title="this is a lion"></p>
<h2 id="百度地图"><a href="#百度地图" class="headerlink" title="百度地图"></a>百度地图</h2><blockquote>
<p>网址<a href="http://api.map.baidu.com/lbsapi/creatmap/index.html" target="_blank" rel="noopener">http://api.map.baidu.com/lbsapi/creatmap/index.html</a></p>
</blockquote>
<p>注意要在html文件中加<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>限定编码格式，否则<strong>可能乱码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;~/Markdown/map.html&quot; width=&quot;600&quot; height=&quot;300&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta name="generator" content="Hexo 3.9.0">
<meta charset="UTF-8">
<!--<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta name="keywords" content="百度地图,百度地图API，百度地图自定义工具，百度地图所见即所得工具" />
<meta name="description" content="百度地图API自定义地图，帮助用户在可视化操作下生成百度地图" />
<title>百度地图API自定义地图</title>-->
<!--引用百度地图API-->
<style type="text/css">
    html,body{margin:0;padding:0;}
    .iw_poi_title {color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap}
    .iw_poi_content {font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word}
</style>
<script type="text/javascript" src="http://api.map.baidu.com/api?key=&v=1.1&services=true"></script>
</head>

<body>
  <!--百度地图容器-->
  <div style="width:697px;height:550px;border:#ccc solid 1px;" id="dituContent"></div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":175,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<script type="text/javascript">
    //创建和初始化地图函数：
    function initMap(){
        createMap();//创建地图
        setMapEvent();//设置地图事件
        addMapControl();//向地图添加控件
        addMarker();//向地图中添加marker
        addPolyline();//向地图中添加线
        addRemark();//向地图中添加文字标注
    }
    
    //创建地图函数：
    function createMap(){
        var map = new BMap.Map("dituContent");//在百度地图容器中创建一个地图
        var point = new BMap.Point(114.368076,30.543335);//定义一个中心点坐标
        map.centerAndZoom(point,17);//设定地图的中心点和坐标并将地图显示在地图容器中
        window.map = map;//将map变量存储在全局
    }
    
    //地图事件设置函数：
    function setMapEvent(){
        map.enableDragging();//启用地图拖拽事件，默认启用(可不写)
        map.enableScrollWheelZoom();//启用地图滚轮放大缩小
        map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写)
        map.enableKeyboard();//启用键盘上下左右键移动地图
    }
    
    //地图控件添加函数：
    function addMapControl(){
        //向地图中添加缩放控件
	var ctrl_nav = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE});
	map.addControl(ctrl_nav);
        //向地图中添加缩略图控件
	var ctrl_ove = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1});
	map.addControl(ctrl_ove);
        //向地图中添加比例尺控件
	var ctrl_sca = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT});
	map.addControl(ctrl_sca);
    }
    
    //标注点数组
    var markerArr = [{title:"终点",content:"come",point:"114.371444|30.545357",isOpen:1,icon:{w:21,h:21,l:46,t:46,x:1,lb:10}}
		 ];
    //创建marker
    function addMarker(){
        for(var i=0;i<markerArr.length;i++){
            var json = markerArr[i];
            var p0 = json.point.split("|")[0];
            var p1 = json.point.split("|")[1];
            var point = new BMap.Point(p0,p1);
			var iconImg = createIcon(json.icon);
            var marker = new BMap.Marker(point,{icon:iconImg});
			var iw = createInfoWindow(i);
			var label = new BMap.Label(json.title,{"offset":new BMap.Size(json.icon.lb-json.icon.x+10,-20)});
			marker.setLabel(label);
            map.addOverlay(marker);
            label.setStyle({
                        borderColor:"#808080",
                        color:"#333",
                        cursor:"pointer"
            });
			
			(function(){
				var index = i;
				var _iw = createInfoWindow(i);
				var _marker = marker;
				_marker.addEventListener("click",function(){
				    this.openInfoWindow(_iw);
			    });
			    _iw.addEventListener("open",function(){
				    _marker.getLabel().hide();
			    })
			    _iw.addEventListener("close",function(){
				    _marker.getLabel().show();
			    })
				label.addEventListener("click",function(){
				    _marker.openInfoWindow(_iw);
			    })
				if(!!json.isOpen){
					label.hide();
					_marker.openInfoWindow(_iw);
				}
			})()
        }
    }
    //创建InfoWindow
    function createInfoWindow(i){
        var json = markerArr[i];
        var iw = new BMap.InfoWindow("<b class='iw_poi_title' title='" + json.title + "'>" + json.title + "</b><div class='iw_poi_content'>"+json.content+"</div>");
        return iw;
    }
    //创建一个Icon
    function createIcon(json){
        var icon = new BMap.Icon("http://app.baidu.com/map/images/us_mk_icon.png", new BMap.Size(json.w,json.h),{imageOffset: new BMap.Size(-json.l,-json.t),infoWindowOffset:new BMap.Size(json.lb+5,1),offset:new BMap.Size(json.x,json.h)})
        return icon;
    }
//标注线数组
    var plPoints = [{style:"solid",weight:4,color:"#f00",opacity:0.6,points:["114.365318|30.5401","114.366755|30.542324","114.367797|30.543568","114.369648|30.544564","114.371426|30.545326"]}
		 ];
    //向地图中添加线函数
    function addPolyline(){
		for(var i=0;i<plPoints.length;i++){
			var json = plPoints[i];
			var points = [];
			for(var j=0;j<json.points.length;j++){
				var p1 = json.points[j].split("|")[0];
				var p2 = json.points[j].split("|")[1];
				points.push(new BMap.Point(p1,p2));
			}
			var line = new BMap.Polyline(points,{strokeStyle:json.style,strokeWeight:json.weight,strokeColor:json.color,strokeOpacity:json.opacity});
			map.addOverlay(line);
		}
	}
//文字标注数组
    var lbPoints = [{point:"114.365031|30.540007",content:"起点"}
		 ];
    //向地图中添加文字标注函数
    function addRemark(){
        for(var i=0;i<lbPoints.length;i++){
            var json = lbPoints[i];
            var p1 = json.point.split("|")[0];
            var p2 = json.point.split("|")[1];
            var label = new BMap.Label("<div style='padding:2px;'>"+json.content+"</div>",{point:new BMap.Point(p1,p2),offset:new BMap.Size(3,-6)});
            map.addOverlay(label);
            label.setStyle({borderColor:"#999"});
        }
    }
    
    initMap();//创建和初始化地图
</script>
</html>

]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2019/08/30/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git版本创建"><a href="#git版本创建" class="headerlink" title="git版本创建"></a>git版本创建</h2><a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git init        <span class="comment">//初始化git仓库</span></span><br><span class="line">git add .       <span class="comment">//添加全部修改</span></span><br><span class="line">git add 文件名  <span class="comment">//添加指定文件的修改</span></span><br><span class="line">git commit -m <span class="string">"说明信息"</span>    <span class="comment">//提交并添加备注</span></span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>     <span class="comment">//查看版本信息</span></span><br></pre></td></tr></table></figure>

<p><img src="git_log.png" alt="git log"> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git status  <span class="comment">//查看修改信息</span></span><br></pre></td></tr></table></figure>

<p><img src="git_status.png" alt="gitstatus"> </p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li><code>HEAD</code>指针会指向最新的版本</li>
<li><code>HEAD^</code>指向上一个版本</li>
<li><code>HEAD^^</code>指向上上个版本…</li>
<li>或者使用<code>HEAD~n</code>代表前n个版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^      <span class="comment">//回退到上一个版本</span></span><br><span class="line">git reset --hard HEAD~<span class="number">3</span>     <span class="comment">//回退到之前3个版本</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>git快速入门</title>
    <url>/2019/08/29/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li><code>git init</code><blockquote>
<p>将当前文件下变为git仓库</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>git status</code></p>
<blockquote>
<p>查看git仓库的状态</p>
</blockquote>
</li>
<li><p><code>git add</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git add 文件  <span class="comment">#添加指定文件的修改</span></span><br><span class="line">git add .     <span class="comment">#添加所有文件的修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git diff</code> </p>
<blockquote>
<p>显示文件修改信息</p>
</blockquote>
</li>
<li><p><code>git reset</code></p>
<blockquote>
<p>退回追踪</p>
</blockquote>
</li>
<li><p><code>git config</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"zhangsan"</span>            <span class="comment">#配置用户名</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"example@qq.com"</span>     <span class="comment">#配置邮箱</span></span><br><span class="line">git config --<span class="keyword">global</span> core.editor vim                 <span class="comment">#配置默认编辑器</span></span><br><span class="line">git config credential.helper store                  <span class="comment">#在执行`push`前输入这段命令，会使git记住用户名和密码，之后就不用再输入</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git commit</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git commit                 <span class="comment">#会打开编辑器，可输入描述信息</span></span><br><span class="line">git commit -m <span class="string">"some text"</span>  <span class="comment">#提交更改并添加描述信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>让git忽略管理某些文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vim .gitignore   <span class="comment">#创建此文件，并在其中编辑要忽略的文件名即可</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>在该列表中添加的文件必须是从未被追踪过的，否则git将继续追踪该文件</p>
</blockquote>
<ul>
<li><p><code>git rm</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git rm --cached 文件    <span class="comment">#让git停止追踪该文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git branch          <span class="comment">#显示分支列表</span></span><br><span class="line">git branch test     <span class="comment">#创建一个名为test的分支</span></span><br><span class="line">git checkout test   <span class="comment">#切换到test分支</span></span><br><span class="line">git merge test      <span class="comment">#将test分支添加到master</span></span><br><span class="line">git branch -d test  <span class="comment">#删除test分支，未添加的分支不可删除</span></span><br><span class="line">git branch -D test  <span class="comment">#强制删除test分支</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推到github</p>
<blockquote>
<p>首先去github创建一个新的仓库，并复制链接，假设为<code>https://.../abc.git</code> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git remote add origin https://.../abc.git       <span class="comment">#告诉git你在网上的仓库位置</span></span><br><span class="line">git push --set-upstream origin master           <span class="comment">#将master提交到github（需要输入用户名和密码）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发送合作邀请</p>
<blockquote>
<p>在github的仓库中<code>setting</code>–&gt;<code>Collaborators</code>–&gt;搜索用户–&gt;点击发送邀请至邮箱</p>
</blockquote>
</li>
<li><p>复制文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://.../abc.git   <span class="comment">#复制仓库至本地，`.gitignore`中的文件不会被下载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git pull<br>将github上更改过的文件下载到本地</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>终端指令</title>
    <url>/2019/08/29/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="some-tips"><a href="#some-tips" class="headerlink" title="some tips"></a>some tips</h2><ul>
<li><code>Tab</code> can auto compelete command</li>
<li><code>Ctrl+c</code> can stop the command or clear your input(终止命令或清空刚才的输入–命令较长时backspace太慢)</li>
</ul>
<a id="more"></a>

<h2 id="the-command-format"><a href="#the-command-format" class="headerlink" title="the command format"></a>the command format</h2><p><code>command [-options] [parameter]</code></p>
<h3 id="instructions"><a href="#instructions" class="headerlink" title="instructions"></a>instructions</h3><ul>
<li>command: command name</li>
<li>[-options]: control the command, it can be omited</li>
<li>[parameter]: maybe only one, or two, or three…</li>
<li>[]: means optional</li>
</ul>
<h2 id="basic-command"><a href="#basic-command" class="headerlink" title="basic command"></a>basic command</h2><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>list</td>
<td>view the contents of the current folder</td>
</tr>
<tr>
<td>pwd</td>
<td>print work directory</td>
<td>view current position</td>
</tr>
<tr>
<td>cd [directory]</td>
<td>change directory</td>
<td>move to the specified directory</td>
</tr>
<tr>
<td>touch [file name]</td>
<td>touch</td>
<td>create new file(s)</td>
</tr>
<tr>
<td>mkdir [directory]</td>
<td>make directory</td>
<td>create new directory</td>
</tr>
<tr>
<td>rm [file name]</td>
<td>remove</td>
<td>remove empty file(s)</td>
</tr>
<tr>
<td>clear</td>
<td>clear</td>
<td>clean the screen</td>
</tr>
</tbody></table>
<h2 id="view-help-information"><a href="#view-help-information" class="headerlink" title="view help information"></a>view help information</h2><ul>
<li><code>command --help</code></li>
<li><code>man command</code>(means manual)</li>
</ul>
<h2 id="files-and-directory-commands"><a href="#files-and-directory-commands" class="headerlink" title="files and directory commands"></a>files and directory commands</h2><ul>
<li>hidden files<blockquote>
<p>if the file begin with a dot <code>.</code> it is a hidden file</p>
</blockquote>
</li>
<li><code>.</code> and<code>..</code> <blockquote>
<p><code>.</code> means this level directory<br><code>..</code> means upper level directory</p>
</blockquote>
</li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><table>
<thead>
<tr>
<th>options</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>all</td>
<td>display all files(including hidden files)</td>
</tr>
<tr>
<td>-l</td>
<td>list</td>
<td>list display files (first letter is<code>d</code>:dir; <code>-</code>: file)</td>
</tr>
<tr>
<td>-h</td>
<td></td>
<td>display file size(Kb), it must be used with <code>-l</code> (ls -lh)</td>
</tr>
</tbody></table>
<ul>
<li><p>wildcard character(通配符)</p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>represents any number of characters(任意个数字符)</td>
</tr>
<tr>
<td>？</td>
<td>represents one character</td>
</tr>
<tr>
<td>[]</td>
<td>give some choices</td>
</tr>
</tbody></table>
</li>
<li><p>examples</p>
</li>
<li><ul>
<li><code>*</code> <blockquote>
<p><code>ls a*</code> display files begin with <code>a</code><br><code>ls *a.txt</code> display files end with <code>a.txt</code><br><code>ls *a*</code> display files contains <code>a</code> </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>** <code>?</code> </p>
<blockquote>
<p><code>ls ?a?.txt</code> display files like <code>1a1.txt</code> </p>
</blockquote>
<p>** <code>[]</code> </p>
<blockquote>
<p><code>ls [abcde]ab.txt</code> display files like <code>aab.txt</code> or<code>bab.txt</code> and so on<br><code>ls [a-f]ab.txt</code> display files begin with <code>abcdef</code> like <code>eab.txt</code></p>
</blockquote>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul>
<li><p>absolute path</p>
<blockquote>
<p>specific path from the root directory or home directory(从根目录或家目录开始的具体路径)<br>example:<code>/home/duguosheng/Desktop/</code> </p>
</blockquote>
</li>
<li><p>relative path</p>
<blockquote>
<p>the path from current directory</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>examples:<code>../Desktop/</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>go back to the current user home directory</td>
</tr>
<tr>
<td>cd ~</td>
<td>just like<code>cd</code></td>
</tr>
<tr>
<td>cd .</td>
<td>keep in the current directory</td>
</tr>
<tr>
<td>cd ..</td>
<td>go to the parent directory</td>
</tr>
<tr>
<td>cd -</td>
<td>switch back and forth between the last two directory</td>
</tr>
</tbody></table>
<h3 id="touch-file"><a href="#touch-file" class="headerlink" title="touch (file)"></a>touch (file)</h3><p>if the file doesn’t exist, the file will be created<br>otherwise, the last modification time of the file will be modified(否则会更改文件的末次修改时间)</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>create a new file</p>
<ul>
<li><code>mkdir -p a/b/c/d</code> <strong>recursively</strong> create directories(递归创建目录)<blockquote>
<p>the directory name can’t be same as <strong>existing file or directory</strong> </p>
</blockquote>
</li>
</ul>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul>
<li>delete file or directory (can not be restore)(不可恢复)</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>recursively delete directory(递归删除目录)</td>
</tr>
<tr>
<td>-f</td>
<td>forced deletion(强制删除)</td>
</tr>
</tbody></table>
<h2 id="copy-and-move-files-or-directories"><a href="#copy-and-move-files-or-directories" class="headerlink" title="copy and move files or directories"></a>copy and move files or directories</h2><h3 id="tree-directory"><a href="#tree-directory" class="headerlink" title="tree [directory]"></a>tree [directory]</h3><p>display directories and files in a tree view </p>
<ul>
<li><code>tree ~</code> display files form home directory</li>
<li><code>tree -d</code> only display directories</li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><ul>
<li><code>cp src dest</code> copy file<blockquote>
<p>example: <code>cp ~/Documents/test.txt .</code> copy test.txt to current directory,if you want to change file name, you can write<code>cp ~/a.txt ./b.txt</code> </p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>promat before overwritting files(覆盖文件前提示)</td>
</tr>
<tr>
<td>-r</td>
<td>copy directory</td>
</tr>
</tbody></table>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>move file or directory</p>
<p><strong>format</strong>: <code>mv src dest</code> </p>
<blockquote>
<p>example:<code>mv test ~/Documents/</code> move <em>test</em> to <em>Documents/</em> </p>
</blockquote>
<p><strong>change file or directory name</strong></p>
<blockquote>
<p>if <em>src</em> and <em>dest</em> are under the same directory, then it can be renamed</p>
</blockquote>
<p><strong>overwrite file</strong> </p>
<blockquote>
<p>if<code>test1.txt</code>and<code>test2</code>have been existed, then input <code>cp test1.txt test2.txt</code>, after that, <code>test1.txt</code> will be renamed as<code>test2.txt</code> and original file<code>test2.txt</code> will be deleted, <strong>this operation is unsafe</strong> </p>
</blockquote>
<p><code>cp -i src dest</code></p>
<blockquote>
<p>prompt before overwriting files</p>
</blockquote>
<h2 id="view-file-content"><a href="#view-file-content" class="headerlink" title="view file content"></a>view file content</h2><h3 id="cat-concatenate连接合并"><a href="#cat-concatenate连接合并" class="headerlink" title="cat(concatenate连接合并)"></a>cat(concatenate连接合并)</h3><p><strong>format</strong>: <code>cat (file)</code> </p>
<blockquote>
<p>view all content of the file </p>
</blockquote>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>show line number(except blank lines)</td>
</tr>
<tr>
<td>-n</td>
<td>show line number(including blank lines)</td>
</tr>
</tbody></table>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p><strong>format</strong>: <code>more (file)</code> </p>
<blockquote>
<p>view the beginning of the file</p>
</blockquote>
<table>
<thead>
<tr>
<th>operation</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td><space></space></td>
<td>display next page</td>
</tr>
<tr>
<td><enter></enter></td>
<td>display next row</td>
</tr>
<tr>
<td>b</td>
<td>go back</td>
</tr>
<tr>
<td>f</td>
<td>go forward</td>
</tr>
<tr>
<td>q</td>
<td>quit</td>
</tr>
</tbody></table>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>a text search tool(文本搜索工具)</p>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>show line number(行号)</td>
</tr>
<tr>
<td>-v</td>
<td>show lines which don’t match(不匹配的所有行)</td>
</tr>
<tr>
<td>-i</td>
<td>ignore case(忽略大小写)</td>
</tr>
</tbody></table>
<ul>
<li>example:<blockquote>
<p><code>grep as test.txt</code> look for the letter <strong>as</strong> in the <code>test.txt</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>grep -n as test.txt</code> look for the letter <strong>as</strong> in the <code>test.txt</code> and show the line number</p>
</blockquote>
<blockquote>
<p><code>grep -v as test.txt</code> look for lines that don’t contain the letter <strong>as</strong> in the <code>test.txt</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>param</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>^a</td>
<td>look for lines start with the letter <strong>a</strong></td>
</tr>
<tr>
<td>ke$</td>
<td>looke for lines end with <strong>ke</strong></td>
</tr>
</tbody></table>
<h2 id="other-command"><a href="#other-command" class="headerlink" title="other command"></a>other command</h2><h3 id="echo-some-words"><a href="#echo-some-words" class="headerlink" title="echo (some words)"></a>echo (some words)</h3><ul>
<li>the words will show in the terminal, it is always used with <strong>redirect command</strong></li>
<li><code>echo hello &gt; a</code> if <code>a</code> doesn’t exist, <code>a</code> will be created, and write <em>hello</em> inside file.(创建文件并指定内容)</li>
</ul>
<h3 id="redirect-gt-and-gt-gt"><a href="#redirect-gt-and-gt-gt" class="headerlink" title="redirect &gt;and&gt;&gt;"></a>redirect <code>&gt;</code>and<code>&gt;&gt;</code></h3><ul>
<li><p>linux allows to <strong>redirect command execution results to a file</strong>(linux允许将命令执行结果重定向到一个文件)</p>
</li>
<li><p><strong>output/append</strong> the content that should be displayed on the terminal to the specified file(将本应显示在终端的内容<strong>输出/追加</strong>到文件中)</p>
</li>
<li><p><code>&gt;</code>: output, overwrite the file</p>
</li>
<li><p><code>&gt;&gt;</code>: append, append content to the file</p>
</li>
<li><p>examples:</p>
<ul>
<li><code>echo helloworld &gt; a.txt</code></li>
<li><code>echo ls -lh &gt; a.txt</code> write the file list and their information to <code>a.txt</code> </li>
<li><code>echo goodbye &gt;&gt; a.txt</code></li>
</ul>
</li>
</ul>
<h3 id="pipe-管道"><a href="#pipe-管道" class="headerlink" title="pipe | (管道)"></a>pipe <code>|</code> (管道)</h3><ul>
<li><p>the output of a command can be input to another with pipe(一个命令的输出可以通过管道作为另一个命令的输入)</p>
</li>
<li><p><code>|</code> divides commands into left and right, left to write, right to read</p>
</li>
<li><p>common commands</p>
<ul>
<li><code>more</code>: spilt screen display content</li>
<li><code>grep</code>: search for the specified content in the command execution result(在命令执行结果中搜索指定内容)</li>
</ul>
</li>
<li><p>example:</p>
<ul>
<li><code>ls -lha ~ | more</code> spilt screen view files and directories</li>
<li><code>ls -lha ~ | grep aa</code> display files with letter <em>aa</em> in its name</li>
</ul>
</li>
</ul>
<hr>
<h2 id="shutdown-restart"><a href="#shutdown-restart" class="headerlink" title="shutdown/restart"></a>shutdown/restart</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><ul>
<li><code>shutdown</code> command can safely shut down or restart the system</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>restart</td>
</tr>
</tbody></table>
<blockquote>
<p>if the command has no options and parameters, it will turn off after 1 minute by default(默认一分钟后关机)<br>when remotely maintaining the serve, you’d better restart rather than shut down.</p>
</blockquote>
<ul>
<li>examples:<ul>
<li><code>shutdown -r now</code> –&gt;restart now</li>
<li><code>shut down now</code> –&gt;shut down now</li>
<li><code>shutdown 20:30</code> –&gt;shut down at 8:30pm</li>
<li><code>shutdown +10</code> –&gt;shut down 10 minutes later</li>
<li><code>shutdown -c</code> –&gt;cancel last command with shutdown</li>
</ul>
</li>
</ul>
<h2 id="view-and-configure-network-card-information-查看和配置网卡信息"><a href="#view-and-configure-network-card-information-查看和配置网卡信息" class="headerlink" title="view and configure network card information(查看和配置网卡信息)"></a>view and configure network card information(查看和配置网卡信息)</h2><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>configure a network interface</td>
<td>view/configure the network card information</td>
</tr>
<tr>
<td>ping (ip address)</td>
<td>ping</td>
<td>check the connection with target IP address is normal or not</td>
</tr>
</tbody></table>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul>
<li>in <strong>manjaro</strong>, use command <code>ip addr</code> instead of <code>ifconfig</code> </li>
<li>a computer may have <strong>a physical network card</strong> and <strong>multiple virtual network cards</strong> (一台计算机中可能有一个物理网卡和多个虚拟网卡)</li>
<li>view ip address: <code>ifconfig | grep inet</code> (<code>ip addr | grep inet</code> in mangaro )</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul>
<li><code>ping (IP)</code> ‘s working principle just like sonar(声纳), it sends out a packet, and the target IP addr returns a packet, the shorter the time, the faster the network speed(指令发出数据包，目标IP收到后返回一个数据包，这段时间越短，则网速越快)</li>
<li><code>ping (IP)</code> can check the target computer is open or not</li>
</ul>
<h2 id="Romote-login-and-copy-files-远程登录和复制文件"><a href="#Romote-login-and-copy-files-远程登录和复制文件" class="headerlink" title="Romote login and copy files(远程登录和复制文件)"></a>Romote login and copy files(远程登录和复制文件)</h2><h3 id="Basics-of-SSH"><a href="#Basics-of-SSH" class="headerlink" title="Basics of SSH"></a>Basics of <strong><em>SSH</em></strong></h3><ul>
<li>Based on the <strong>SSH Client</strong> and <strong>SSH Serve</strong> </li>
<li><strong>SSH Client</strong> is a software program connected to a remote computer with protocol <code>Secure Shell(SSH)</code> (SSH客户端是一种使用SSH协议连接到远程计算机的软件程序)</li>
<li>Transmitted data is<ul>
<li><strong>Encrypted(加密)</strong> –Prevent information from being leaked</li>
<li><strong>Compressed(压缩)</strong> –Increase transmission speed</li>
</ul>
</li>
</ul>
<h3 id="Port-number-端口号-and-Domain-name-域名"><a href="#Port-number-端口号-and-Domain-name-域名" class="headerlink" title="Port number(端口号) and Domain name(域名)"></a>Port number(端口号) and Domain name(域名)</h3><ul>
<li>Port number:<ul>
<li>IP address: just like <code>172.168.12.13</code> use it can <strong>find computer</strong> on internet</li>
<li>Port number: can <strong>find application</strong> running on the computer<ul>
<li><strong>SSH Client</strong> default port number is <code>22</code>, if it’s default port number, you can omit the port number when connecting(默认端口号连接时可以省略)</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>services</th>
<th>port number</th>
</tr>
</thead>
<tbody><tr>
<td>SSH Serve</td>
<td>22</td>
</tr>
<tr>
<td>Web Serve</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>FTP Serve</td>
<td>21</td>
</tr>
</tbody></table>
<ul>
<li>Domain name: just like <strong><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> , it use aliases for easy memory(使用别名，方便记忆)</li>
</ul>
<center>
<img src="portNum1.png" height="100" width="800" alt="notFound" title="command ping">
</center>

<blockquote>
<p>As shown in figure, <code>www.baidu.com</code> is <code>180.97.33.107</code> aliases, if you type <code>180.97.33.107</code> in the browser, also can visit <code>Baidu</code> </p>
</blockquote>
<blockquote>
<p>Also, you can input <code>180.97.33.107:80</code> to visit <code>Baidu</code>, IP addr<code>180.97.33.107</code> to find the computer, and port number <code>80</code> to find its application program (web serve)</p>
</blockquote>
<h3 id="SSH-Serve"><a href="#SSH-Serve" class="headerlink" title="SSH Serve"></a>SSH Serve</h3><ul>
<li>format:<code>ssh [-p port] user@romote</code> <ul>
<li><code>user</code> default current user</li>
<li><code>romote</code> IP addr, Alias Or Domain name of remote computer</li>
<li><code>port</code> the port of <strong>SSH Serve</strong> to listen, default<code>22</code> </li>
</ul>
</li>
<li>exp: <code>ssh -p 22 duguosheng@172.16.140.138</code> </li>
</ul>
<blockquote>
<p>Tips:</p>
<ul>
<li><code>exit</code>: Log out of the current user(退出当前账户登录)</li>
<li>Linux and Mac can use SSH without doing anything, but in Windows, you have to install some software for free<ul>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">Putty</a></li>
<li><a href="http://xshellcn.com" target="_blank" rel="noopener">XShell</a></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li><p><code>scp</code> is <code>secure copy</code>, it be used to <strong>remote copy file</strong> </p>
</li>
<li><p>example:</p>
<ul>
<li><p>If the path after<code>:</code> isn’t an absolute path, the user’s home directory is used as the reference path(<code>:</code> 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径)</p>
<blockquote>
<p>copy <code>01.py</code> from your local current directory to<code>Desktop/01.py</code> in your remote home directory(把本地当前目录下的 01.py 文件复制到远程家目录下的 Desktop/01.py)</p>
<blockquote>
<p><code>scp -P port 01.py user@remote:Desktop/01.py</code> <strong>P is capital(大写)</strong> </p>
<blockquote>
<p><code>scp -P 22 01.py duguosheng@172.16.139.122:Desktop/</code> &lt;++&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>copy <code>Desktop/01.py</code> from remote home directory to <code>01.py</code> in local current directory</p>
<blockquote>
<p><code>scp -P port user@remote:Desktop/01.py 01.py</code> </p>
</blockquote>
</blockquote>
</li>
<li><p>use <code>-r</code> can copy directory</p>
<blockquote>
<p><code>demo</code> under current local dir <strong>–&gt;</strong> remote <code>Desktop/</code></p>
<blockquote>
<p><code>scp -r demo user@remote:Desktop</code> </p>
<blockquote>
<p><code>scp -P 22 -r demo duguosheng@212.134.23.123:Desktop/</code> </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p><code>Desktop</code> under remote home dir <strong>–&gt;</strong> <code>demo/</code> in local current dir</p>
<blockquote>
<p><code>scp -r user user@remote:Desktop demo</code> </p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>Attention:</p>
<ul>
<li><code>scp</code> only can use in <code>linux</code> or <code>unix</code> </li>
<li>in <code>Windows</code>, you can install <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">Putty</a>, use <code>pscp</code> <strong>OR</strong> install <a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">FileZilla</a>, use <code>FTP</code> <ul>
<li><code>FTP</code> use <code>Ftp</code> instead of <code>Ssh</code>, so its port number is <code>21</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SSH-advanced"><a href="#SSH-advanced" class="headerlink" title="SSH advanced"></a>SSH advanced</h3><blockquote>
<p>All SSH ci=onfiguration information is stroed in the <code>/home/user/.ssh</code></p>
</blockquote>
<h4 id="Password-free-login-免密码登录"><a href="#Password-free-login-免密码登录" class="headerlink" title="Password free login(免密码登录)"></a>Password free login(免密码登录)</h4><ul>
<li><p>Steps:</p>
<ul>
<li><p>Configure the public key(配置公钥)</p>
<blockquote>
<p>Execute <code>ssh-keygen</code> to generate a public key(生成公钥), you can see <code>id_rsa</code>(private key) and <code>id_rsa.pub</code>(public key) under <code>~/.ssh/</code></p>
</blockquote>
</li>
<li><p>upload public key to Serve</p>
<blockquote>
<p>Execute <code>ssh-copy-id -p port user@remote</code> can let the Serve remember our pulic key, in fact, this command copy <code>id_rsa.pub</code> to Serve’s <code>~/.ssh/</code> </p>
</blockquote>
<p><img src="ssh1.png" alt="原理"></p>
</li>
</ul>
</li>
<li><p>Asymmetric encryption algorithm(非对称加密算法)</p>
<ul>
<li>Data encrypted using the public key needs to be decrypted using the private key(使用公钥加密的数据，需要使用私钥解密)</li>
<li>Data encrypted using the private key needs to be decrypted using the public key(使用私钥加密的数据，需要使用公钥解密)</li>
</ul>
</li>
</ul>
<h4 id="Configure-an-alias"><a href="#Configure-an-alias" class="headerlink" title="Configure an alias"></a>Configure an alias</h4><ul>
<li>Steps:<ul>
<li><code>cd ~/.ssh/</code> </li>
<li><code>touch config</code> </li>
<li><code>vi config</code> </li>
<li>edit <code>config</code> </li>
</ul>
</li>
<li>for example, <code>ssh -p 22 example@100.100.100.100</code> can be changed to <code>ssh exp</code> by edit <code>config</code> like this<br><img src="ssh3.png" alt="config"></li>
<li>Also, you can use <code>scp -r ~/Desktop exp:Desktop/demo</code> to copy a directory</li>
</ul>
<h2 id="Commands-about-User-Premissions-用户权限"><a href="#Commands-about-User-Premissions-用户权限" class="headerlink" title="Commands about User Premissions(用户权限)"></a>Commands about User Premissions(用户权限)</h2><h3 id="User-and-Premission"><a href="#User-and-Premission" class="headerlink" title="User and Premission"></a><strong><em>User</em></strong> and <strong><em>Premission</em></strong></h3><ul>
<li>In Linux, you can specify different permissions for different <strong>files or directories</strong> for each user</li>
<li>the permissions contains:</li>
</ul>
<table>
<thead>
<tr>
<th>permission</th>
<th>abbreviation</th>
<th>number</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>r</td>
<td>4</td>
</tr>
<tr>
<td>write</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>executive</td>
<td>x</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="ls-l-extended"><a href="#ls-l-extended" class="headerlink" title="ls -l extended"></a><code>ls -l</code> extended</h3><ul>
<li>execute <code>ls -lh</code> get some infomation like this<br><img src="user1.png" alt="result"> </li>
</ul>
<table>
<thead>
<tr>
<th><code>d</code>or<code>-</code></th>
<th>rwx</th>
<th>r-x</th>
<th>r–</th>
<th>2</th>
<th>duguosheng</th>
<th>duguosheng</th>
<th>4.0K</th>
<th>Aug 2 23:04</th>
<th>桌面/</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code> directory <code>-</code> file</td>
<td>user permission</td>
<td>group permission</td>
<td>other people permission</td>
<td>Number of hard links</td>
<td>user name</td>
<td>group name</td>
<td>size</td>
<td>last version time</td>
<td>file or directory name</td>
</tr>
</tbody></table>
<ul>
<li>Number of hard links(硬链接数)<blockquote>
<p>how many ways to access the current directory/file</p>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>if it is a file, the number is 1, through the path</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>if it is a directory without subdirectories(没有子目录), the number is 2, through the path or<code>cd .</code> </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>if it is a directory with n subdirectories(有n个子目录), the number is 2+n, through the path, <code>cd .</code> or <code>cd ..</code> </p>
</blockquote>
</blockquote>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul>
<li><code>chmod</code> can change permission of user/group</li>
<li>format: <code>chmod +/- rwx fileName/dirName</code> this usage will permission of both change user and group</li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><ul>
<li><code>su</code> is <code>substitute user</code>, default is <code>root</code> </li>
</ul>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><ul>
<li>To facilitate user management, you can group users and then assign permissions to groups(分组，为组分配权限)</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>groupadd (name)</td>
<td>add a group</td>
</tr>
<tr>
<td>groupdel (name)</td>
<td>delete a group</td>
</tr>
<tr>
<td>cat /etc/group</td>
<td>view group</td>
</tr>
<tr>
<td>chgrp -R (group_name) (dir)</td>
<td>change the group to which the dir belongs</td>
</tr>
</tbody></table>
<h3 id="User-management"><a href="#User-management" class="headerlink" title="User management"></a>User management</h3><h4 id="create-delete-user-And-change-password"><a href="#create-delete-user-And-change-password" class="headerlink" title="create/delete user And change password"></a>create/delete user And change password</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>tips</th>
</tr>
</thead>
<tbody><tr>
<td>useraddd -m -g (groupName) (userName)</td>
<td>add a user</td>
<td><code>-m</code> auto create home directory, <code>-g</code> specify user’s group, otherwise a group with the same name as the user will be created</td>
</tr>
<tr>
<td>passwd (user)</td>
<td>set user’s password</td>
<td>normal user can set set password by <code>passwd</code></td>
</tr>
<tr>
<td>userdel -r (user)</td>
<td>delete user</td>
<td><code>-r</code> will delete user’s home dir</td>
</tr>
</tbody></table>
<ul>
<li>if you foget to add <code>-m</code>, you can delete user and recreate it</li>
<li>the user information is stored in the <code>/etc/passwd</code> </li>
</ul>
<h4 id="view-user-information"><a href="#view-user-information" class="headerlink" title="view user information"></a>view user information</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>id (user)</td>
<td>view uid and gid</td>
</tr>
<tr>
<td>who</td>
<td>View a list of all currently logged in users(查看当前所有登录的用户列表)</td>
</tr>
<tr>
<td>whoami</td>
<td>view current user</td>
</tr>
</tbody></table>
<ul>
<li><code>id duguosheng</code> </li>
<li><code>cat -n /etc/passwd</code><br><img src="user2.png" alt="id"> </li>
<li><code>cat -n /etc/group</code> </li>
</ul>
<table>
<thead>
<tr>
<th>duguosheng</th>
<th>x</th>
<th>1000</th>
<th>1000</th>
<th>duguosheng</th>
<th>/home/duguosheng</th>
<th>/usr/bin/fish</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>encrypted password</td>
<td>user id</td>
<td>group id</td>
<td>group</td>
<td>home dir</td>
<td>shell</td>
</tr>
</tbody></table>
<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><ul>
<li><code>usermod</code> can be used to set the user’s primary/additional group and login shell(设置主组/附加组，和登录shell)</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>usermod -g (group) (user)</td>
<td>change user’s primary group</td>
</tr>
<tr>
<td>usermod -G (group) (user)</td>
<td>change user’s additional group</td>
</tr>
<tr>
<td>usermod -s /bin/bash (user)</td>
<td>change user’s shell</td>
</tr>
</tbody></table>
<ul>
<li>Users added by default with <code>useradd</code> do not have permission to use <strong>sudo</strong> to execute commands as <strong>root</strong>. Users can be added to sudo additional groups by using the following commands(默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中)<br><code>usermod -G sudo (user)</code> </li>
</ul>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p><code>which (command)</code> see the path of command</p>
<ul>
<li><code>which ls</code> <blockquote>
<p>result: <code>/bin/ls</code></p>
</blockquote>
</li>
<li><code>bin</code> and <code>sbin</code> </li>
</ul>
<p><img src="user4.png" alt="command_dir"> </p>
<h4 id="change-user"><a href="#change-user" class="headerlink" title="change user"></a>change user</h4><table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>su</td>
<td>change to root(not safe)</td>
</tr>
<tr>
<td>su (user)</td>
<td>change user</td>
</tr>
<tr>
<td>su - (user)</td>
<td>change user and go his home dir</td>
</tr>
<tr>
<td>exit</td>
<td>log out</td>
</tr>
</tbody></table>
<ul>
<li><p>Modify File Permissions(修改文件权限)</p>
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>chown (user) (file/dir)</td>
<td>change ower</td>
</tr>
<tr>
<td>chgrp -R (user) (file/dir)</td>
<td>change group</td>
</tr>
<tr>
<td>chmod -R 755 (file/dir)</td>
<td>change permission</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="user5.png" alt="permission"> </p>
<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>view system time</td>
</tr>
<tr>
<td>cal</td>
<td>view calendar</td>
</tr>
<tr>
<td>cal -y</td>
<td>view calendar of a year</td>
</tr>
</tbody></table>
<h3 id="disk-information-磁盘信息"><a href="#disk-information-磁盘信息" class="headerlink" title="disk information(磁盘信息)"></a>disk information(磁盘信息)</h3><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>df -h</td>
<td>disk free</td>
<td>show free space of disk(剩余空间)</td>
</tr>
<tr>
<td>du -h [dir]</td>
<td>disk usage</td>
<td>display the file size in the dir(目录下的文件大小)</td>
</tr>
</tbody></table>
<h3 id="process-information-进程信息"><a href="#process-information-进程信息" class="headerlink" title="process information(进程信息)"></a>process information(进程信息)</h3><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>ps (aux)</td>
<td>process status</td>
<td>view process</td>
</tr>
<tr>
<td>top</td>
<td></td>
<td>Display running processes dynamically and sort them(动态显示运行中的进程并且排序)</td>
</tr>
<tr>
<td>kill [-9] (process)</td>
<td></td>
<td><code>process</code> can be a name or its pid, stop the process, <code>-9</code> :force to stop</td>
</tr>
</tbody></table>
<ul>
<li>option of <code>ps</code> <ul>
<li><code>a</code> :Display all processes on the terminal, including those of other users(显示终端上的所有进程，包括其他用户的进程)</li>
<li><code>u</code> :display details of process</li>
<li><code>x</code> :Display processes without control terminals(显示没有控制终端的进程)</li>
</ul>
</li>
</ul>
<h2 id="Other-command"><a href="#Other-command" class="headerlink" title="Other command"></a>Other command</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li>format: <code>find [path] -name &quot;*.png&quot;</code> <blockquote>
<p>if no path, default in current directory</p>
</blockquote>
</li>
</ul>
<h3 id="Softlink-软链接"><a href="#Softlink-软链接" class="headerlink" title="Softlink(软链接)"></a>Softlink(软链接)</h3><ul>
<li>format: <code>ln -s src destfile</code> use absolute path, don’t use relative path</li>
</ul>
<h3 id="Hardlink-硬链接"><a href="#Hardlink-硬链接" class="headerlink" title="Hardlink(硬链接)"></a>Hardlink(硬链接)</h3><ul>
<li>format: <code>ln src destfile</code><br><img src="user6.png" alt="hardlink"> </li>
</ul>
<h3 id="Packing-and-Compression-打包压缩"><a href="#Packing-and-Compression-打包压缩" class="headerlink" title="Packing and Compression(打包压缩)"></a>Packing and Compression(打包压缩)</h3><h4 id="Pack-unpack-打包-解包"><a href="#Pack-unpack-打包-解包" class="headerlink" title="Pack/unpack(打包/解包)"></a>Pack/unpack(打包/解包)</h4><ul>
<li><p>different OS has different mode of pack and compression</p>
<ul>
<li><code>windows</code> : <code>rar</code> </li>
<li><code>mac</code> : <code>zip</code> </li>
<li><code>linux</code> : <code>tar</code>  </li>
</ul>
</li>
<li><p><code>tar</code> can pack a series of files into a large file or restore a packaged large file into a series of files(此命令可以把一系列文件打包到 一个大文件中，也可以把一个打包的大文件恢复成一系列文件)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>tar -cvf 打包文件.tar 被打包文件/路径…</td>
<td>pack</td>
</tr>
<tr>
<td>tar -xvf 打包文件.tar</td>
<td>unpack</td>
</tr>
</tbody></table>
<ul>
<li>options of tar</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>x</td>
<td>解开档案文件</td>
</tr>
<tr>
<td>v</td>
<td>列出详细过程，显示进度</td>
</tr>
<tr>
<td>f</td>
<td>指定档案文件，f后面一定是.tar文件，所以必须放选项最后</td>
</tr>
</tbody></table>
<blockquote>
<p>attention: </p>
<blockquote>
<p><code>f</code> 必须放在选项最后，其他随意<br><code>tar</code> 只负责打包，不负责压缩</p>
</blockquote>
</blockquote>
<h4 id="compression-decompression-压缩-解压"><a href="#compression-decompression-压缩-解压" class="headerlink" title="compression/decompression(压缩/解压)"></a>compression/decompression(压缩/解压)</h4><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><ul>
<li><code>tar</code> 与<code>gzip</code> 结合可实现打包压缩</li>
<li>用<code>gzip</code> 压缩<code>tar</code> 打包后的文件，扩展名一般用<code>xxx.tar.gz</code> </li>
<li>在<code>tar</code> 命令中，有一个<code>-z</code> 选项可以调用<code>gzip</code> </li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径,该指定路径必须已存在</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 指定路径</span><br></pre></td></tr></table></figure>

<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><ul>
<li><code>tar</code> 与<code>bzip2</code> 结合可实现打包压缩</li>
<li>用<code>bzip2</code> 压缩<code>tar</code> 打包后的文件，扩展名一般用<code>xxx.tar.bz2</code> </li>
<li>在<code>tar</code> 命令中，有一个<code>-j</code> 选项可以调用<code>bzip2</code> </li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径,该指定路径必须已存在</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2 -C 指定路径</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>archlinux包管理工具pacman</title>
    <url>/2019/08/29/archlinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pacman/</url>
    <content><![CDATA[<p>pacman的基本命令分为三大类S,R,Q</p>
<a id="more"></a>

<h4 id="command-with-S-means-synchronized-lt-同步的-gt"><a href="#command-with-S-means-synchronized-lt-同步的-gt" class="headerlink" title="command with S (means synchronized&lt;同步的&gt;)"></a>command with <strong><code>S</code></strong> (means synchronized&lt;同步的&gt;)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -S (some apps)</td>
<td>install software</td>
<td>sudo pacman -S vlc</td>
</tr>
<tr>
<td>sudo pacman -Sy</td>
<td>only synchronize source(仅同步源)</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syy</td>
<td>force to refresh for updates(强制刷新一遍更新信息)</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Su</td>
<td>update the system</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syu</td>
<td>synchronize source and update</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syyu</td>
<td>force to refresh imformation for updates and update system</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Ss (some apps)</td>
<td>search for the software from internet</td>
<td>sudo pacman -Ss vim</td>
</tr>
<tr>
<td>sudo pacman -Sc</td>
<td>delete software installation packages</td>
<td></td>
</tr>
</tbody></table>
<h4 id="command-with-R-means-remove"><a href="#command-with-R-means-remove" class="headerlink" title="command with R (means remove)"></a>command with <code>R</code> (means remove)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -R (app)</td>
<td>delete the software</td>
<td>sudo pacman -R vim</td>
</tr>
<tr>
<td>sudo pacman -Rs (app)</td>
<td>delete the software and the packages it rely on(删除软件及其依赖的包)</td>
<td>sudo pacman -Rs vim</td>
</tr>
<tr>
<td>*sudo pacman -Rns (app)</td>
<td>delete software, packages, and global profile</td>
<td>sudo pacman -Rns vim</td>
</tr>
</tbody></table>
<h4 id="command-with-Q-means-query-lt-查询-gt"><a href="#command-with-Q-means-query-lt-查询-gt" class="headerlink" title="command with Q (means query&lt;查询&gt;)"></a>command with <strong><code>Q</code></strong> (means query&lt;查询&gt;)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -Q</td>
<td>list all softwares be installed</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qe</td>
<td>list the software have been installed by user</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Q &#124; wc -l</td>
<td>show total number of softwares</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qe &#124; wc -l</td>
<td>show number of personal softwares</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qeq</td>
<td>list pesonal softwares without version</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qs (app)</td>
<td>query the softwares which contains letters</td>
<td>sudo pacman -Qs vim</td>
</tr>
<tr>
<td>sudo pacman -Qdt</td>
<td>query unrequired packages</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qdtq</td>
<td>query unrequired packages(不需要的包)</td>
<td></td>
</tr>
</tbody></table>
<h4 id="combination-commands"><a href="#combination-commands" class="headerlink" title="combination commands"></a>combination commands</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -R $(pacman -Qdtq)</td>
<td>delete unrequired packages</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pacman</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>终端下文件管理器Ranger使用</title>
    <url>/2019/08/28/%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8Ranger%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="选择-打开文件"><a href="#选择-打开文件" class="headerlink" title="选择/打开文件"></a>选择/打开文件</h2><a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code>或<code>h</code></td>
<td>上一级</td>
</tr>
<tr>
<td><code>right</code>或<code>l</code></td>
<td>下一级/打开文件</td>
</tr>
<tr>
<td><code>up</code>或<code>k</code></td>
<td>上一个</td>
</tr>
<tr>
<td><code>down</code>或<code>j</code></td>
<td>下一个</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>最上方</td>
</tr>
<tr>
<td><code>G</code></td>
<td>最下方</td>
</tr>
<tr>
<td><code>r</code></td>
<td>选择打开方式</td>
</tr>
<tr>
<td><code>[</code></td>
<td>移动至上一个父文件夹</td>
</tr>
<tr>
<td><code>]</code></td>
<td>移动至下一个父文件夹</td>
</tr>
<tr>
<td><code>H</code></td>
<td>退回上一个位置</td>
</tr>
<tr>
<td><code>L</code></td>
<td>撤销退回</td>
</tr>
<tr>
<td><code>&lt;Space&gt;</code></td>
<td>选择该文件，可多选</td>
</tr>
<tr>
<td><code>v</code></td>
<td>反转选择</td>
</tr>
<tr>
<td><code>V</code></td>
<td>进入可视模式，结合移动键进行选择</td>
</tr>
</tbody></table>
<ul>
<li><p>打开文件默认使用<code>nano</code>或者<code>gedit</code>，如果想要修改，</p>
</li>
<li><p>查看默认编辑器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $EDITOR</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认编辑器(如改为vim)</p>
<blockquote>
<p>如果使用<code>bash</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export EDITOR="/usr/bin/vim"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>fish</code> </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set -g -x EDITOR "/usr/bin/vim"</span><br></pre></td></tr></table></figure>

<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>y</code></td>
<td>按照提示选择复制的内容，如文件，文件路径等</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>复制一个文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>按照提示招贴</td>
</tr>
<tr>
<td><code>pp</code></td>
<td>复制刚才粘贴的，不覆盖</td>
</tr>
<tr>
<td><code>po</code></td>
<td>复制并覆盖重名文件</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>剪切</td>
</tr>
<tr>
<td><code>dD</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>dU</code></td>
<td>查看文件大小</td>
</tr>
</tbody></table>
<ul>
<li>复制一个很大的文件进行粘贴时，可使用<code>w</code>进入<strong>进度管理</strong></li>
<li>在<strong>进度管理</strong>中，<code>dd</code>取消当前任务</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>/搜索内容</code></td>
<td>查找文件,<code>n</code>下一个,<code>N</code>上一个</td>
</tr>
<tr>
<td><code>f 搜索内容</code></td>
<td>查找文件，并直接指向该文件</td>
</tr>
<tr>
<td><code>zh</code> / <code>&lt;BackSpace&gt;</code> / <code>&lt;C-h&gt;</code></td>
<td>显示/隐藏隐藏文件</td>
</tr>
<tr>
<td><code>cw</code> / <code>a</code> / <code>i</code> / <code>A</code> / <code>I</code></td>
<td>重命名文件</td>
</tr>
<tr>
<td><code>o</code></td>
<td>按照提示选择排序方式</td>
</tr>
</tbody></table>
<h2 id="生成Ranger配置文件"><a href="#生成Ranger配置文件" class="headerlink" title="生成Ranger配置文件"></a>生成Ranger配置文件</h2><ul>
<li>在终端下执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ranger --copy-config=all</span><br></pre></td></tr></table></figure>

<p>就会在<code>.config/ranger/</code>下看到相关配置文件，更多配置信息可以去<a href="https://github.com/ranger/ranger/wiki" target="_blank" rel="noopener">ranger的github下的wiki栏目</a>下查看</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
</search>
