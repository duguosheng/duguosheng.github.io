<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单工厂模式</title>
    <url>/2020/03/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<p>面向对象的三大特性：<strong>封装，继承和多态</strong></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>一般来说，工厂模式需要三个类</li>
</ul>
<ol>
<li>抽象产品类：简单工厂模式中所有对象的父类，负责描述接口</li>
<li>具体产品类：继承自抽象产品类，是简单工厂模式的创建目标</li>
<li>工厂类：简单工厂模式的核心，负责判断到底需要实例化谁</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>假设需要设计一个执行两个数字简单四则运算的程序</p>
<h3 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h3><p>抽象出该程序中公共的内容：两个数字，及其<code>get</code>，<code>set</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运算基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> num1;</span><br><span class="line">    <span class="keyword">double</span> num2;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetNum1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetNum1</span><span class="params">(<span class="keyword">double</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetNum2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetNum2</span><span class="params">(<span class="keyword">double</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Operation() &#123; <span class="built_in">printf</span>(<span class="string">"del opera\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法的实现</span></span><br><span class="line"><span class="keyword">double</span> Operation::GetNum1() &#123; <span class="keyword">return</span> num1; &#125;</span><br><span class="line"><span class="keyword">void</span> Operation::SetNum1(<span class="keyword">double</span> num) &#123; num1 = num; &#125;</span><br><span class="line"><span class="keyword">double</span> Operation::GetNum2() &#123; <span class="keyword">return</span> num2; &#125;</span><br><span class="line"><span class="keyword">void</span> Operation::SetNum2(<span class="keyword">double</span> num) &#123; num2 = num; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h3><p>接下来写出每个运算的具体类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>;</span><br><span class="line">    ~Add() &#123; <span class="built_in">printf</span>(<span class="string">"deladd\n"</span>); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>;</span><br><span class="line">    ~Sub() &#123; <span class="built_in">printf</span>(<span class="string">"delsub\n"</span>); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>;</span><br><span class="line">    ~Mul() &#123; <span class="built_in">printf</span>(<span class="string">"delmul\n"</span>); &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span></span>;</span><br><span class="line">    ~Div() &#123; <span class="built_in">printf</span>(<span class="string">"deldiv\n"</span>); &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> Add::GetResult() &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line"><span class="keyword">double</span> Sub::GetResult() &#123; <span class="keyword">return</span> num1 - num2; &#125;</span><br><span class="line"><span class="keyword">double</span> Mul::GetResult() &#123; <span class="keyword">return</span> num1 * num2; &#125;</span><br><span class="line"><span class="keyword">double</span> Div::GetResult() &#123;</span><br><span class="line">    <span class="keyword">if</span> (num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"除数不能为0"</span>;</span><br><span class="line">    <span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h3><p>这个类用于判断什么时候实例出哪一个类的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运算简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//提供静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Operation* <span class="title">CreateOperation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* opearte)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Operation* OperationFactory::CreateOperation(<span class="keyword">const</span> <span class="keyword">char</span>* opearte) &#123;</span><br><span class="line">    Operation* oper = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(opearte, <span class="string">"+"</span>) == <span class="number">0</span>)</span><br><span class="line">        oper = <span class="keyword">new</span> Add;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(opearte, <span class="string">"-"</span>) == <span class="number">0</span>)</span><br><span class="line">        oper = <span class="keyword">new</span> Sub;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(opearte, <span class="string">"*"</span>) == <span class="number">0</span>)</span><br><span class="line">        oper = <span class="keyword">new</span> Mul;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(opearte, <span class="string">"/"</span>) == <span class="number">0</span>)</span><br><span class="line">        oper = <span class="keyword">new</span> Div;</span><br><span class="line">    <span class="keyword">return</span> oper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由工厂类来判断到底需要创建什么对象</span></span><br><span class="line">    Operation* oper = OperationFactory::CreateOperation(<span class="string">"+"</span>);</span><br><span class="line">    oper-&gt;SetNum1(<span class="number">10</span>);</span><br><span class="line">    oper-&gt;SetNum2(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"res=%lf"</span>, oper-&gt;GetResult());</span><br><span class="line">    <span class="comment">//析构</span></span><br><span class="line">    <span class="keyword">delete</span> oper;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res=30.000000</span><br><span class="line">deladd</span><br><span class="line">del opera</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用简单工厂模式后，更为方便扩展，当需要添加新的运算如次方根等时，需要</p>
<ul>
<li>添加相应的运算子类</li>
<li>在工厂类中添加新的判断分支<br>而不需要影响整个代码</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++抽象类子类实例化的析构</title>
    <url>/2020/03/06/C-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<p>在C++使用抽象类时会面临一个问题，根据其派生类实例出来的对象，如何释放内存，需要用道虚析构，C++将从最底层依次向上调用析构函数</p>
<a id="more"></a>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>定义类<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义一个虚析构函数，但不能为纯虚函数</span></span><br><span class="line">    <span class="comment">//如果没有visual将不会调用子类的析构</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Animal() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"del animal"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"猫步轻悄"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~Cat() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"del cat"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>抽象类的析构前要加’virtual’，否则不会调用子类的析构</p>
</blockquote>
<ul>
<li><p>实例化演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal *ani = <span class="keyword">new</span> Cat;</span><br><span class="line">    ani-&gt;Run();</span><br><span class="line">    <span class="keyword">delete</span> ani;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">猫步轻悄</span><br><span class="line">del cat</span><br><span class="line">del animal</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>虚析构</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的序列生成器</title>
    <url>/2020/02/26/Oracle%E7%9A%84%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E5%99%A8-1/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>Oracle的序列生成器</title>
    <url>/2020/02/26/Oracle%E7%9A%84%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>
<p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。不占用磁盘空间，占用内存。其可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>
<ul>
<li>创建序列生成器</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> SEQ _SURFDATA <span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">100</span> MAXVALUE <span class="number">9999999999</span> <span class="keyword">NOCYCLE</span> NOCACHE;</span><br></pre></td></tr></table></figure>

<p>语法详解：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建序列命令</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> 序列名</span><br><span class="line"><span class="comment">--定义序列的步长（增长量），如果省略，则默认为1</span></span><br><span class="line"><span class="comment">--如果出现负值，则代表序列的值是按照此步长递减的。</span></span><br><span class="line">[<span class="keyword">INCREMENT</span> <span class="keyword">BY</span> n]</span><br><span class="line"><span class="comment">--定义序列的初始值(即产生的第一个值)，默认为1</span></span><br><span class="line">[<span class="keyword">START</span> <span class="keyword">WITH</span> n]</span><br><span class="line"><span class="comment">--定义序列生成器能产生的最大值</span></span><br><span class="line"><span class="comment">--选项NOMAXVALUE是默认选项，代表没有最大值定义</span></span><br><span class="line"><span class="comment">--这时对于递增序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。</span></span><br><span class="line"><span class="comment">--MINVALUE 定义序列生成器能产生的最小值</span></span><br><span class="line"><span class="comment">--选项NOMAXVALUE是默认选项，代表没有最小值定义</span></span><br><span class="line"><span class="comment">--这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。</span></span><br><span class="line">[&#123;MAXVALUE/<span class="keyword">MINVALUE</span> n|<span class="keyword">NOMAXVALUE</span>&#125;] <span class="comment">--3、</span></span><br><span class="line"><span class="comment">--CYCLE 和 NOCYCLE 表示当序列生成器的值达到限制值后是否循环</span></span><br><span class="line"><span class="comment">--CYCLE代表循环，NOCYCLE代表不循环。</span></span><br><span class="line">[&#123;<span class="keyword">CYCLE</span>|<span class="keyword">NOCYCLE</span>&#125;]</span><br><span class="line"><span class="comment">--CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。</span></span><br><span class="line"><span class="comment">--对序列进行内存缓冲，可以改善序列的性能</span></span><br><span class="line">[&#123;<span class="keyword">CACHE</span> n|NOCACHE&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除序列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">SEQUENCE</span> 序列名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取序列的当前值和下一个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--获取序列的当前值</span></span><br><span class="line"><span class="keyword">SELECT</span> 序列名.CURRVAL <span class="keyword">FROM</span> dual;</span><br><span class="line"><span class="comment">--获取序列的下一个值</span></span><br><span class="line"><span class="keyword">SELECT</span> abc.NEXTVAL <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>序列生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的虚表dual及伪列</title>
    <url>/2020/02/26/Oracle%E7%9A%84%E8%99%9A%E8%A1%A8dual/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="虚表dual"><a href="#虚表dual" class="headerlink" title="虚表dual"></a>虚表dual</h2><p>dual是一个虚拟表，用来构成select的语法规则，oracle保证dual里面永远只有一条记录。我们可以用它来做很多事情，如下：</p>
<ul>
<li>查看当前用户，可以在 SQL Plus中执行下面语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<ul>
<li>用来调用系统函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--获得当前系统时间</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--获得主机名</span></span><br><span class="line"><span class="keyword">select</span> SYS_CONTEXT(<span class="string">'USERENV'</span>,<span class="string">'TERMINAL'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--获得当前 locale</span></span><br><span class="line"><span class="keyword">select</span> SYS_CONTEXT(<span class="string">'USERENV'</span>,<span class="string">'language'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--获得一个随机数</span></span><br><span class="line"><span class="keyword">select</span> dbms_random.random <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>3、得到序列的下一个值或当前值，用下面语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--获得序列your_sequence的下一个值</span></span><br><span class="line"><span class="keyword">select</span> your_sequence.nextval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--获得序列your_sequence的当前值</span></span><br><span class="line"><span class="keyword">select</span> your_sequence.currval <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>4、可以用做计算器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">7</span>*<span class="number">9</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C语言取的是操作系统的时间<br>Oracle运行数据库的服务器的操作系统的时间</p>
</blockquote>
<h2 id="伪列"><a href="#伪列" class="headerlink" title="伪列"></a>伪列</h2><p>Oracle 中伪列就像一个表列（表中的列），但是它并没有存储在表中，伪列可以从表中查询，但不能插入、更新和删除它们的值<br>常用的伪列有ROWID和ROWNUM。</p>
<ul>
<li><p>ROWNUM 是查询返回的结果集中行的序号，可以使用它来限制查询返回的行数。</p>
</li>
<li><p>rowid格式<br>ROWID是数据的详细地址，通过rowid，oracle可以快速的定位某行具体的数据在磁盘中存放的物理位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询rowid</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rowid</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>查到的格式如<code>AAASP3AAEAAAACvABj</code><br>第一部分6位表示：该行数据所在的数据对象的编号；<br>第二部分3位表示：该行数据所在的相对数据文件的id;<br>第三部分6位表示：该数据行所在的数据块的编号；<br>第四部分3位表示：该行数据的行的编号；</p>
<blockquote>
<p>使用rowid可以快速查询定位文件，效率很高</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="keyword">rowid</span>=<span class="string">'AAASP3AAEAAAACvABj'</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>dual</tag>
      </tags>
  </entry>
  <entry>
    <title>error while loading shared libraries: libclntsh.so.11.1: cannot open shared object file: No such file or directory问题解决</title>
    <url>/2020/02/20/error-while-loading-shared-libraries-libclntsh-so-11-1-cannot-open-shared-object-file-No-such-file-or-directory%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/red10057/article/details/8202255" target="_blank" rel="noopener">参考文章, 点击跳转</a></p>
<ul>
<li><p>首先检查文件是否存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入oracle家目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$ORACLE_HOME</span>/lib</span><br><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line">ls -l |grep libclntsh.so</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/etc/ld.so.conf添加$ORACLE_HOME/lib路径</span></span><br><span class="line">sudo vi /etc/ld.so.conf</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"># 在第一行下填写lib路径，使用绝对路径</span><br><span class="line">/u01/oracle/product/11.2.0/db_1/lib/</span><br></pre></td></tr></table></figure>

<p>冒号wq保存退出</p>
<ul>
<li>重新ldconfig<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7服务器上部署oracle11g-静默安装</title>
    <url>/2020/02/20/CentOS7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2oracle11g-%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<a id="more"></a>
<p>搜索了B站centos7上部署oracle，结果需要图形化界面，又找了很多文章，跟着下面的这篇文章终于部署成功了</p>
<p><strong>静默安装，无需图形界面</strong></p>
<p><a href="https://yq.aliyun.com/articles/667322" target="_blank" rel="noopener noreferrer">原文章跳转</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle中的表及其相关操作</title>
    <url>/2020/02/20/oracle%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="表的概念"><a href="#表的概念" class="headerlink" title="表的概念"></a>表的概念</h2><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p>表是数据库的最基本的逻辑结构，一切数据都存放在表中，其它数据库对象（索引、视图、同义词等）都是为了用户很好地操作表中的数据，一个ORACLE数据库就是由若干个数据表组成，每个表由列和行组成，如下表所示。</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>籍贯</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>张三</td>
<td>男</td>
<td>北京</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>男</td>
<td>上海</td>
</tr>
</tbody></table>
<h3 id="表的组成"><a href="#表的组成" class="headerlink" title="表的组成"></a>表的组成</h3><blockquote>
<p>表是由列或字段组成，表的内容，也就是表的各个属性，组成了表的各个列。</p>
</blockquote>
<ul>
<li>表结构</li>
</ul>
<ol>
<li>列名：列的名称。</li>
<li>长度：该列所能容纳的最大数据位数。</li>
<li>数据类型：该列存储的数据类型，常用数据类型如所示。</li>
<li>非空列：该列值是不能为空的。</li>
<li>主键：该列能唯一表示一行内容，则称该列为关键字。识别码，唯一的ID。</li>
</ol>
<h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
<th>最大长度</th>
<th>表示方法</th>
</tr>
</thead>
<tbody><tr>
<td>char(长度)</td>
<td>定长字符串</td>
<td>255</td>
<td>单引号括起来，如’张三’</td>
</tr>
<tr>
<td>varchar2(长度)</td>
<td>变长字符串</td>
<td>2000</td>
<td>同上</td>
</tr>
<tr>
<td>number(长度,精度)</td>
<td>数字</td>
<td>38</td>
<td>可以括起来，也可以不括，如12.3或’12.3’</td>
</tr>
<tr>
<td>date</td>
<td>日期时间，实际是一个整数</td>
<td></td>
<td>用<code>to_date</code>和<code>to_char</code>把字符串和日期进行转换</td>
</tr>
</tbody></table>
<p><code>to_date</code>使用：如<code>to_date(&#39;2020-01-01 20:00:00&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)</code>将字符串转换为<code>date</code>类型</p>
<p><code>to_char</code>使用：假设<code>birthday</code>是表中的一个<code>date</code>数据类型，使用<code>to_char(birthday,&#39;yyyy-mm-dd hh24:mi:ss&#39;)</code>将<code>date</code>类型转换为<code>yyyy-mm-dd hh24:mi:ss</code>格式的字符串</p>
<p><strong>行/记录</strong>：表中所有列组合在一起形成的一条信息，称之为一行或一条记录。</p>
<hr>
<h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><blockquote>
<p>sql命令不区分大小写<br>sql中使用两个短横线作为注释符号，如</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--这是一段注释</span></span><br></pre></td></tr></table></figure>

<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul>
<li><p>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line">	(</span><br><span class="line">	<span class="comment">--每个参数间以逗号结束</span></span><br><span class="line">	<span class="comment">--变量名 数据类型</span></span><br><span class="line">	column1 datatype,</span><br><span class="line">	<span class="comment">--null表示可以空，为默认值，可不填</span></span><br><span class="line">	column2 datatype <span class="literal">null</span>,</span><br><span class="line">	<span class="comment">--not null表示该项必须非空</span></span><br><span class="line">	column3 datatype <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	……,</span><br><span class="line">	<span class="comment">--最后一行没有逗号</span></span><br><span class="line">	<span class="comment">--指定id为主键</span></span><br><span class="line">	primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
</li>
<li><p>建表举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T_GIRL</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">char</span>(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">name</span> varchar2(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gender <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">    hometown varchar2(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="表记录的插入"><a href="#表记录的插入" class="headerlink" title="表记录的插入"></a>表记录的插入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--第一种写法,前后的值要一一对应</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename(col1,col2,col3,……,coln) <span class="keyword">values</span>(value1,value2,value3,……,valuen);</span><br><span class="line"><span class="comment">--还有一种写法。</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename <span class="keyword">values</span>(value1,value2,value3,……,valuen);<span class="comment">--value的顺序为建表时指定的顺序</span></span><br></pre></td></tr></table></figure>

<p>后面的写法一定不能出现在程序中，因为只要表结构发生改变，或字段的位置改变，SQL就会出错。</p>
<h3 id="查询表中数据"><a href="#查询表中数据" class="headerlink" title="查询表中数据"></a>查询表中数据</h3><ul>
<li>查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--常用语法</span></span><br><span class="line"><span class="keyword">select</span> col1,col2,col3 <span class="keyword">from</span> tablename <span class="keyword">where</span> ...; <span class="comment">--where后接条件语句</span></span><br><span class="line"><span class="comment">--查询法和条件的所有内容</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tablename <span class="keyword">where</span> ...;</span><br><span class="line"><span class="comment">--查询系统时间</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--查询表的结构</span></span><br><span class="line">desc tablename;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>条件判断</strong>:<code>=</code>相等, <code>!=</code>不相等, <code>and</code>与, <code>or</code>或</p>
<ul>
<li>排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--在上面的语句后接</span></span><br><span class="line">order by A; <span class="comment">--查询后根据A元素升序排序</span></span><br><span class="line">order by A,B; <span class="comment">--查询后先根据A升序,再根据B元素升序排序</span></span><br><span class="line">order by A asc; <span class="comment">--asc表示升序,为默认值,可省略</span></span><br><span class="line">order by A desc; <span class="comment">--desc是降序</span></span><br><span class="line">order by A,B desc; <span class="comment">--先根据A升序,再根据B降序排列</span></span><br><span class="line">order by A desc, B desc; <span class="comment">--现根据A降序,再根据B降序排</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改表中的数据"><a href="#修改表中的数据" class="headerlink" title="修改表中的数据"></a>修改表中的数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> col1=value1,col2=value2,……,coln=valuen <span class="keyword">where</span> 条件表达式;</span><br></pre></td></tr></table></figure>

<p>如果没有条件表达式，就更新表中全部的数据。</p>
<h3 id="删除表中的数据"><a href="#删除表中的数据" class="headerlink" title="删除表中的数据"></a>删除表中的数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> 条件表达式;</span><br></pre></td></tr></table></figure>

<p>如果没有条件表达式，就删除表中全部的数据。</p>
<h2 id="sqlplus技巧"><a href="#sqlplus技巧" class="headerlink" title="sqlplus技巧"></a>sqlplus技巧</h2><p>在sqlplus登录后,执行sql语句,可以用<code>/</code>重复上一条命令,<code>l</code>显示出来上一条语句,<code>c/old/new</code>来将上一条命令中的<code>old</code>改为<code>new</code></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle的事务及与删除操作的关联</title>
    <url>/2020/02/20/oracle%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%8F%8A%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E8%81%94/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="oracle的事务"><a href="#oracle的事务" class="headerlink" title="oracle的事务"></a>oracle的事务</h2><h3 id="对数据库中事务的理解"><a href="#对数据库中事务的理解" class="headerlink" title="对数据库中事务的理解"></a>对数据库中事务的理解</h3><p>在数据库中事务是工作的逻辑任务，一个事务是由一个或多个SQL语句组成，通过事务机制确保这一组SQL语句所作的操作要么全部成功执行，完成整个工作任务，要么一个也不执行，对数据表所做的操作全部撤销。</p>
<p>例如<strong>银行转账</strong></p>
<ul>
<li>A用户帐户余额减少1000元；</li>
<li>B用户帐户余额增加1000元；</li>
<li>记录A用户的交易日志。</li>
<li>记录B用户的交易日志。</li>
</ul>
<p>一次交易产生四次数据库操作，要么全部都成功，如果有一个失败，其它操作也应该全部被撤销。</p>
<h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<h2 id="删除操作与事务的关联"><a href="#删除操作与事务的关联" class="headerlink" title="删除操作与事务的关联"></a>删除操作与事务的关联</h2><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除表中数据有以下两种方式：</p>
<ul>
<li>delete<br>删除数据时，数据库需要写日志，ORACLE数据库还需要占用回滚段，每次事务越大，对数据库的冲击越大，所以在删除或者更新数据时，一定要注意控制事务的大小，避免产生大事务。如：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename <span class="keyword">where</span>  ……;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>用delete删除数据时，只删除数据，但不释放空间，并且产生碎片。</p>
<ul>
<li>truncate<br>删除表中所有数据，并回收存储空间，truncate不产生事务。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> tablename;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>删除表命令为drop，利用 drop命令删除表将删除表中全部的数据。不产生事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语言概述</title>
    <url>/2020/02/20/sql%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>主要由<code>select</code>关键字完成，查询语句是SQL 语句中最复杂、功能最丰富的语句。</p>
<h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><p>Data Manipulation Language，数据操作语言<br>主要由<code>insert</code>、<code>update</code>和<code>delete</code>三个关键字完成。</p>
<h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>Data Definition Language，数据定义语言<br>主要由<code>create</code>、<code>alter</code>、<code>drop</code>和<code>truncate</code>四个关键字完成。</p>
<ul>
<li>ALTER用法</li>
</ul>
<ol>
<li><p>如需在表中添加列，请使用下列语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype</span><br></pre></td></tr></table></figure>
</li>
<li><p>要删除表中的列，请使用下列语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注释：某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN column_name)。</p>
<ol start="3">
<li>要改变表中列的数据类型，请使用下列语法：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name datatype</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">MODIFY</span> column_name datatype</span><br></pre></td></tr></table></figure>

<h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><p>Data Control Language，数据控制语言<br>主要<code>grant</code>和<code>revoke</code> 两个关键字完成。</p>
<h3 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h3><p>主要由<code>commit</code>、<code>rollback</code>和<code>savepoint</code>三个关键字完成，<code>savepoint</code>了解就行。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7更新gcc,并解决version 'GLIBCXX_3.4.21' not found</title>
    <url>/2020/01/09/centos7%E6%9B%B4%E6%96%B0gcc-%E5%B9%B6%E8%A7%A3%E5%86%B3version-GLIBCXX-3-4-21-not-found/</url>
    <content><![CDATA[<a id="more"></a>
<ol>
<li><p>升级gcc<br><a href="https://www.cnblogs.com/NanZhiHan/p/11010130.html" target="_blank" rel="noopener">https://www.cnblogs.com/NanZhiHan/p/11010130.html</a></p>
</li>
<li><p>解决解决version ‘’GLIBCXX_3.4.21’’ not found’<br>安装完成新版本gcc后，根据上面的教程安装在了<code>/usr/local/gcc</code>下，<br>首先</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/gcc/lib64</span><br><span class="line"><span class="comment"># 根据升级的gcc版本不同，这里的文件名可能后面的某些数字不同</span></span><br><span class="line">sudo cp libstdc++.so.6.0.25 /usr/lib64</span><br><span class="line"><span class="built_in">cd</span> /usr/lib64</span><br><span class="line"><span class="comment"># 如果已经存在则将其备份</span></span><br><span class="line">sudo mv libstdc++.so.6 libstdc++.so.6.back</span><br><span class="line"><span class="comment"># 将拷贝进来的文件建立软连接</span></span><br><span class="line">sudo ln -s libstdc++.so.6.0.25 libstdc++.so.6</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux简单使用</title>
    <url>/2020/01/09/tmux%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>tmux</td>
<td>进入tmux</td>
</tr>
<tr>
<td><c-b>+%</c-b></td>
<td>新建一个竖分屏窗口会话</td>
</tr>
<tr>
<td><c-b>+”</c-b></td>
<td>新建一个横分屏窗口会话</td>
</tr>
<tr>
<td><c-b>+c</c-b></td>
<td>新建一个tmux标签页</td>
</tr>
<tr>
<td><c-b>+p</c-b></td>
<td>到上一个tmux标签页</td>
</tr>
<tr>
<td><c-b>+n</c-b></td>
<td>到下一个tmux标签页</td>
</tr>
<tr>
<td><c-b>+w</c-b></td>
<td>菜单选择tmux标签页</td>
</tr>
<tr>
<td><c-b>+d</c-b></td>
<td>删除当前会话窗口</td>
</tr>
<tr>
<td><c-b>+t</c-b></td>
<td>显示时钟，按enter回到shell</td>
</tr>
<tr>
<td><c-b>+方向键</c-b></td>
<td>选择会话窗口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>ftp服务搭建</title>
    <url>/2020/01/08/ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>参考文章<a href="https://blog.csdn.net/langyue919/article/details/80796369" target="_blank" rel="noopener">https://blog.csdn.net/langyue919/article/details/80796369</a></p>
<a id="more"></a>

<ul>
<li>默认在root用户下操作<h3 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y vsftpd</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置端口"><a href="#配置端口" class="headerlink" title="配置端口"></a>配置端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcp模式放行20, 21端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=20/tcp --permanent</span><br></pre></td></tr></table></figure>

<ul>
<li>同时各个云服务器要在网页控制台直接放行端口，或配置安全组策略</li>
</ul>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/vsftpd</span><br><span class="line">vi vsftpd.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改以下参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen=YES</span><br><span class="line">listen_ipv6=NO</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加如下参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pam_service_name=vsftpd</span><br><span class="line">userlist_enable=YES</span><br><span class="line">tcp_wrappers=YES</span><br><span class="line"></span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_address=123.1.1.1  #服务器外网ip地址</span><br><span class="line">pasv_min_port=5500</span><br><span class="line">pasv_max_port=6000</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="配置被动模式所用端口"><a href="#配置被动模式所用端口" class="headerlink" title="配置被动模式所用端口"></a>配置被动模式所用端口</h3><ul>
<li>上面配置文件中选定了5500-6000端口，现在放行<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5500-6000/tcp --permanent</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selinux=disable</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>setenforce 0</code>立即生效</p>
</li>
</ul>
<h3 id="创建ftp用户"><a href="#创建ftp用户" class="headerlink" title="创建ftp用户"></a>创建ftp用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd_login</span><br></pre></td></tr></table></figure>

<ul>
<li><p>写入虚拟用户的用户名和密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user1          奇数行  写用户名</span><br><span class="line">123            偶数行  写密码</span><br><span class="line">user2          多个用户就写多组，中间不能有空行和空格</span><br><span class="line">456</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 /etc/vsftpd/vsftpd_login</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>将文本文件转换成二进制文件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/vsftpd_login /etc/vsftpd/vsftpd_login.db</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建虚拟用户的配置文件目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/vsftpd/vsftpd_user_conf</span><br><span class="line"><span class="built_in">cd</span> /etc/vsftpd/vsftpd_user_conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建虚拟用户的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim user1       <span class="comment">#此处的文件名必须和/etc/vsftpd/vsftpd_login文件里的用户名一致</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义虚拟用户的家目录</span><br><span class="line">local_root=/home/user1</span><br><span class="line"></span><br><span class="line">#不允许匿名用户登陆，如果允许则用YES</span><br><span class="line">anonymous_enable=YES</span><br><span class="line"></span><br><span class="line">#写权限，允许</span><br><span class="line">write_enable=YES</span><br><span class="line"></span><br><span class="line">#设定umask，用来控制用户创建文件和目录的默认权限</span><br><span class="line">local_umask=022</span><br><span class="line"></span><br><span class="line">#不允许匿名用户上传</span><br><span class="line">anon_upload_enable=NO</span><br><span class="line"></span><br><span class="line">#不允许匿名用户创建目录和写权限</span><br><span class="line">anon_mkdir_write_enable=NO</span><br><span class="line"></span><br><span class="line">#空闲时限600秒，超时自动断开</span><br><span class="line">#idle_session_timeout=600</span><br><span class="line"></span><br><span class="line">#数据连接（请求）时限120秒，超时会自动断开</span><br><span class="line">#data_connection_timeout=120</span><br><span class="line"></span><br><span class="line">#客户端的最大连接数</span><br><span class="line">max_clients=10</span><br><span class="line">pasv_promiscuous=YES</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义用户验证文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/pam.d/vsftpd    #编辑ftp的用户认证文件</span><br><span class="line">#在最前面加上：注意区分系统是32位还是64位</span><br><span class="line">#指定密码验证形式为文件形式，并指定路径路径</span><br><span class="line">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login </span><br><span class="line">#指定账户存储形式为文件，并指定账户存储文件路径</span><br><span class="line">account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>配置完成</strong>，接下来就可使用ftp客户端连接了</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>ftp相关命令</title>
    <url>/2020/01/08/ftp%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ftp接地址直接登录</span></span><br><span class="line">ftp ip地址</span><br><span class="line"><span class="comment"># 先启动ftp然后使用open</span></span><br><span class="line">ftp</span><br><span class="line">open ip地址</span><br></pre></td></tr></table></figure>

<p>之后输入用户名和密码即可</p>
<h2 id="文件相关指令"><a href="#文件相关指令" class="headerlink" title="文件相关指令"></a>文件相关指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dir     <span class="comment">#显示服务器目录和文件列表</span></span><br><span class="line">ls      <span class="comment">#显示服务器目录和文件列表</span></span><br><span class="line"><span class="built_in">cd</span>      <span class="comment">#进入服务器指定目录</span></span><br><span class="line">lcd     <span class="comment">#进入本地客户端指定目录</span></span><br><span class="line">ascii   <span class="comment">#设定传输方式为ascii传输</span></span><br><span class="line">binary  <span class="comment">#设定传输方式为二进制传输</span></span><br><span class="line">get/recv oldname [newname] <span class="comment">#下载服务器上的文件到本地，[并重命名为newname]</span></span><br><span class="line">mget file1 file2 ...  <span class="comment">#下载多个文件，支持通配符</span></span><br><span class="line">put/send oldname [newname] <span class="comment">#上传文件到服务器，[并重命名为newname]</span></span><br><span class="line">mput file1 file2 ...  <span class="comment">#上传多个文件，支持通配符</span></span><br><span class="line">rename oldname newname <span class="comment">#重命名文件</span></span><br><span class="line">delete file  <span class="comment">#删除文件</span></span><br><span class="line">mdelete file1 file2 ...  <span class="comment">#删除多个文件</span></span><br><span class="line"><span class="built_in">help</span>   <span class="comment">#帮助信息</span></span><br><span class="line">prompt <span class="comment">#打开/关闭交互提示</span></span><br><span class="line"><span class="built_in">bye</span>    <span class="comment">#退出ftp</span></span><br><span class="line">passive  <span class="comment">#主动与被动模式切换</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>QT中TCP通信</title>
    <url>/2019/12/07/QT%E4%B8%ADTCP%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<a id="more"></a>


<ul>
<li>整体流程如下<br><img src="t1.png" alt="tcp"></li>
</ul>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><ul>
<li>在pro文件中加入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QT += network</span><br><span class="line">CONFIG += c++11</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="include-h"><a href="#include-h" class="headerlink" title="_include.h"></a>_include.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _INCLUDE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INCLUDE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpServer&gt;  //监听套接字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTcpSocket&gt;  //通信套接字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpserver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpclient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _INCLUDE_H</span></span></span><br></pre></td></tr></table></figure>

<h4 id="tcpclient-h"><a href="#tcpclient-h" class="headerlink" title="tcpclient.h"></a>tcpclient.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPCLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPCLIENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_include.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TcpClient</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~TcpClient();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btn_connect_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btn_send_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btn_close_clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::TcpClient *ui;</span><br><span class="line">    QTcpSocket *client_sock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPCLIENT_H</span></span></span><br></pre></td></tr></table></figure>

<h4 id="tcpclient-cpp"><a href="#tcpclient-cpp" class="headerlink" title="tcpclient.cpp"></a>tcpclient.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpclient.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_tcpclient.h"</span></span></span><br><span class="line"></span><br><span class="line">TcpClient::TcpClient(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::TcpClient)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    setWindowTitle(<span class="string">"客户端"</span>);</span><br><span class="line">    client_sock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    client_sock = <span class="keyword">new</span> QTcpSocket(<span class="keyword">this</span>);</span><br><span class="line">    connect(client_sock, &amp;QTcpSocket::connected,\</span><br><span class="line">            [=]()&#123;</span><br><span class="line">        ui-&gt;text_recv-&gt;setText(<span class="string">"成功连接服务器"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    connect(client_sock, &amp;QTcpSocket::readyRead, \</span><br><span class="line">            [=]()&#123;</span><br><span class="line">                <span class="comment">//获取对方发送的内容</span></span><br><span class="line">                QByteArray <span class="built_in">array</span> = client_sock-&gt;readAll();</span><br><span class="line">                <span class="comment">//追加到编辑区中</span></span><br><span class="line">                ui-&gt;text_recv-&gt;append(<span class="built_in">array</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpClient::~TcpClient()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpClient::on_btn_connect_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取服务器端口和IP</span></span><br><span class="line">    QString ip = ui-&gt;lineEdit_ip-&gt;text();</span><br><span class="line">    quint16 port = ui-&gt;lineEdit_port-&gt;text().toInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主动和服务器连接</span></span><br><span class="line">    client_sock-&gt;connectToHost(QHostAddress(ip), port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpClient::on_btn_send_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(client_sock==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取编辑框内容</span></span><br><span class="line">    QString str = ui-&gt;text_send-&gt;toPlainText();</span><br><span class="line">    ui-&gt;text_send-&gt;clear();</span><br><span class="line">    <span class="comment">//给对方发送数据，使用的是tcpSocket</span></span><br><span class="line">    client_sock-&gt;write(str.toUtf8().data());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpClient::on_btn_close_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(client_sock==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//主动和对方断开连接</span></span><br><span class="line">    client_sock-&gt;disconnectFromHost();</span><br><span class="line">    client_sock-&gt;close();</span><br><span class="line">    client_sock = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcpserver-h"><a href="#tcpserver-h" class="headerlink" title="tcpserver.h"></a>tcpserver.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_include.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTcpServer *tcpServer;</span><br><span class="line">    QTcpSocket *tcpSocket;</span><br><span class="line">    QString client_ip;</span><br><span class="line">    quint16 client_port;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitServer</span><span class="params">()</span></span>;  <span class="comment">//初始化服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TcpServer</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Write</span><span class="params">(QString data)</span></span>;</span><br><span class="line">    <span class="function">QByteArray <span class="title">Read</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DisConnect</span><span class="params">()</span></span>;</span><br><span class="line">    ~TcpServer();</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SuccessConnected</span><span class="params">(QString ip, quint16 port)</span></span>;  <span class="comment">//成功连接客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RecvMessage</span><span class="params">(QByteArray data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TCPSERVER_H</span></span></span><br></pre></td></tr></table></figure>

<h4 id="tcpserver-cpp"><a href="#tcpserver-cpp" class="headerlink" title="tcpserver.cpp"></a>tcpserver.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpserver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义监听端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_SERVER_LISTEN_PORT 5894</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TcpServer::TcpServer(QObject *parent) : QObject(parent)</span><br><span class="line">&#123;    </span><br><span class="line">    InitServer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpServer::InitServer()</span><br><span class="line">&#123;</span><br><span class="line">    tcpServer = <span class="keyword">new</span> QTcpServer(<span class="keyword">this</span>);</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line">    tcpServer-&gt;listen(QHostAddress::Any, TCP_SERVER_LISTEN_PORT);</span><br><span class="line">    connect(tcpServer, &amp;QTcpServer::newConnection, \</span><br><span class="line">            [=]()&#123;</span><br><span class="line">                <span class="comment">//取出建立好连接的套接字</span></span><br><span class="line">                tcpSocket = tcpServer-&gt;nextPendingConnection();</span><br><span class="line">                <span class="comment">//获取对方的ip和端口</span></span><br><span class="line">                QString client_ip = tcpSocket-&gt;peerAddress().toString();</span><br><span class="line">                quint16 client_port = tcpSocket-&gt;peerPort();</span><br><span class="line">                emit SuccessConnected(client_ip, client_port);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当获取了tcpSocket后,建立连接关系，读取接收到的消息</span></span><br><span class="line">                connect(tcpSocket, &amp;QTcpSocket::readyRead, \</span><br><span class="line">                        [=]()&#123;</span><br><span class="line">                            QByteArray <span class="built_in">array</span> = tcpSocket-&gt;readAll();</span><br><span class="line">                            emit RecvMessage(<span class="built_in">array</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> TcpServer::Write(QString data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//给对方发送数据，使用的是tcpSocket</span></span><br><span class="line">    <span class="keyword">if</span>(tcpSocket-&gt;write(data.toUtf8().data())==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpServer::DisConnect()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tcpSocket==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//主动和客户端断开连接</span></span><br><span class="line">    tcpSocket-&gt;disconnectFromHost();</span><br><span class="line">    tcpSocket-&gt;close();</span><br><span class="line">    tcpSocket = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~TcpServer()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="widget-h"><a href="#widget-h" class="headerlink" title="widget.h"></a>widget.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_include.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    TcpServer *tcp_server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DealSuccessConnected</span><span class="params">(QString ip, quint16 port)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DealRecvMessage</span><span class="params">(QByteArray data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_button_send_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_button_close_clicked</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a>widget.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    setWindowTitle(<span class="string">"服务器：5894"</span>);</span><br><span class="line">    tcp_server = <span class="keyword">new</span> TcpServer(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//连接成功后输出提示信息</span></span><br><span class="line">    connect(tcp_server, &amp;TcpServer::SuccessConnected, <span class="keyword">this</span>, &amp;Widget::DealSuccessConnected);</span><br><span class="line">    <span class="comment">//收到消息后显示在文本框</span></span><br><span class="line">    connect(tcp_server, &amp;TcpServer::RecvMessage, <span class="keyword">this</span>, &amp;Widget::DealRecvMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::DealSuccessConnected(QString ip, quint16 port)</span><br><span class="line">&#123;</span><br><span class="line">    QString info = QString (<span class="string">"%1:%2:成功连接"</span>).arg(ip).arg(port);</span><br><span class="line">    ui-&gt;text_read-&gt;setText(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::DealRecvMessage(QByteArray data)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;text_read-&gt;append(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::on_button_send_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取编辑区内容</span></span><br><span class="line">    QString str = ui-&gt;text_send-&gt;toPlainText();</span><br><span class="line">    ui-&gt;text_send-&gt;clear();</span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    tcp_server-&gt;Write(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::on_button_close_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    tcp_server-&gt;DisConnect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>该程序会生成两个窗口（重合在一起，需用鼠标拖开），一个服务端，一个客户端，连接后即可通信</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab调度</title>
    <url>/2019/12/06/crontab%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<a id="more"></a>
<ul>
<li>crontab命令</li>
</ul>
<p>-e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)<br>-r : 删除目前的时程表<br>-l : 列出目前的时程表</p>
<ul>
<li>编写任务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>星号分别代表<strong>分，时，一个月中的第几天，月份，星期几</strong></p>
<blockquote>
<p>分：0-59，如在每小时的第十分钟执行，这里就写<code>10</code>，如果每隔五分钟执行一次就写<code>*/5</code>，如要每小时的第1,5,10分钟执行，就写<code>1,5,10</code><br>时：0-23<br>第几天：1-31<br>月份：1-12<br>星期：0-7，0和7都代表周日</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>任务调度</tag>
      </tags>
  </entry>
  <entry>
    <title>QT多线程</title>
    <url>/2019/12/03/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="QT4"><a href="#QT4" class="headerlink" title="QT4"></a>QT4</h2><ul>
<li><p>自定义一个类，继承自<strong>QThread</strong>，并实现<strong>run()</strong>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>:</span> <span class="keyword">public</span> Qthread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">//线程处理函数（和主线程不在同一个线程）</span></span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">isDone</span><span class="params">()</span></span>;  <span class="comment">//用于判断线程是否结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyThread::run()</span><br><span class="line">&#123;</span><br><span class="line">	QThread.sleep(<span class="number">5</span>);  <span class="comment">//sleep延时模拟实际工程中的处理函数</span></span><br><span class="line">	<span class="function">emit <span class="title">isDone</span><span class="params">()</span></span>;  <span class="comment">//处理完触发isDone()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象并调用<strong>start()</strong>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyThread th;</span><br><span class="line">th.start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭线程</span></span><br><span class="line">th-&gt;quit();</span><br><span class="line"><span class="comment">//等待线程处理完手头工作</span></span><br><span class="line">th-&gt;wait();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="QT5"><a href="#QT5" class="headerlink" title="QT5"></a>QT5</h2><ul>
<li>自定义一个类，继承自<strong>QObject</strong></li>
<li>类中设置一个线程函数（只有一个是线程函数）</li>
<li>在主线程中创建线程对象（不能指定父对象）myTh和Qthread实例对象th</li>
<li>使用<code>myTh-&gt;moveToThread(th)</code>把自定义线程类加入到子线程</li>
<li>使用connect建立一定关系的连接</li>
<li>调用Qthread实例对象的<code>start()</code>方法启动线程</li>
</ul>
<blockquote>
<p>mythread.h</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTHREAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyThread</span><span class="params">(QObject *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;  <span class="comment">//线程处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">bool</span> flg=<span class="literal">false</span>)</span></span>;  <span class="comment">//标志位，通过设置标志位进入或退出处理函数的循环</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYTHREAD_H</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>mythread.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mythread.h"</span></span></span><br><span class="line"></span><br><span class="line">MyThread::MyThread(QObject *parent) : QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyThread::setFlag(<span class="keyword">bool</span> flg)</span><br><span class="line">&#123;</span><br><span class="line">    flag = flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyThread::doWork()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        QThread::sleep(<span class="number">1</span>);  <span class="comment">//每隔一秒触发一次信号</span></span><br><span class="line">        <span class="function">emit <span class="title">mySignal</span><span class="params">()</span></span>;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"子线程号："</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>widget.h</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mythread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~Widget();</span><br><span class="line">    QThread *th;</span><br><span class="line">    MyThread *myTh;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_start_button_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_stop_btn_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLcdNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dealClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>widget.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 为线程分配空间</span></span><br><span class="line">    <span class="comment">//创建QThread对象</span></span><br><span class="line">    th = <span class="keyword">new</span> QThread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建自定义线程类对象，该类必须继承于QObject</span></span><br><span class="line">    myTh = <span class="keyword">new</span> MyThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 将自定义线程加入到QThread创建的对象中</span></span><br><span class="line">    myTh -&gt; moveToThread(th);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当触发自定义线程中的信号时，使LCD显示的数字增加</span></span><br><span class="line">    connect(myTh, &amp;MyThread::mySignal, <span class="keyword">this</span>, &amp;Widget::addLcdNum);</span><br><span class="line">    <span class="comment">//3. 当触发主界面类的开启线程信号时，开启线程处理函数,调用th-&gt;start()</span></span><br><span class="line">    connect(<span class="keyword">this</span>, &amp;Widget::startThread, myTh, &amp;MyThread::doWork);</span><br><span class="line">    <span class="comment">//当窗口被关闭时，释放资源</span></span><br><span class="line">    connect(<span class="keyword">this</span> ,&amp;Widget::destroyed, <span class="keyword">this</span>, &amp;Widget::dealClose);</span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"主线程是："</span> &lt;&lt; QThread::currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::addLcdNum()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    ui -&gt; lcdNumber -&gt; display(++num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下开始键，触发开启线程的信号</span></span><br><span class="line"><span class="keyword">void</span> Widget::on_start_button_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(th-&gt;isRunning())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    th -&gt; start();</span><br><span class="line">    myTh -&gt; setFlag(<span class="literal">true</span>);</span><br><span class="line">    <span class="function">emit <span class="title">startThread</span><span class="params">()</span></span>;  <span class="comment">//触发信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下停止键，将标志位翻转</span></span><br><span class="line"><span class="keyword">void</span> Widget::on_stop_btn_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(th-&gt;isRunning()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    myTh -&gt; setFlag(<span class="literal">false</span>);</span><br><span class="line">    th -&gt; quit();</span><br><span class="line">    th -&gt; wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭窗口</span></span><br><span class="line"><span class="keyword">void</span> Widget::dealClose()</span><br><span class="line">&#123;</span><br><span class="line">    on_stop_btn_clicked();</span><br><span class="line">    <span class="keyword">delete</span> myTh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>QT中QString和char*互转</title>
    <url>/2019/12/02/QT%E4%B8%ADQString%E5%92%8Cchar-%E4%BA%92%E8%BD%AC/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="QString转char"><a href="#QString转char" class="headerlink" title="QString转char*"></a>QString转char*</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString qstr = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">char</span> *str = qstr.toUtf8().data(); <span class="comment">//先转为QByteArray,再转为char*</span></span><br></pre></td></tr></table></figure>

<h4 id="char-转QString"><a href="#char-转QString" class="headerlink" title="char*转QString"></a>char*转QString</h4><p>使用构造方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch=<span class="string">"hello!"</span>;</span><br><span class="line"><span class="function">QString <span class="title">str</span><span class="params">(ch)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QString</tag>
      </tags>
  </entry>
  <entry>
    <title>QT中信号和槽</title>
    <url>/2019/12/02/QT%E4%B8%AD%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）</p>
<p>信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。</p>
<h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>connect()函数最常用的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(sender, signal, receiver, slot);</span><br></pre></td></tr></table></figure>

<p>参数：<br>sender：发出信号的对象<br>signal：发送对象发出的信号(地址)<br>receiver：接收信号的对象<br>slot：接收对象在接收到信号之后所需要调用的函数(地址)</p>
<p>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在使用widget新建的工程中，在<code>widget.cpp</code>的构造函数中写入下面的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QPushButton *btn1 = <span class="keyword">new</span> QPushButton();</span><br><span class="line"><span class="comment">//    btn1-&gt;show();  //show会以顶层方式弹出窗口控件</span></span><br><span class="line">    btn1-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;setText(<span class="string">"关闭窗口"</span>);</span><br><span class="line">    btn1-&gt;move(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    setFixedSize(<span class="number">600</span>, <span class="number">400</span>);  <span class="comment">//设置窗口固定大小</span></span><br><span class="line">    <span class="comment">//调用connect实现信号与槽函数的连接</span></span><br><span class="line">    connect(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样建立了点击按钮这个信号和关闭窗口这个槽函数的连接，当按下按钮时，窗口就会关闭</p>
<h3 id="自定义信号与槽"><a href="#自定义信号与槽" class="headerlink" title="自定义信号与槽"></a>自定义信号与槽</h3><ul>
<li><p>实现的效果是-&gt;信号：下课-老师饿了  槽：学生请老师吃饭</p>
</li>
<li><p>首先创建两个类老师Teacher，学生Student</p>
</li>
<li><p>老师在signals下声明hungry()方法，不需实现</p>
</li>
<li><p>学生在public slots下声明treat()方法，需要实现，实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::treat()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"请客吃饭"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Widget类中声明并实现ClassIsOver()方法，使用emit触发Teacher类中hungry()信号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_widget.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建老师，学生对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;tc = <span class="keyword">new</span> Teacher(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;st = <span class="keyword">new</span> Student(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立老师饿了，学生请客的链接</span></span><br><span class="line">    connect(tc, &amp;Teacher::hungry, st, &amp;Student::treat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用下课函数，</span></span><br><span class="line">    classISOver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Widget::classISOver()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//下课函数,调用此函数后使用emit触发老师饿了的信号</span></span><br><span class="line">    emit tc-&gt;hungry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果发生重载，可以定义函数指针来指向确定的函数，如在上述例子中重载hungry和treat方法中加入QString参数，指明吃什么，就可以通过下面的写法指明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义函数指针，指向重载函数中确定的某一个</span></span><br><span class="line"><span class="keyword">void</span> (Teacher::*tcSignal)(QString) = &amp;Teacher::hungry;</span><br><span class="line"><span class="keyword">void</span> (Student::*stSlot)(QString) = &amp;Student::treat;</span><br><span class="line">connect(tc, tcSignal, st, stSlot);</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些注意事项</p>
</li>
</ul>
<ul>
<li><input disabled type="checkbox"> <p>信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义信号，写到signals下</span><br><span class="line">返回值是void，只需要声明，不需要实现</span><br><span class="line">可以有参数，可以重载</span><br></pre></td></tr></table></figure>
</li>
<li><input disabled type="checkbox"> <p>槽：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">早期QT版本，必须写到public slots下，高版本可以写到public或全局下</span><br><span class="line">返回值void，需要声明，也要实现</span><br><span class="line">可以有参数，可以重载</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="断开信号与槽"><a href="#断开信号与槽" class="headerlink" title="断开信号与槽"></a>断开信号与槽</h3><ul>
<li>使用<code>disconnect</code>方法，参数复制<code>connect</code>中的即可</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>信号可以连接信号</li>
<li>一个信号可以连接多个槽</li>
<li>多个信号可以连接同一个槽</li>
<li>信号和槽函数的参数必须类型一一对应</li>
<li>信号的参数个数可以多于槽函数参数的个数，之前的参数类型要一一对应</li>
</ul>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>信号与槽</tag>
      </tags>
  </entry>
  <entry>
    <title>QT学习1</title>
    <url>/2019/12/01/QT%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<a id="more"></a>
<p>创建工程时，会看到如下界面<br><img src="q1.png" alt="工程"><br>其实，<code>QMainWindows</code>和<code>QDialog</code>是<code>QWidget</code>的子类，<code>QWidget</code>只有一个空界面，而另外两个子类在其基础上增添了其他功能</p>
<h3 id="新建源文件的注释说明"><a href="#新建源文件的注释说明" class="headerlink" title="新建源文件的注释说明"></a>新建源文件的注释说明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mywidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;  //包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main程序入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a应用程序对象，在Qt中，应用程序对象有切纸有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//窗口对象，myWidget父类-&gt;QWidget</span></span><br><span class="line">    myWidget w;</span><br><span class="line">    <span class="comment">//窗口对象，需使用show方法来显示</span></span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让应用程序对象进入消息循环</span></span><br><span class="line">    <span class="comment">//让代码阻塞到这行</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新建源文件的注释说明-1"><a href="#新建源文件的注释说明-1" class="headerlink" title="新建源文件的注释说明"></a>新建源文件的注释说明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYWIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYWIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myWidget</span> :</span> <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这是一个宏，允许类中使用信号和槽的机制</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    myWidget(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~myWidget();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYWIDGET_H</span></span></span><br></pre></td></tr></table></figure>

<h3 id="QT的pro文件"><a href="#QT的pro文件" class="headerlink" title="QT的pro文件"></a>QT的pro文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># QT包含的模块</span></span><br><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于QT4版本以上，包含widget模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标：生成的.exe程序的名称</span></span><br><span class="line">TARGET = <span class="number">01</span>_FirstProject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板：应用程序模板Application</span></span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件</span></span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mywidget.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件</span></span><br><span class="line">HEADERS += \</span><br><span class="line">    mywidget.h</span><br></pre></td></tr></table></figure>

<h3 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+/</td>
<td>注释</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>运行</td>
</tr>
<tr>
<td>ctrl+b</td>
<td>编译</td>
</tr>
<tr>
<td>ctrl+滚轮</td>
<td>字体缩放</td>
</tr>
<tr>
<td>ctrl+f</td>
<td>查找</td>
</tr>
<tr>
<td>ctrl+shift+上下键</td>
<td>整行移动</td>
</tr>
<tr>
<td>ctrl+i</td>
<td>自动对齐</td>
</tr>
<tr>
<td><f4></f4></td>
<td>同名的.h和.cpp文件切换</td>
</tr>
<tr>
<td><f1></f1></td>
<td>帮助文档</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器安装mysql(CentOS7)</title>
    <url>/2019/11/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mysql-CentOS7/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="安装Yum资源包"><a href="#安装Yum资源包" class="headerlink" title="安装Yum资源包"></a>安装Yum资源包</h3><p>CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<img src="https://dev.mysql.com/downloads/repo/yum/" alt="官网链接"><br><img src="f1.png" alt="下载"><br>点击Download下载到本地<br>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#linux下使用scp命令将下载的文件传输到服务器，windows下可以使用xftp软件</span></span><br><span class="line">scp /path/to/download/package user@123.31.31.45:path/to/your/server</span><br></pre></td></tr></table></figure>

<h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"><span class="built_in">cd</span> 放置刚才下载.rpm文件的目录</span><br><span class="line">sudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<p>通过修改vim /etc/yum.repos.d/mysql-community.repo文件，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0，然后再将5.6源的enabled=0改成enabled=1即可。<br>注意： 任何时候，只能启用一个版本。<br>查看当前的启用的 MySQL 版本：yum repolist enabled | grep mysql</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-server -y</span><br></pre></td></tr></table></figure>

<h3 id="初始化mysql"><a href="#初始化mysql" class="headerlink" title="初始化mysql"></a>初始化mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mysqld --initialize</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p>然后这一步我就出问题了，我把<code>/var/lib/mysql删除后就可以了</code></p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下将gbk文件转换为utf-8</title>
    <url>/2019/11/23/linux%E4%B8%8B%E5%B0%86gbk%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAutf-8/</url>
    <content><![CDATA[<p>转自<a href="https://blog.csdn.net/u012724167/article/details/77248919" target="_blank" rel="noopener">Linux下GBK文件编码批量转换UTF-8命令</a></p>
<p>在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>
<a id="more"></a>
<h3 id="Linux命令-enca-查看文件的编码"><a href="#Linux命令-enca-查看文件的编码" class="headerlink" title="Linux命令-enca 查看文件的编码"></a>Linux命令-enca 查看文件的编码</h3><ul>
<li><p>Enca语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...</span><br><span class="line">        enconv [-L LANGUAGE] [OPTION]... [FILE]...</span><br><span class="line">        Detect encoding of text files and convert them <span class="keyword">if</span> required.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Enca用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ enca -L zh_CN file 检查文件的编码</span><br><span class="line">$ enca -L zh_CN -x UTF-8 file 将文件编码转换为<span class="string">"UTF-8"</span>编码</span><br><span class="line">$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。</p>
<ul>
<li><p>转换单个文件的编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ enca -L none -x utf-8  index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换多个文件的编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ enca -x utf-8 *</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Linux文件名编码批量转换–convmv"><a href="#Linux文件名编码批量转换–convmv" class="headerlink" title="Linux文件名编码批量转换–convmv"></a>Linux文件名编码批量转换–convmv</h3><p>Convmv语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ convmv -f 源编码 -t 新编码 [选项] 文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>Convmv 常用参数</li>
</ul>
<p>-r 递归处理子文件夹<br>–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。<br>–list 显示所有支持的编码<br>–unescap 可以做一下转义，比如把%20变成空格</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>转换一个文件由GBK转换成UTF-8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convmv -f GBK -t UTF-8 --notest utf8 filename</span><br></pre></td></tr></table></figure>
</li>
<li><p>GBK-&gt;UTF-8文件编码批量转换脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find default -<span class="built_in">type</span> f -<span class="built_in">exec</span> convmv -f GBK -t UTF-8 --notest utf8 &#123;&#125; -o utf/&#123;&#125; \;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用iconv-转换"><a href="#使用iconv-转换" class="headerlink" title="使用iconv 转换"></a>使用iconv 转换</h3><ul>
<li>Iconv语法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iconv -f encoding -t encoding inputfile</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>单个文件转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iconv -f GBK -t UTF-8 file1 -o file2</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量转换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find default -<span class="built_in">type</span> d -<span class="built_in">exec</span> mkdir -p utf/&#123;&#125; \;</span><br><span class="line">$ find default -<span class="built_in">type</span> f -<span class="built_in">exec</span> iconv -f GBK -t UTF-8 &#123;&#125; -o utf/&#123;&#125; \;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言多线程</title>
    <url>/2019/11/21/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98588567" target="_blank" rel="noopener">码农有道的博客</a></p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>和多进程相比，多线程是一种比较节省资源的多任务操作方式。启动一个新的进程必须分配给它独立的地址空间，每个进程都有自己的堆栈段和数据段，系统开销比较高，进行数据的传递只能通过进行间通信的方式进行。在同一个进程中，可以运行多个线程，运行于同一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享全局数据，启动一个线程所消耗的资源比启动一个进程所消耗的资源要少。</p>
<a id="more"></a>

<h2 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>在Linux下，采用pthread_create函数来创建一个新的线程，函数声明：</p>
<ul>
<li><p>包含头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数thread为为指向线程标识符的地址。<br>参数attr用于设置线程属性，一般为空，表示使用默认属性。<br>参数start_routine是线程运行函数的地址。<br>参数arg是线程运行函数的参数。新创建的线程从start_routine函数的地址开始运行，该函数只有一个无类型指针参数arg。  </p>
<blockquote>
<p>在编译时注意加上-lpthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p>
</blockquote>
<h3 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h3><p>如果进程中的任一线程调用了exit(0)，则整个进程会终止，所以，在线程的start_routine函数中，不能采用exit。</p>
<ul>
<li>线程的终止有三种方式：<br>1）线程的start_routine函数代码结束，自然消亡。<br>2）线程的start_routine函数调用pthread_exit结束，不想活了。<br>3）被主进程或其它线程中止，被杀了，一般情况不会这么做。</li>
</ul>
<p>pthread_exit函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数retval填空。</p>
<ul>
<li>线程主函数的函数体中，不能使用return语句，如果想退出线程，可以用pthread_exit(0);返回。</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步？怎么同步？一起运行？一起停止？我当年听说线程同步这个词的时候，也是一头雾水。</p>
<p>在人们的日常生活中，所说的锁大概有两种：一种是不允许访问；另一种是资源忙，同一时间只允许一个使用者占用，其它使用者如果要使用，必须要等待。</p>
<p>1）不允许访问的锁好理解，就像每户人家的锁，不允许外人进入。<br>2）第二种锁，例如火车上的厕所，它是公共的，空闲的时候任何人可以进入，人进去以后就会把它锁起来，其它的人如果要上厕所，必须等待解锁，即里面的人出来。还有红绿灯，红灯是加锁，绿灯是解锁。</p>
<p>对多线程来说，资源是共享的，基本上不存在不允许访问的情况，但是，共享的资源在某一时间点只能有一个线程占用，这种情况是存在的，所以需要给资源加锁。</p>
<p>线程的锁的种类有互斥锁、读写锁、条件变量、自旋锁、信号灯。</p>
<p>在本章节中，只介绍互斥锁，其它的锁应用场景极少</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁机制是同一时刻只允许一个线程占有共享的资源。</p>
<ul>
<li>初始化锁<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutex_attr_t</span> *mutexattr)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中参数 mutexattr 用于指定锁的属性（见下），如果为NULL则使用缺省属性。<br>互斥锁的属性在创建锁的时候指定，当资源被某线程锁住的时候，其它的线程在试图加锁时表现将不同。当前有四个值可供选择：</p>
<p>1）PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。<br>2）PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。<br>3）PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。<br>4）PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，等待解锁后重新竞争。</p>
<ul>
<li><p>阻塞加锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非阻塞加锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">( <span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>该函数语义与 pthread_mutex_lock() 类似，不同的是在锁已经被占据时立即返回 EBUSY，不是挂起等待。</p>
<ul>
<li><p>解锁（要求锁是lock状态，并且由加锁线程解锁）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁锁（此时锁必需unlock状态，否则返回EBUSY）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(pthread_mutex *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h2><p>Linux没有真正意义上的线程，它的实现是由进程来模拟，属于用户级线程。所以，在Linux系统下，进程与线程在性能和资源消耗方面没有本质的差别。对我们程序员来说，进程不能共享全局数据，线程可以共享全局数据，各位可以根据应用场景选择采用多进程或多线程。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>linux进程间通信</title>
    <url>/2019/11/20/linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98588176" target="_blank" rel="noopener">码农有道的博客</a></p>
<a id="more"></a>
<h3 id="进程通信的概念"><a href="#进程通信的概念" class="headerlink" title="进程通信的概念"></a>进程通信的概念</h3><p>进程数据空间是相互独立的，不能相互访问的。但某些情况下进程之间需要互相通信，来完成系统的某项功能或交换数据。</p>
<h3 id="进程通信的场景"><a href="#进程通信的场景" class="headerlink" title="进程通信的场景"></a>进程通信的场景</h3><ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li>
<li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如通知进程退出）。</li>
<li>进程控制：有些进程希望控制另一个进程的运行。</li>
</ul>
<h3 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h3><h4 id="进程通信的方式-1"><a href="#进程通信的方式-1" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h4><ul>
<li>无名管道（pipe）及有名管道（named pipe）：无名管道可用于具有父进程和子进程之间的通信。有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</li>
<li>信号（signal）：信号用于通知接受进程有某种事件发生。</li>
<li>消息队列（message）：消息队列是消息的链接表，进程可以向队列中添加消息，其它的进程则可以读走队列中的消息。</li>
<li>共享内存：使得多个进程可以访问同一块内存空间。</li>
<li>信号灯（semaphore）：也叫信号量，主要作为进程之间对共享资源加锁的手段。</li>
<li>套接字（socket）：可用于不同机器之间的进程间通信。</li>
</ul>
<h4 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h4><ul>
<li>管道和消息队列：太过时了，实在没什么应用价值，了解一下即可。</li>
<li>信号灯（semaphore）：我有十年没用过了，可能会有用，也是了解一下即可，不必深入学习。</li>
<li>信号（signal）：在信号章节中已详细介绍。</li>
<li>套接字（socket）：在TCP通讯章节中介绍。</li>
<li>共享内存：应用场景不多，但还是有，本章节将介绍它。</li>
</ul>
<p>共享内存和信号灯的江湖地位本来是很高的，但是，随着网络带宽的增加和内存数据库技术的发展，共享内存的应用场景越来越少。但是，对于大型数据库系统来说，共享内存和信号灯仍极其重要。<br>socket可以用于不同机器之间的进程通信，完全可以代替只能在同一机器的进程通信的管道和消息队列。</p>
<h3 id="共享内存的概念"><a href="#共享内存的概念" class="headerlink" title="共享内存的概念"></a>共享内存的概念</h3><p>共享内存就是允许多个进程访问同一个内存空间。共享内存是在多个进程之间共享和传递数据最高效的方式。操作系统将不同进程之间共享内存安排为同一段物理内存，进程可以将共享内存连接到它们自己的地址空间中，如果某个进程修改了共享内存中的数据，其它的进程读到的数据也将会改变。</p>
<p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的读写加锁，我们可以用共享内存自身的标记或信号灯。对普通程序员来说，对共享内存加锁的应用场景并不多见。</p>
<h3 id="共享内存的操作"><a href="#共享内存的操作" class="headerlink" title="共享内存的操作"></a>共享内存的操作</h3><p>Linux中提供了一组函数用于操作共享内存，它们声明在头文件 sys/shm.h 中。</p>
<h4 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h4><p>shmget函数用来获取或创建共享内存，它的声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数key是共享内存的键值，是一个整数，typedef unsigned int key_t，是共享内存在系统中的编号，不同共享内存的编号不能相同，这一点由程序员保证。key用十六进制表示比较好。<br>参数size是待创建的共享内存的大小，以字节为单位。<br>参数shmflg是共享内存的访问权限，与文件的权限一样，0666|IPC_CREAT表示全部用户对它可读写，如果共享内存不存在，就创建一个共享内存。</p>
<h4 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h4><p>把共享内存连接到当前进程的地址空间。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数，shm_id是由shmget函数返回的共享内存标识。<br>参数shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。<br>参数shm_flg是一组标志位，通常为0。<br>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p>
<h4 id="shmdt函数"><a href="#shmdt函数" class="headerlink" title="shmdt函数"></a>shmdt函数</h4><p>该函数用于将共享内存从当前进程中分离，相当于shmat函数的反操作。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数shmaddr是shmat函数返回的地址。<br>调用成功时返回0，失败时返回-1.</p>
<h4 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h4><p>删除共享内存，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数shm_id是shmget函数返回的共享内存标识符。<br>参数command填IPC_RMID。<br>参数buf填0。<br>解释一下，shmctl是控制共享内存的函数，其功能不只是删除共享内容，但其它的功能没什么用，所以不介绍了。<br>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</p>
<ul>
<li>示例程序（book255.cpp）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;  <span class="comment">//共享内存标识符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建共享内存，键值为0x5005, 共1024字节, 全部用户可读可写</span></span><br><span class="line">    <span class="keyword">if</span>((shmid=shmget((<span class="keyword">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0666</span>|IPC_CREAT))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"shmat(0x5005)failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *ptext = <span class="number">0</span>;  <span class="comment">//用于指向共享内存的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间，由ptext指针指向它</span></span><br><span class="line">    ptext = (<span class="keyword">char</span> *)shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作本程序的ptext指针，就是操作共享内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"写入前：%s\n"</span>, ptext);</span><br><span class="line">    <span class="built_in">sprintf</span>(ptext, <span class="string">"本程序的进程号是：%d"</span>, getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"写入后：%s\n"</span>, ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">    shmdt(ptext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(shmctl(shmid, IPC_RMID, 0)==-1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf("stmctl(0x5005) failed\n");</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="p1.png" alt="共享内存"></p>
</blockquote>
<p>注意，程序第一次运行的时候，共享内存未创建，所以第一次运行程序的时候，共享内存中的内容为空。之后程序每次运行都能获取到上一次程序运行写入的内容。</p>
<h4 id="两个共享内存的操作命令"><a href="#两个共享内存的操作命令" class="headerlink" title="两个共享内存的操作命令"></a>两个共享内存的操作命令</h4><p>用ipcs -m可以查看当前用户有读限权的共享内存，内容有键值（key），共享内存编号（shmid），创建者（owner），权限（perms），大小（bytes）。<br><img src="p2.png" alt="ipcs"></p>
<p>用ipcrm -m共享内存编号，可以手工删除共享内存，如下：<br><img src="p3.png" alt="ipcrm"></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>linux信号signal</title>
    <url>/2019/11/19/linux%E4%BF%A1%E5%8F%B7signal/</url>
    <content><![CDATA[<ul>
<li>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98587494" target="_blank" rel="noopener">码农有道的博客</a></li>
</ul>
<h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><p>信号是进程在运行过程中，由自身产生或由进程外部发过来的消息（事件）。信号是硬件中断的软件模拟(软中断)。每个信号用一个整型常量宏表示，以SIG开头，比如SIGCHLD( 子进程结束向父进程发送的一个信号 )、SIGINT（Ctrl+c）等，它们在系统头文件&lt;signal.h&gt;中定义,也可以通过在shell下键入kill –l查看信号列表，或者键入man 7 signal查看更详细的说明。</p>
<a id="more"></a>

<h2 id="如何让程序在后台运行"><a href="#如何让程序在后台运行" class="headerlink" title="如何让程序在后台运行"></a>如何让程序在后台运行</h2><p>如果想让程序在后台运行，有两种方法。</p>
<h3 id="加“-amp-”符号"><a href="#加“-amp-”符号" class="headerlink" title="加“&amp;”符号"></a>加“&amp;”符号</h3><p>如果想让程序在后台运行，执行程序的时候，命令的最后面加“&amp;”符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./socket_serve &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>程序<code>socket_serve</code>就在后台运行了。<br><img src="s1.png" alt="后台"><br>在后台运行的程序，用Ctrl+c无法中断，并且就算终端退出了，程序仍在后台运行。<br>如果终端退出了，后台运行的程序将由系统托管。<br><img src="s2.png" alt="交给系统"><br>在第一张图中，socket_serve的父进程是1971，第二张图中，book249的父进程是1。</p>
</blockquote>
<h3 id="采用fork"><a href="#采用fork" class="headerlink" title="采用fork"></a>采用fork</h3><p>另一种方法是采用fork，主程序执行fork，生成一个子进程，然后父进程退出，留下子进程继续运行，子进程将由系统托管。</p>
<ul>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//主进程退出,只留下子进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上图中，子进程的父进程是系统进程。<br><img src="s3.png" alt="进程"></p>
</li>
</ul>
<h3 id="如何让中止后台程序"><a href="#如何让中止后台程序" class="headerlink" title="如何让中止后台程序"></a>如何让中止后台程序</h3><p>问题来了，程序在后台运行了，离开了终端控制，用Ctrl+c上也无法中止，那怎么让它停下来呢？暂时用一个笨方法：杀了它。</p>
<ul>
<li>杀程序有两个方法：</li>
</ul>
<ol>
<li><p>killall 程序名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>先用“ps -ef|grep 程序名”找到程序的进程编号，然后用“kill 进程编号”<br><img src="s4.png" alt="进程"></p>
</li>
</ol>
<h2 id="signal信号"><a href="#signal信号" class="headerlink" title="signal信号"></a>signal信号</h2><p>signal信号是Linux编程中非常重要的部分，接下来将详细介绍信号机制的基本概念、Linux对信号的实现和使用，以及有关信号的几个系统调用（库函数）。</p>
<p>signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。从它的命名可以看出，它的实质和使用很象中断。信号是进程控制的一部分。</p>
<h3 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h3><p>软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据。 </p>
<p>收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。第三种方法是，对该信号的处理保留系统的默认操作，大部分的信号的默认操作是终止进程。</p>
<h3 id="信号的类型"><a href="#信号的类型" class="headerlink" title="信号的类型"></a>信号的类型</h3><p>发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：</p>
<table>
<thead>
<tr>
<th>信号名</th>
<th>信号值</th>
<th>默认处理动作</th>
<th>发出信号的原因</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>1</td>
<td>A</td>
<td>终端挂起或者控制进程终止</td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td>2</td>
<td>A</td>
<td>键盘中断Ctrl+c</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>C</td>
<td>键盘的退出键被按下</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>C</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>C</td>
<td>由abort(3)发出的退出指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>C</td>
<td>浮点异常</td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td>9</td>
<td>AEF</td>
<td>采用kill -9 进程编号 强制杀死程序。不可捕获</td>
</tr>
<tr>
<td><strong>SIGSEGV</strong></td>
<td>11</td>
<td>C</td>
<td>无效的内存引用,不可被捕获</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>A</td>
<td>管道破裂:写一个没有读端口的管道</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>A</td>
<td>由alarm(2)发出的信号</td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td>15</td>
<td>A</td>
<td>采用“kill 进程编号”或“killall 程序名”通知程序。</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>A</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>A</td>
<td>用户自定义信号2</td>
</tr>
<tr>
<td><strong>SIGCHLD</strong></td>
<td>20,17,18</td>
<td>B</td>
<td>子进程结束信号</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td></td>
<td>进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>DEF</td>
<td>终止进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>D</td>
<td>控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>D</td>
<td>后台进程企图从控制终端读</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>D</td>
<td>后台进程企图从控制终端写</td>
</tr>
</tbody></table>
<ul>
<li>处理动作一项中的字母含义如下<br>A 缺省的动作是终止进程。<br>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。<br>C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。<br>D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去。<br>E 信号不能被捕获。<br>F 信号不能被忽略。</li>
</ul>
<h3 id="signal库函数"><a href="#signal库函数" class="headerlink" title="signal库函数"></a>signal库函数</h3><p>signal库函数可以设置程序对信号的处理方式。<br>包含头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数signum表示信号的编号。</p>
<ul>
<li>参数handler表示信号的处理方式，有三种情况：<br>1）SIG_IGN：忽略参数signum所指的信号。<br>2）一个自定义的处理信号的函数，信号的编号为这个自定义函数的参数。<br>3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。<br>程序员不关心signal的返回值。</li>
</ul>
<h3 id="信号有什么用"><a href="#信号有什么用" class="headerlink" title="信号有什么用"></a>信号有什么用</h3><p>服务程序运行在后台，如果想让它中止，杀了它不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定。还有，用Ctrl+c与杀程序是相同的效果。<br>如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。<br>信号还可以用于服务程序抓包等，这是较复杂的应用，暂时不介绍。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。</p>
<blockquote>
<p>Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。一般也会通过<code>close</code>关闭他们</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">50</span>;ii++)</span><br><span class="line">&#123;</span><br><span class="line">    signal(ii,SIG_IGN);</span><br><span class="line">    close(ii);  <span class="comment">//屏蔽标准的输入输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。</p>
<ul>
<li>程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。<blockquote>
<p>程序在运行中，如果按Ctrl+c，将向程序发出SIGINT信号，信号编号是2。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。</p>
</blockquote>
<blockquote>
<p>采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。</p>
</blockquote>
<p>所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。</p>
<ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exit</span><span class="params">(<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"signal=%d\n"</span>, signal);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//忽略所有的信号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        signal(i, SIG_IGN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置SIGINT和SIGTERM的处理函数</span></span><br><span class="line">    signal(SIGINT, Exit);</span><br><span class="line">    signal(SIGTERM, Exit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"/home/duguosheng/study/C_Cpp/signal/test.txt"</span>, <span class="string">"w"</span>))==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打开文件失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"我是第%d个数据\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="s5.png" alt="结束"></p>
</blockquote>
<p>不管是用Ctrl+c还是kill，程序都能体面的退出。</p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>Linux操作系统提供了kill命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。</p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>kill函数将参数sig指定的信号给参数pid 指定的进程。</p>
<ul>
<li>参数pid 有几种情况：</li>
</ul>
<ol>
<li>pid&gt;0 将信号传给进程识别码为pid 的进程。</li>
<li>pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号。</li>
<li>pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。</li>
</ol>
<p>sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。<br>返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。<br>EINVAL：指定的信号码无效（参数 sig 不合法）。<br>EPERM：权限不够无法传送信号给指定进程。<br>ESRCH：参数 pid 所指定的进程或进程组不存在。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>用多进程实现socket并发</title>
    <url>/2019/11/19/%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0socket%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98587017" target="_blank" rel="noopener">码农有道的博客</a></p>
<a id="more"></a>
<h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><p>在之前介绍socket通信的时候，socket的服务端在同一时间只能和一个客户端通信，并不是服务端有多忙，而是因为单进程的程序在同一时间只能做一件事情，不可能一边等待客户端的新连接，一边与其它的客户端进行通信。</p>
<p>如果把socket服务端改为多进程，在每次accept到一个客户端的连接后，生成一个子进程，让子进程负责和这个客户端通信，父进程继续accept客户端的连接，socket的服务端在监听新客户端的同时，还可以与多个客户端进行通信。这就是并发</p>
<h3 id="并发的应用"><a href="#并发的应用" class="headerlink" title="并发的应用"></a>并发的应用</h3><p><a href="https://github.com/duguosheng/MyFunc" target="_blank" rel="noopener">已经封装好了的socket通信代码</a></p>
<blockquote>
<p>具体是下面图中的文件<br><img src="p1.png" alt></p>
</blockquote>
<ul>
<li>修改socket服务端的代码，如下：<br>首先，在CTcpServer类中增加两个成员函数，如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseListen</span><span class="params">()</span></span>;  <span class="comment">//关闭监听套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CloseClient</span><span class="params">()</span></span>;  <span class="comment">//关闭与客户端通信的套接字</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>具体实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CTcpServe::CloseListen(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_listen_sock&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(m_listen_sock);</span><br><span class="line">        m_listen_sock = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CTcpServe::CloseClient(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_serve_sock&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(m_serve_sock);</span><br><span class="line">        m_serve_sock= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>main函数略做修改，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tcp_serve.Accept())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"接收客户端的连接失败\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tcp_serve.CloseClient();  <span class="comment">//关闭父进程中的客户端套接字</span></span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">//父进程进入下次循环继续监听</span></span><br><span class="line">    &#125;</span><br><span class="line">    tcp_serve.CloseListen();  <span class="comment">//关闭子进程中的监听套接字</span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//子进程跳出循环进入下面的通信程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释一下：</p>
</li>
</ul>
<ol>
<li>当有客户端连上来的时候，主进程执行fork，这时候会产生两个客户端的socket（m_clientfd被复制了一份），对父进程来说，只负责监听客户端的连接，不需要与客户端通信，所以父进程关闭客户端的socket，即close(m_clientfd)。</li>
<li>当有客户端连上来的时候，主进程执行fork，这时候也会产生两个服务端的socket（m_listenfd被复制了一份），对子进程来说，只需要与客户端通信，不需要监听客户端的连接，所以子进程关闭监听的socket，即close(m_listenfd)。</li>
<li>子进程执行完任务后，要调用retrun或exit(0)退出，如果没有调用return或exit(0)，子进程将一直存在，直到父进程退出才消失。</li>
</ol>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><h4 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h4><p>一个子进程在调用return结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个僵尸进程。</p>
<p>僵尸进程是子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源。如果父进程先退出，子进程<strong>被系统接管</strong>，也就是子进程的父进程变为了系统进程，子进程退出后系统会回收其占用的相关资源，不会成为僵尸进程。</p>
<p>先启动服务端程序<code>socket_serve</code>，然后多次启动客户端程序<code>socket_client</code>，查看进程，如下图，有<defunct>标志的是僵尸进程，<br><img src="p3.png" alt="僵尸进程"></defunct></p>
<p>如果父进程出退出，僵尸进程随之消失。</p>
<h4 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h4><p>僵尸进程在消失之前会继续占用系统资源。</p>
<h4 id="如何解决僵尸进程"><a href="#如何解决僵尸进程" class="headerlink" title="如何解决僵尸进程"></a>如何解决僵尸进程</h4><p>解决僵尸进程的方法有两种。</p>
<ol>
<li><p>子进程退出之前，会向父进程发送一个信号，父进程调用waid函数等待这个信号，只要等到了，就不会产生僵尸进程。这话说得容易，因为在并发的服务端程序中这是不可能的，因为父进程要做其它的事，例如等待客户端的新连接，不可能去等待子进程的退出信号。所以这种方法我就不介绍了。</p>
</li>
<li><p>另一种方法就是父进程直接忽略子进程的信号，具体做法很简单，在主程序中增加以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//忽略子进程的信号，避免成为僵尸进程</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>signal库函数的用法暂时不介绍，以后有详细说明。</p>
<h3 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h3><p>在学习了多进程的基础知识之后，初学者可能会认为多进程是一个高大上的技术，认为多进程处理数据肯定比单进程快，其实不是。在实际开发中，采用多进程的主要目的是处理多个并发的任务，而不是为了提高程序的效率。</p>
<p>从效率方面来说，多进程的效率比单进程要低，原因很简单，因为在有限的硬件资源中，多进程的内存开销更大，还会产生资源锁和竞争。</p>
<p>就像多个人端着一盆水，不如一个人端着一盆水走得快。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>linux多进程</title>
    <url>/2019/11/17/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>转自<a href="https://blog.csdn.net/wucz122140729/article/details/98586806" target="_blank" rel="noopener">linux多进程</a></p>
<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>什么是进程？进程这个概念是针对系统而不是针对程序员的，对程序员来说，我们面对的概念是程序。当程序员敲入命令执行一个程序的时候，对系统而言，它将启动一个进程。进程就是正在内存中运行中的程序。</p>
<a id="more"></a>

<p>Linux下一个进程在内存里有三部分的数据，就是“代码段”、”堆栈段”和”数据段”。”代码段”，顾名思义，就是存放了程序代码。“堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。而“数据段”则存放程序的全局变量，常数以及动态数据分配的数据空间（比如用new函数分配的空间）。</p>
<p>系统如果同时运行多个相同的程序，它们的“代码段”是相同的（因为代码是已经固定不变的），“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。 </p>
<h2 id="进程的编号"><a href="#进程的编号" class="headerlink" title="进程的编号"></a>进程的编号</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前终端的进程</span></span><br><span class="line">ps</span><br><span class="line"><span class="comment"># 查看系统全部的进程。</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="comment"># 查看系统全部的进程，结果分页显示。</span></span><br><span class="line">ps -ef | more</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ps</code><br><img src="l1.png" alt="ps"></p>
</li>
<li><p><code>ps -ef</code><br><img src="l2.png" alt="ps -ef"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>UID</td>
<td>启动进程的操作系统用户。</td>
</tr>
<tr>
<td>PID</td>
<td>进程编号。</td>
</tr>
<tr>
<td>PPID</td>
<td>进程的父进程的编号。</td>
</tr>
<tr>
<td>C</td>
<td>CPU使用的资源百分比。</td>
</tr>
<tr>
<td>STIME</td>
<td>进程启动时间。</td>
</tr>
<tr>
<td>TTY</td>
<td>进程所属的终端。</td>
</tr>
<tr>
<td>TIME</td>
<td>使用掉的CPU时间。</td>
</tr>
<tr>
<td>CMD</td>
<td>执行的是什么指令。</td>
</tr>
</tbody></table>
<ul>
<li><code>ps -ef | grep book</code>查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录。程序员用得最多的指令就是这个了。</li>
</ul>
<h3 id="getpid库函数"><a href="#getpid库函数" class="headerlink" title="getpid库函数"></a>getpid库函数</h3><blockquote>
<p>getpid库函数的功能是获取本程序运行时进程的编号。</p>
<ul>
<li>包含头文件：</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数没有参数，返回值是进程的编号，<code>pid_t</code>就是<code>typedef int pid_t</code></p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我的进程号是%d\n"</span>, getpid());</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// sleep(10)是为了方便查看进程。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="l3.png" alt="运行"></p>
</blockquote>
<p>终端查看<br><img src="l4.png" alt="终端"></p>
<ul>
<li>注意两个细节：<ul>
<li>进程的编号是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。</li>
<li>进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。</li>
</ul>
</li>
</ul>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork函数，这段程序演示了使用fork的基本框架。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>fork函数用于产生一个新的进程，函数返回值<code>pid_t</code>是一个整数，原有的进程称为<strong>父进程</strong>，新产生的进程称为<strong>子进程</strong>，在父进程中，返回值仍为进程编号，在子进程中，返回值是0。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程编号是：%d\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> ipid = fork();  <span class="comment">//创建一个新的进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ipid=%d\n"</span>, ipid);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(ipid!=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程编号是:%d\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程编号是:%d\n"</span>, getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="l5.png" alt="fork"></p>
</blockquote>
<p>查看进程情况，出现了两个book进程。<br><img src="l6.png" alt="fork"></p>
<blockquote>
<p>初学者可能用点接受不了现实。</p>
<ul>
<li>一个函数（fork）返回了两个值？</li>
<li>if和else中的代码能同时被执行？</li>
</ul>
</blockquote>
<p>那么调用这个fork函数时发生了什么呢？fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。</p>
<p>fork函数对返回值做了特别的处理，调用fork函数之后，在子程序中fork的返回值是0，在父进程中fork的返回值仍是原进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。</p>
<p>在上文上已提到过，子进程拷贝了父进程的堆栈段和数据段，也就是说，在父进程中定义的变量子进程中会复制一个副本，fork之后，<strong>子进程对变量的操作不会影响交父进程，父进程对变量的操作也不会影响子进程</strong></p>
<ul>
<li>示例：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatchfunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//父进程的业务主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">childfunc</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//子进程的业务主函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"执行父进程代码\n"</span>);</span><br><span class="line">        fatchfunc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"执行子进程代码\n"</span>);</span><br><span class="line">        childfunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatchfunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是父进程:num=%d\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">childfunc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是子进程:num=%d\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果：<br><img src="l7.png" alt="多进程"></p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS7防火墙相关指令</title>
    <url>/2019/11/16/centOS7%E9%98%B2%E7%81%AB%E5%A2%99%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.csdn.net/m0_37779570/article/details/81979073" target="_blank" rel="noopener">Centos7查看防火墙对应的开放端口</a></p>
<a id="more"></a>
<h3 id="查看已经开放的端口"><a href="#查看已经开放的端口" class="headerlink" title="查看已经开放的端口"></a>查看已经开放的端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<h3 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>

<ul>
<li>命令含义:<br>–zone #作用域<br>–add-port=80/tcp #添加端口，格式为：端口/通讯协议<br>–permanent #永久生效，没有此参数重启后失效</li>
<li>开启端口后记得重启<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall -cmd --reload</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="防火墙其他命令"><a href="#防火墙其他命令" class="headerlink" title="防火墙其他命令"></a>防火墙其他命令</h3><ul>
<li><p>停止firewall  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止firewall开机启动  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>关于sockaddr与sockaddr_in详解</title>
    <url>/2019/11/15/%E5%85%B3%E4%BA%8Esockaddr%E4%B8%8Esockaddr-in%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qingzhuyuxian/article/details/79736821" target="_blank" rel="noopener">详解</a></p>
<p>总的来说就是后者弥补了前者的一些缺陷，但是由于某些函数需要传入sockaddr类型的数据，可以用sockaddr_in赋值后，强转为sockaddr作为参数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>socket通信二</title>
    <url>/2019/11/14/socket%E9%80%9A%E4%BF%A1%E4%BA%8C/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="C语言socket编程说明"><a href="#C语言socket编程说明" class="headerlink" title="C语言socket编程说明"></a>C语言socket编程说明</h3><h4 id="服务端程序绑定地址"><a href="#服务端程序绑定地址" class="headerlink" title="服务端程序绑定地址"></a>服务端程序绑定地址</h4><p>一般情况下，服务器有多个网卡，多个IP地址，socket通信可以指定用哪个地址来进行通信，对于程序员有两种选择</p>
<ul>
<li><p>任意IP地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//本主机的任意IP地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定IP地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m_servaddr.sin_addr.s_addr = inet_addr(<span class="string">"100.100.100.100"</span>);  <span class="comment">//指定IP地址</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="绑定通信端口"><a href="#绑定通信端口" class="headerlink" title="绑定通信端口"></a>绑定通信端口</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m_servaddr.sin_port = htons(<span class="number">6789</span>);  <span class="comment">//绑定端口</span></span><br></pre></td></tr></table></figure>

<h4 id="客户端程序指定服务端的IP地址"><a href="#客户端程序指定服务端的IP地址" class="headerlink" title="客户端程序指定服务端的IP地址"></a>客户端程序指定服务端的IP地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hptr</span>;</span>  <span class="comment">//IP地址的结构体指针</span></span><br><span class="line"><span class="keyword">if</span>((hptr=gethostbyname(<span class="string">"100.100.100.100"</span>))==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">"gethostbyname"</span>);</span><br><span class="line">    close(sockfd);  <span class="comment">//sockfd指客户端的套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h4><p>send函数用于把数据通过socket发送给对端。不论是客户端还是服务端，应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</p>
<ul>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> send (<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sockfd为已建立好连接的socket。<br>buf为需要发送的数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，内存中有什么就发送什么。<br>len需要发送的数据的长度，为buf中有效数据的长度。<br>flags填0, 其他数值意义不大。<br>函数返回已发送的字符数。出错时返回-1，错误信息errno被标记。<br>注意，就算是网络断开，或socket已被对端关闭，send函数不会立即报错，要过几秒才会报错。<br>如果send函数返回的错误（&lt;=0），表示通信链路已不可用。</p>
<h4 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a>recv函数</h4><p>recv函数用于接收对端socket发送过来的数据。</p>
<ul>
<li><p>包含头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recv (<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sockfd为已建立好连接的socket。<br>buf为用于接收数据的内存地址，可以是C语言基本数据类型变量的地址，也可以数组、结构体、字符串，只要是一块内存就行了。<br>len需要接收数据的长度，不能超过buf的大小，否则内存溢出。<br>flags填0, 其他数值意义不大。<br>如果socket的对端没有发送数据，recv函数就会等待，如果对端发送了数据，函数返回接收到的字符数。出错时返回-1，错误信息errno被标记。如果socket被对端关闭，返回值为0。<br>如果recv函数返回的错误（&lt;=0），表示通信链路已不可用。</p>
<h4 id="服务端有多个socket"><a href="#服务端有多个socket" class="headerlink" title="服务端有多个socket"></a>服务端有多个socket</h4><p>对服务端来说，有多个socket，一个是用于监听的socket，还有一个就是客户端连接成功后，由<strong>accept函数创建的</strong>用于与客户端收发报文的socket。如果有多个客户端连接，就会有多个socket。</p>
<h4 id="程序退出时先关闭socket"><a href="#程序退出时先关闭socket" class="headerlink" title="程序退出时先关闭socket"></a>程序退出时先关闭socket</h4><p>socket是系统资源，操作系统打开的socket数量是有限的，在程序退出之前必须关闭已打开的socket，就像关闭文件指针一样，就像delete已分配的内存一样，极其重要。<br>值得注意的是，关闭socket的代码不能只在main函数的最后，那是程序运行的理想状态，还应该在main函数的每个return之前关闭。</p>
<h3 id="相关的库函数"><a href="#相关的库函数" class="headerlink" title="相关的库函数"></a>相关的库函数</h3><h4 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h4><p>socket函数用于创建一个新的socket，也就是向系统申请一个socket资源。socket函数用户客户端和服务端。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数说明：</p>
<p>domain：协议域，又称协议族（family）。常用的协议族有AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域Socket）、AF_ROUTE等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p>
<p>type：指定socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等。流式socket（SOCK_STREAM）是一种面向连接的socket，针对于面向连接的TCP服务应用。数据报式socket（SOCK_DGRAM）是一种无连接的socket，对应于无连接的UDP服务应用。</p>
<p>protocol：指定协议。常用协议有IPPROTO_TCP、IPPROTO_UDP、IPPROTO_STCP、IPPROTO_TIPC等，分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p>
<blockquote>
<p>说了一大堆废话，第一个参数只能填AF_INET，第二个参数只能填SOCK_STREAM，第三个参数只能填0。</p>
</blockquote>
<p>除非系统资料耗尽，socket函数一般不会返回失败。</p>
<h4 id="gethostbyname函数"><a href="#gethostbyname函数" class="headerlink" title="gethostbyname函数"></a>gethostbyname函数</h4><p>把ip地址或域名转换为hostent 结构体表达的地址。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数name，域名或者主机名，例如”192.168.1.3”、”<a href="http://www.google.com&quot;等。" target="_blank" rel="noopener">www.google.com&quot;等。</a><br>返回值：如果成功，返回一个hostent结构指针，失败返回NULL。<br>gethostbyname只用于客户端。</p>
<p>gethostbyname只是把字符串的ip地址转换为结构体的ip地址，只要地址格式没错，一般不会返回错误。函数失败不会设置errno的值。</p>
<h4 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h4><p>向服务器发起连接请求。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr * serv_addr, <span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数说明：connect函数用于将参数sockfd 的socket 连至参数serv_addr 指定的服务端，参数addrlen为sockaddr的结构长度。<br>返回值：成功则返回0, 失败返回-1, 错误原因存于errno 中。<br>connect函数只用于客户端。<br>如果服务端的地址错了，或端口错了，或服务端没有启动，connect一定会失败。</p>
<h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><p>服务端把用于通信的地址和端口绑定到socket上。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数sockfd，需要绑定的socket。<br>参数addr，存放了服务端用于通信的地址和端口。<br>参数addrlen表示addr结构体的大小。<br>如果绑定的地址错误，或端口已被占用，bind函数一定会报错，否则一般不会返回错误。</p>
<h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><p>listen函数把主动连接套接口变为被连接套接口，使得这个socket可以接受其它socket的连接请求，从而成为一个服务端的socket。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回：0──成功， -1──失败</p>
<p>参数sockfd是已经被bind过的套接字。socket函数返回的套接字是一个主动连接的套接字，在服务端的编程中，程序员希望这个套接字可以接受外来的连接请求，也就是被动等待客户端来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，程序员通过调用listen函数来完成这件事。</p>
<p>参数backlog，这个参数涉及到一些网络的细节，比较麻烦，填5、10都行，一般不超过30。<br>当调用listen之后，服务端的套接字就可以调用accept来接受客户端的连接请求。<br>listen函数一般不会返回错误。</p>
<h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><p>服务端接受客户端的连接。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr *addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数sockfd是已经被listen过的套接字。<br>参数addr用于存放客户端的地址信息，用sockaddr结构体表达，如果不需要客户端的地址，可以填0。<br>参数addrlen用于存放addr参数的长度，如果addr为0，addrlen也填0。<br>accept函数等待客户端的连接，如果没有客户端连上来，它就一直等待，这种方式称之为<strong>阻塞</strong>。<br>accept等待到客户端的连接后，创建<strong>一个新的套接字</strong>，函数返回值就是这个新的套接字，服务端使用这个新的套接字和客户端进行报文的收发。<br>accept在等待的过程中，如果被中断或其它的原因，函数返回-1，表示失败，如果失败，可以重新accept。</p>
<h3 id="函数小结"><a href="#函数小结" class="headerlink" title="函数小结"></a>函数小结</h3><p>服务端函数调用的流程是：socket-&gt;bind-&gt;listen-&gt;accept-&gt;recv/send-&gt;close<br>客户端函数调用的流程是：socket-&gt;connect-&gt;send/recv-&gt;close</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>socket通信一</title>
    <url>/2019/11/13/socket%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="http://www.duguosheng.xyz/2019/09/12/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" target="_blank" rel="noopener">一些基本概念</a></p>
<p><a href="http://www.duguosheng.xyz/2019/11/14/socket%E9%80%9A%E4%BF%A1%E4%BA%8C/" target="_blank" rel="noopener">C语言中需要注意的socket编程知识</a></p>
<ul>
<li>C语言实现socket通信<blockquote>
<p><code>_public.h</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PUBLIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_ADDR <span class="meta-string">"100.100.100.100"</span>  <span class="comment">//这里填写本机IP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_PORT 7890  <span class="comment">//指定端口</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketClient</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketServe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>socket_serve.cpp</code><br>这是服务器的程序，服务器的流程包括</p>
<ul>
<li>服务端要先启动，准备好一个通信通道，表示可以在某地址和端口上可以接收客户连接。</li>
<li>等待客户端的连接请求。</li>
<li>等待并接收客户端发过来的数据，处理该客户的数据，处理完成后，向客户端返回处理结果。</li>
<li>不断的重复第上一步，直到客户端断开连接。</li>
<li>关闭服务端</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(SocketServe()==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketServe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建服务器用于监听的socket</span></span><br><span class="line">    <span class="comment">//把服务端用于通信的地址和端口绑定到socket上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  <span class="comment">//服务器地址信息的数据结构</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;  <span class="comment">//协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//本主机的任意IP</span></span><br><span class="line">    <span class="comment">//servaddr.sin_addr.s_addr = inet_addr(IP_ADDR);  //绑定指定的地址</span></span><br><span class="line">    servaddr.sin_port = htons(IP_PORT);  <span class="comment">//绑定通信端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把socket设定为监听模式</span></span><br><span class="line">    <span class="keyword">if</span>(listen(listenfd, <span class="number">5</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        close(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端的连接</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;  <span class="comment">//客户端的socket</span></span><br><span class="line">    <span class="keyword">int</span> socklen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span>  <span class="comment">//客户端的地址信息</span></span><br><span class="line">    clientfd = accept(listenfd, (struct sockaddr *)&amp;clientaddr, (<span class="keyword">socklen_t</span> *)&amp;socklen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"客户端%s已连接\n"</span>, inet_ntoa(clientaddr.sin_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与客户端通信，接收客户端发过来的报文后，回复OK</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span>(recv(clientfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"接收：%s\n"</span>, buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, <span class="string">"OK"</span>);</span><br><span class="line">        <span class="keyword">if</span>(send(clientfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"发送：%s\n"</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(clientfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>serve_client.cpp</code><br>这是客户端的程序，客户端的流程为</p>
<ul>
<li>打开一个通信通道，连接到服务端已准备好的端口。</li>
<li>向服务端发送数据，等待并接收服务端处理结果。</li>
<li>不断的重复第上一步，直到全部的数据被处理完。</li>
<li>关闭与服务器的连接。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"_public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(SocketClient()==<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SocketClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建客户端的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hptr</span>;</span>  <span class="comment">//ip地址的结构体</span></span><br><span class="line">    <span class="keyword">if</span>((hptr=gethostbyname(IP_ADDR))==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"gethostbyname"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把服务器的地址和端口转换为结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(IP_PORT);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, hptr-&gt;h_addr, hptr-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//项服务器发起连接请求</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr))!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str_buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务段通讯，发送一个报文后等待回复，然后发送下一个报文</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(str_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(str_buffer));</span><br><span class="line">        <span class="built_in">sprintf</span>(str_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(str_buffer));</span><br><span class="line">        <span class="built_in">sprintf</span>(str_buffer, <span class="string">"这是第%d个报文"</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(send(sockfd, str_buffer, <span class="built_in">strlen</span>(str_buffer), <span class="number">0</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"发送：%s\n"</span>, str_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(str_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(str_buffer));</span><br><span class="line">        <span class="keyword">if</span>(recv(sockfd, str_buffer, <span class="keyword">sizeof</span>(str_buffer), <span class="number">0</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"接收：%s\n"</span>, str_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分别在两个终端窗口下运行代码即可看到效果</p>
</blockquote>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的多态</title>
    <url>/2019/11/13/C-%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/wucz122140729/article/details/98583135" target="_blank" rel="noopener">类的多态</a></p>
<a id="more"></a>
<ul>
<li>虚函数</li>
<li>纯虚函数</li>
<li>接口</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的继承</title>
    <url>/2019/11/12/C-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象程序设计中最重要的一个概念。继承允许我们根据一个类来定义另一个类，达到了代码功能重用效果。<br>当创建一个类时，如果待创建的类与另一个类存在某些共同特征，程序员不需要全部重新编写成员变量和成员函数，只需指定继承另一个类即可，被继承的类称为基类或父类，新建的类称为派生类或子类。</p>
<h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>定义一个派生类，需要指定它的基类，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>

<p>derived-class：派生类名。<br>access-specifie：访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。<br>base-class：基类名</p>
<ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动物叫"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> color[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat *cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat-&gt;shout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">动物叫</span><br></pre></td></tr></table></figure>

<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>派生类可以访问基类中所有的非私有成员变量和成员函数，如果基类的成员变量和成员函数不想被派生类访问，则应在基类中声明为 private。</p>
<h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><p>公有继承（public）：当类派生以public方式继承时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p>
</li>
<li><p>保护继承（protected）： 当类派生以protected方式继承时，基类的公有和保护成员将成为派生类的保护成员。</p>
</li>
<li><p>私有继承（private）：当类派生以private方式继承时，基类的公有和保护成员将成为派生类的私有成员。</p>
</li>
</ul>
<h3 id="基类与派生类的指针"><a href="#基类与派生类的指针" class="headerlink" title="基类与派生类的指针"></a>基类与派生类的指针</h3><p>基类的指针可以指向基类对象。<br>派生类的指针可以指向派生类对象。<br>基类的指针可以指向派生类对象，但是不能通过基类的指针访问派生类的成员。<br>派生类的指针不可以指向基类对象。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个派生类可以有多个基类，它继承了多个基类的特性。<br>C++ 类可以从多个基类继承成员，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态内存和运算符重载</title>
    <url>/2019/11/12/C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98582590" target="_blank" rel="noopener">动态内存</a></p>
<p><a href="https://blog.csdn.net/wucz122140729/article/details/98582930" target="_blank" rel="noopener">运算符重载</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>动态内存</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>vector容器</title>
    <url>/2019/11/09/vector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98582170" target="_blank" rel="noopener">码农有道</a></p>
<a id="more"></a>

<p>之前我们在声明数组的时候，采用的是datatype  array[len]的形式，数组在分配之后，不能调整大小，删除和插入数据时操作十分的繁琐，虽然可以采用链表，但是链表的操作更麻烦，我喜欢简单的方法。</p>
<p>与string类一样, 向量vector 同属于STL（Standard Template Library, 标准模板库）中的自定义的类, vector是一个封装了动态数组的顺序容器（Sequence Container）。跟其它类型的容器一样，它能够存放各种类型的数据和对象。可以简单的认为，vector容器是一个能够存放任意类型的动态数组。</p>
<p>与数组相比，vector 容器的优点在于它能够根据需要自动调整的大小，随时放入更多的元素。此外, vector 也提供了许多的成员函数来对自身进行操作。</p>
<h3 id="容器的定义"><a href="#容器的定义" class="headerlink" title="容器的定义"></a>容器的定义</h3><p>首先，如果要在程序中使用vector容器，必须包含头文件<code>&lt;vector&gt;</code>。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>vector类是一个模板类，位于std命名空间内，为方便使用还需要增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>声明一个容器很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;              <span class="comment">// 定义用于存放整数的容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vd;         <span class="comment">// 定义用于存放浮点数的容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;           <span class="comment">// 定义用于存放string字符串的容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;struct st_girl&gt; vgirl;  <span class="comment">// 定义用于存放超女结构体的容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;CGirl&gt; vGirl;         <span class="comment">// 定义用于存放超女类的容器</span></span><br></pre></td></tr></table></figure>

<p>vector容器可以存放C语言的基本数据类型，可以存放结构体，还可以存放类，这正是我们想要的简单的方法，至于链表，我已经有二十年没有用它了。</p>
<h3 id="容器的使用"><a href="#容器的使用" class="headerlink" title="容器的使用"></a>容器的使用</h3><p>vector的功能强大，成员函数很多，我不想按普通教程的方式来介绍它，那样会太烦锁，我回忆了二十年来的实际应用场景，采用示例程序介绍vector常用的用法。</p>
<h4 id="存放整数"><a href="#存放整数" class="headerlink" title="存放整数"></a>存放整数</h4><ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       //vector需要的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    //sort需要的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vheight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入超女的身高(0-结束输入)："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;height);</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vheight.push_back(height);  <span class="comment">//把数据追加入容器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vheight.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"vheight[%d]=%d\n"</span>, i, vheight[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(vheight.begin(), vheight.end());  <span class="comment">//容器中的记录排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vheight.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"vheight[%d]=%d\n"</span>, i, vheight[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vheight.clear();  <span class="comment">//清空容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入超女的身高(0-结束输入)：166</span><br><span class="line">请输入超女的身高(0-结束输入)：165</span><br><span class="line">请输入超女的身高(0-结束输入)：170</span><br><span class="line">请输入超女的身高(0-结束输入)：0</span><br><span class="line">vheight[0]=166</span><br><span class="line">vheight[1]=165</span><br><span class="line">vheight[2]=170</span><br><span class="line">vheight[0]=165</span><br><span class="line">vheight[1]=166</span><br><span class="line">vheight[2]=170</span><br></pre></td></tr></table></figure>

<ul>
<li>程序解释如下：<br><code>std::vector&lt;int&gt; vheight;</code>   声明容器用于存放整数，超女身高，单位是cm。</li>
</ul>
<p><code>void push_back(const T&amp; x)</code>成员函数：向容器尾部增加一个元素x，x就是你要向容器中增加的变量，在本示例中是一个整数，注意，参数x是一个引用，要用变量的名称，不是变量的地址，如vheight.push_back(height);。</p>
<p><code>int size()</code>成员函数：返回容器中数据的元素总数。</p>
<p>像数组一样访问容器：容器像数组一样，可以用数组的下标访问，vheight[0]表示容器的第1个元素，vheight[n]表示容器的第n+1个元素。注意，采用下标方式放问容器的时候，下标不要越界，否则可能会引起内存溢出。</p>
<p><code>iterator begin()</code>成员函数：返回容器头指针，指向第一个元素。</p>
<p><code>iterator end()</code>成员函数：返回容器尾指针，指向容器最后一个元素的下一个位置。</p>
<p><code>sort()</code>容器中的元素排序：采用sort()函数对容器中的元素进行排序。如sort(vheight.begin(),vheight.end());表示对容器中全部的元素进行排序。</p>
<p><code>void clear()</code>：清空容器中的全部元素，注意两点：1）容器被声明的时候，本来就是空的；2）容器是类，有析构函数，析构函数中会自动清空容器中的元素，释放内存资源，不需要程序员担心。但是，程序员也可以调clear()函数手工清空容器中的元素。</p>
<p>示例程序展示了vector容器10%的功能和成员函数，但是，在实际开发中，对容器的操作，95%的内容就是这些。</p>
<h4 id="存放字符串"><a href="#存放字符串" class="headerlink" title="存放字符串"></a>存放字符串</h4><p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strtmp[<span class="number">50</span>];  <span class="comment">//存放姓名的临时变量</span></span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">//存放键盘输入的名字</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vname;  <span class="comment">//存放姓名的容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入姓名(0-结束输入):"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, strtmp);  <span class="comment">//接收键盘输入</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(strtmp, <span class="string">"0"</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//结束输入</span></span><br><span class="line">        vname.push_back(strtmp);  <span class="comment">//把数据加入容器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vname.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"vname[%d]=%s\n"</span>, i, vname[i].c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入姓名(0-结束输入):张三</span><br><span class="line">请输入姓名(0-结束输入):李四</span><br><span class="line">请输入姓名(0-结束输入):王五</span><br><span class="line">请输入姓名(0-结束输入):赵六</span><br><span class="line">请输入姓名(0-结束输入):0</span><br><span class="line">vname[0]=张三</span><br><span class="line">vname[1]=李四</span><br><span class="line">vname[2]=王五</span><br><span class="line">vname[3]=赵六</span><br></pre></td></tr></table></figure>

<p>注意几个问题：</p>
<p>1）用容器存放字符串，数据类型用string，不是C语言用0结尾的字符数组char[]。</p>
<p>2）用vname.push_back()成员函数把数据追加到容器中，参数的类型可以是string，也可以是char[]，但是，这并不是vector的特征，而是string的特征，容器声明的是string类型，string的构造函数支持char []，表面上看push_back()进去的是char []，实际上会被转换为string。</p>
<p>3）对string和结构体等的排序，在以后的章节中会详细介绍。</p>
<h4 id="存放结构体"><a href="#存放结构体" class="headerlink" title="存放结构体"></a>存放结构体</h4><ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> age;        <span class="comment">//年龄</span></span><br><span class="line">&#125;PERSON;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PERSON per;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PERSON&gt; vper;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(per.name, <span class="string">"张三"</span>);</span><br><span class="line">    per.age = <span class="number">19</span>;</span><br><span class="line">    vper.push_back(per);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(per.name, <span class="string">"李四"</span>);</span><br><span class="line">    per.age = <span class="number">22</span>;</span><br><span class="line">    vper.push_back(per);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用数组下标访问容器中的记录</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vper.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"vper[%d].name=%s;vper[%d].age=%d\n"</span>,\</span><br><span class="line">                i, vper[i].name, i, vper[i].age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;per, <span class="number">0</span>, <span class="keyword">sizeof</span>(per));<span class="comment">//清空结构体</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vper.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"per%d.name=%s;per%d.age=%d\n"</span>,\</span><br><span class="line">                i, per.name, i, per.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vper.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;per, &amp;vper[i], <span class="keyword">sizeof</span>(per));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"per%d.name=%s;per%d.age=%d\n"</span>,\</span><br><span class="line">                i, per.name, i, per.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vper[0].name=张三;vper[0].age=19</span><br><span class="line">vper[1].name=李四;vper[1].age=22</span><br><span class="line">per0.name=;per0.age=0</span><br><span class="line">per1.name=;per1.age=0</span><br><span class="line">per0.name=张三;per0.age=19</span><br><span class="line">per1.name=李四;per1.age=22</span><br></pre></td></tr></table></figure>

<p>总的来说，存放结构体的容器和数组的用法基本相同。</p>
<p>在book225.cpp中，采用了memcpy函数，它是C语言的库函数，用于内存中的数据复制，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dest – 指向用于存储复制内容的目标地址，类型强制转换为<code>void*</code> 指针。<br>src – 指向要复制的数据源地址，类型强制转换为<code>void*</code> 指针。<br>n – 要被复制的字节数。</p>
<p>该函数返回dest。</p>
<h4 id="存放类"><a href="#存放类" class="headerlink" title="存放类"></a>存放类</h4><p>在第2节存放字符串中，string就是类。</p>
<p>vector容器可以存放类，但是在实际开发中，除了存放string类，很少用vector存放其它的类。</p>
<h3 id="其它成员函数"><a href="#其它成员函数" class="headerlink" title="其它成员函数"></a>其它成员函数</h3><p>vector的成员函数比较多，为了不增加各位的学习负担，我介绍一些可能有用的。</p>
<h4 id="定位的函数"><a href="#定位的函数" class="headerlink" title="定位的函数"></a>定位的函数</h4><p>iterator begin()：返回容器头的指针，指向容器第一个元素的位置。<br>iterator end()：返回容器尾的指针，指向容器最后一个元素的下一个位置。<br>iterator是跌代器，这个名字让人难以理解，大家不要管它，以下我会举例说明用法，一般来说，begin()和end()成员函数会用在其它成员函数的参数中。</p>
<h4 id="增加元素的函数"><a href="#增加元素的函数" class="headerlink" title="增加元素的函数"></a>增加元素的函数</h4><p>void push_back(const T&amp; x)：向容器的尾部增加一个元素x。<br>iterator insert(iterator it,const T&amp; x)：向容器中指定位置（it）前插入一个元素x。</p>
<p>示例：<br>strcpy(stgirl.name,”王昭群”); stgirl.age=22;<br>vgirl.insert(vgirl.begin()+1,stgirl);  // 在第2个元素前插入一个元素。</p>
<h4 id="删除元素的函数"><a href="#删除元素的函数" class="headerlink" title="删除元素的函数"></a>删除元素的函数</h4><p>iterator erase(iterator it)：删除容器中指定位置（it）的元素。</p>
<p>示例：<br>vgirl.erase(vgirl.begin()+2);  // 删除容器中第3个元素。<br>void pop_back()：删除容器中最后一个元素。<br>void clear()：清空容器中全部的元素。</p>
<h4 id="判断容器的大小"><a href="#判断容器的大小" class="headerlink" title="判断容器的大小"></a>判断容器的大小</h4><p>bool empty()：判断容器是否为空。<br>int size()：返回容器中元素的个数。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的string类</title>
    <url>/2019/11/09/C-%E7%9A%84string%E7%B1%BB/</url>
    <content><![CDATA[<a id="more"></a>
<p>在C语言中，用0结尾的字符数组表示字符串，C的字符串有一个问题，就是定义后大小不能改变，存入的内容只能比数组小，不能大，如果不小心存多了，会引起内存的溢出，这个问题让程序员很郁闷。</p>
<p>C++的string部分的解决了这个问题，它会随存放字符的长度自动伸缩，程序员不必担心内存溢出的问题。string类还和c语言的字符串之间可以转换。</p>
<h3 id="string的声明"><a href="#string的声明" class="headerlink" title="string的声明"></a>string的声明</h3><p>首先，为了在程序中使用string类，必须包含头文件 <string>。如下：</string></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意这里不是string.h，string.h是C字符串头文件。<br>string类是一个模板类，位于std命名空间内，为方便使用还需要在程序中增加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>

<p>创建一个string字符串对象很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br></pre></td></tr></table></figure>

<p>如果不指定命名空间，也就是说没有using namespace std，创建字符串对象的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br></pre></td></tr></table></figure>

<h3 id="string的赋值"><a href="#string的赋值" class="headerlink" title="string的赋值"></a>string的赋值</h3><ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    str = <span class="string">"小明"</span>;  <span class="comment">//直接用=赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());  <span class="comment">//下面讲c_str()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="string的重载的操作符"><a href="#string的重载的操作符" class="headerlink" title="string的重载的操作符"></a>string的重载的操作符</h3><blockquote>
<p>可以用=直接赋值。<br>可以用 ==、&gt;、&lt;、&gt;=、&lt;=、和!=比较字符串。<br>可以用+或者+=操作符连接两个字符串。<br>可以用[]获取特定的字符，类似数组。</p>
</blockquote>
<p>最重要的一个成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回一个以NULL结尾的c字符串，即c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同，用于string转<code>const char*</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1;</span><br><span class="line">str1=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">31</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str2,str1.c_str());</span><br></pre></td></tr></table></figure>

<h3 id="string特性描述函数"><a href="#string特性描述函数" class="headerlink" title="string特性描述函数"></a>string特性描述函数</h3><p>可用下列函数来获得string的一些特性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;             <span class="comment">// 返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;           <span class="comment">// 返回当前字符串的长度,结果和上面的size()一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;           <span class="comment">// 清空字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>string的其它成员函数<br>string提供了上百个成员函数，非常丰富，丰富得有点眼花，各位自己找资料，有空的时候再研究一下，断章取义的使用，注意，是有空的时候。</li>
</ul>
<h3 id="string的本质"><a href="#string的本质" class="headerlink" title="string的本质"></a>string的本质</h3><p>string是一个类，通过动态分配内存，实现对字符串的存储，我们来看以下代码。</p>
<ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    str = <span class="string">"aaaaaaaaaaaaaaa"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, str.c_str());</span><br><span class="line">    str += <span class="string">"bbbb"</span>;  <span class="comment">//字符串增大，需要新的内存空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, str.c_str());</span><br><span class="line">    str = <span class="string">"cccc"</span>;  <span class="comment">//字符串减小，无须开辟新内存空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, str.c_str());</span><br><span class="line">    str = <span class="string">"dhasjhkashdjsadsadasdashdkhsaddjas"</span>;  <span class="comment">//字符串增大，需要开辟新内存空间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, str.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7ffc20fc1e80</span><br><span class="line">0x5586c80742c0</span><br><span class="line">0x5586c80742c0</span><br><span class="line">0x5586c80742f0</span><br></pre></td></tr></table></figure>

<p>通过以上的例子，我们可以看到，string对象用于存放字符的内存地址是变化的，不是什么神奇的技术。</p>
<h3 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h3><p>C++的string类是一个变长的字符串，不需要程序员担心内存溢出的问题，还提供了很多字符串操作函数，初学者可能会想，用它取代C语言中的字符串（以0结尾的字符数组）一定是个很好的主意。我要告诉各位，这是不可能的，因为string中的字符串存储的内存空间没有固定的位置（它也没办法有固定位置）。</p>
<p>对初学者来说，只会用C和C++写一些简单的程序，做一些简单的事情，不懂得实际开发的需求，例如Oracle和MySQL数据库提供的接口，在数据交换的时候需要绑定一个固定的地址，string是做不到的。</p>
<p>我的建议是采用string存放一些需要动态分配内存的临时数据，避开动态内存技术带来的坑，然后转换为C的字符串。C的字符串没有string类那么丰富的成员函数，这个不是问题，我们可以自己写，这也是我不想介绍string成员函数的原因，与其花时间去研究string的成员函数，还不如自己写一个。</p>
<p>所以，了解string类的原理和一些用得着的成员函数就可以了，不必太深入研究，意义不大。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>string类</tag>
      </tags>
  </entry>
  <entry>
    <title>C++引用</title>
    <url>/2019/11/09/C-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<a id="more"></a>

<p>转自<a href="https://blog.csdn.net/wucz122140729/article/details/98477620" target="_blank" rel="noopener">码农有道</a><br>  对于习惯使用C进行开发的程序员来说，在看到C++中出现的&amp;符号，可能会犯迷糊，因为在C语言中这个符号表示了取地址符，但是在C++中，它除了取地址，还有其它的用途，叫做引用（reference），引用是C++引入的新语言特性。</p>
<h3 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h3><p>引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。</p>
<ul>
<li>引用的声明方法：类型标识符 &amp;引用名=目标变量名；<br>例如：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;ra=a;  <span class="comment">// 定义引用ra，它是变量a的引用，即别名。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明：<br>1）&amp;在此不是求地址运算，而是起标识作用。<br>2）类型标识符是指目标变量的类型。<br>3）声明引用时，必须同时对其进行初始化，否则编译器会报错。<br>4）引用声明后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ra=<span class="number">1</span>;  <span class="comment">//等价于  a=1;</span></span><br></pre></td></tr></table></figure>

<p>5）声明一个引用，不是新定义了一个新的变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。</p>
<ul>
<li>引用可以用const修饰，表示只读，用这种方式声明的引用，不能通过引用对目标变量的值进行修改。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ra=a;</span><br><span class="line">a=<span class="number">10</span>;    <span class="comment">// 可以</span></span><br><span class="line">ra=<span class="number">10</span>;   <span class="comment">// 不行</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h3><p>引用的主要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案是数据的地址。但是在C++中，又增加了一种同样有效率的选择，就是引用。</p>
<ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    print_num(number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其执行过程相当于</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;num = number;</span><br><span class="line">    num = <span class="number">20</span>;  <span class="comment">// 改变引用的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, number);</span><br></pre></td></tr></table></figure>

<p>从以上的示例可以看出，<strong>传递引用给函数与传递指针的效果是一样的</strong>。这时，被调函数的参数就成为调用者调函数中的变量或对象的一个别名来使用，所以在被调函数中对引用的操作就是对目标变量的操作。</p>
<ul>
<li>引用的优点：<br>引用传递（pass by refenrence），在内存中没有产生形参。效率提高！也不用处理指针的析构问题。</li>
</ul>
<p>在很多资料中，把引用的优点过于夸大，在我看来，引用的好处就是调用函数的时候，不用填写取地址符&amp;，子函数中也不写取变量符<code>*</code>，结构体和类不用-&gt;取成员。我更倾向传递地址的方式，因为更直观，不管是在函数内部还是函数被调用的地方，一眼就能清楚是否是地址。</p>
<p>引用还可以作为函数的返回值，但我不建议这么用，我实在看不出这样做有什么好处，那就没必要把事情搞得那么复杂，所以这里就不介绍了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类的详解</title>
    <url>/2019/11/09/C-%E7%B1%BB%E7%9A%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<a id="more"></a>
<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98477574" target="_blank" rel="noopener">码农有道</a></p>
<h3 id="封装文件类"><a href="#封装文件类" class="headerlink" title="封装文件类"></a>封装文件类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件操作类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        FILE *m_fp;  <span class="comment">// 文件指针</span></span><br><span class="line">        <span class="keyword">bool</span> m_bEnBuffer;  <span class="comment">// 是否启用缓冲区，true-启用，false-不启用</span></span><br><span class="line">        <span class="keyword">char</span> m_filename[<span class="number">301</span>];  <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//类的构造函数</span></span><br><span class="line">        CFile();</span><br><span class="line">        <span class="comment">//启用，禁用缓冲区</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">EnBuffer</span><span class="params">(<span class="keyword">bool</span> bEnBuffer=<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="comment">//打开文件，成功返回true,失败返回false</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *openmode)</span></span>;</span><br><span class="line">        <span class="comment">//调用fprint向文件写入数据</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Fprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line">        <span class="comment">//调用fgets从文件中读取一行</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Fgets</span><span class="params">(<span class="keyword">char</span> *strBuffer, <span class="keyword">const</span> <span class="keyword">int</span> ReadSize)</span></span>;</span><br><span class="line">        <span class="comment">//关闭文件指针</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//类的析构函数</span></span><br><span class="line">        ~CFile();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。</p>
<h3 id="类成员的访问权限"><a href="#类成员的访问权限" class="headerlink" title="类成员的访问权限"></a>类成员的访问权限</h3><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是类外面的代码该类中成员权限。</p>
<p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</p>
<p>在类的外部（定义类的代码之外），只能通过对象访问public的成员，不能访问 private、protected 属性的成员。</p>
<p>本节重点介绍 public 和 private，protected 将在以后介绍。</p>
<p>private 后面的成员都是私有的，如m_fp和m_bEnBuffer，直到有 public 出现才会变成共有的；public 之后再无其他限定符，所以 public 后面的成员都是共有的。</p>
<p>private 关键字的作用在于更好地隐藏类的内部实现，该向外暴露的接口（能通过对象访问的成员）都声明为 public，不希望外部知道、或者只在类内部使用的、或者对外部没有影响的成员，都建议声明为 private。</p>
<p>声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为 private。</p>
<p>在一个类体中，private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。</p>
<p>你可能会说，将成员变量全部设置为 public 省事，确实，这样做 99.9% 的情况下都不是一种错误，我也不认为这样做有什么不妥；但是，将成员变量设置为 private 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。</p>
<h3 id="成员变量的命名"><a href="#成员变量的命名" class="headerlink" title="成员变量的命名"></a>成员变量的命名</h3><p>成员变量大都以<code>m_</code>开头，这是约定成俗的写法，不是语法规定的内容。以<code>m_</code>开头既可以一眼看出这是成员变量，又可以和成员函数中的参数名字区分开。</p>
<p>例如成员函数EnBuffer的函数体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFile::EnBuffer(<span class="keyword">bool</span> bEnBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    m_bEnBuffer = bEnBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在CFile类的声明中，有一个特殊的成员函数CFile()，它就是构造函数（constructor）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的构造函数</span></span><br><span class="line">CFile();</span><br></pre></td></tr></table></figure>

<p>构造函数的名字和类名相同，没有返回值，不能被显式的调用，而是在创建对象时自动执行。</p>
<p>构造函数具备以下特点：<br>1）构造函数必须是 public 属性。<br>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。</p>
<p>构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。但是，在实际开发中，我很少重载构造函数，一是程序写出来不漂亮，二是构造函数不能有返回值，能做的事情很有限，让其它的成员函数去做就是了。</p>
<p>构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，我基本上就是这么用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFile::CFile()</span><br><span class="line">&#123;</span><br><span class="line">    m_fp = <span class="number">0</span>;</span><br><span class="line">    m_bEnBuffer = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">memset</span>(m_filename, <span class="number">0</span>, <span class="keyword">sizeof</span>(m_filename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>在CFile类的声明中，还有一个特殊的成员函数~CFile()，它就是析构函数（destructor）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的析构函数</span></span><br><span class="line">~CFile();</span><br></pre></td></tr></table></figure>

<p>析构函数的名字在类的名字前加~，没有返回值，但可以被显式的调用，在对象销毁时自动执行，用于进行清理工作，例如释放分配的内存、关闭打开的文件等，这个用途非常重要，可以防止程序员犯错。</p>
<p>析构函数具备以下特点：<br>1）构造函数必须是 public 属性的。<br>2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。<br>析构函数不允许重载的。一个类只能有一个析构函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CFile::~CFile()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_fp!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(m_fp);  <span class="comment">// 关闭文件指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_fp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>我们已经介绍过printf、fprintf、sprintf、snprintf函数，它们是一组功能相似的函数，并且有一个共同点，就是函数的参数列表是可变的。</p>
<p>函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们的自定义函数也需要可变参数，实现类似上述函数的功能，例如CFile类的Fprintf成员函数，函数的声明和定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> CFile::Fprintf(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_fp==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    va_list vlist;              <span class="comment">//定义va_list指针</span></span><br><span class="line">    va_start(vlist, fmt);       <span class="comment">//根据fmt的格式，分析参数列表</span></span><br><span class="line">    <span class="built_in">vfprintf</span>(m_fp, fmt, vlist); <span class="comment">//将分析结果输出到文件</span></span><br><span class="line">    va_end(vlist);              <span class="comment">//释放va_liat指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(m_bEnBuffer==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>va_list指针、va_start宏、va_end宏难以理解，大家会抄就行，我不详细介绍，vfprintf函数把宏分析的结果输出到文件，还有一系列功能相似的函数，声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出的屏幕</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="comment">// 输出到字符串，第二个参数指定了输出结果的长度，类似snprintf函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可变参数的知识不只这些，但是，在实际开发中，我只见过用于格式化输出，其它的应用场景我没有见过。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象</title>
    <url>/2019/11/09/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<a id="more"></a>
<p>转自<a href="https://blog.csdn.net/wucz122140729/article/details/98477538" target="_blank" rel="noopener">码农有道</a></p>
<h3 id="C-类和对象"><a href="#C-类和对象" class="headerlink" title="C++ 类和对象"></a>C++ 类和对象</h3><p>C语言中结构体（struct）是一种构造类型，可以包含若干成员变量，可以通过结构体来定义结构体变量。</p>
<p>C++中的类（class）可以看成结构体的升级版，类也是一种构造类型，但是进行了一些扩展，类的成员不但可以有变量，还可以有函数，通过类定义出来的变量也有特定的称呼，叫做对象。</p>
<ul>
<li>示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Girl::Show()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"姓名：%s，年龄：%d， 身高：%lf\n"</span>,\</span><br><span class="line">            name, age, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Girl girl;</span><br><span class="line">    <span class="built_in">strcpy</span>(girl.name, <span class="string">"Mary"</span>);</span><br><span class="line">    girl.age = <span class="number">20</span>;</span><br><span class="line">    girl.height = <span class="number">168.4</span>;</span><br><span class="line">    girl.Show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="o1.png" alt="面向对象"></p>
</blockquote>
<p>class是C++的关键字，用于定义类，就像结构体中的sturct。<br>public也是C++中的关键字，用于指定权限。<br>C语言中的 struct 只能包含成员变量，而C++中的 class 除了可以包含成员变量，还可以包含成员函数，例如Show()。在C语言中，结构体和函数是分离的，通过函数的参数传递变量；而在C++中，成员变量和成员函数都放在class内部声明，是聚集在一起的，看起来更像一个整体，成员函数可以直接访问成员变量，不必传递参数。</p>
<p>类的成员变量和普通变量一样，也有数据类型和名称。与结构体一样，在定义类的时候也不能对成员变量赋值。</p>
<p><code>int CGirl::Show()</code>是类的成员函数的定义语法，在函数前加上类的名称和两个冒号，表示该函数是这个类的成员函数，函数的返回值、参数等语法和使用方法与C语言的普通函数相同。</p>
<p>在C++中，用类定义一个类变量叫做创建（或实例化）一个对象；某些资料中，把成员变量称为属性（property）；成员函数称为方法（method）。在我的教程中，将采用类、创建对象、成员变量和成员函数的称呼。</p>
<p>创建对象以后，可以使用点号.来访问成员变量和成员函数，这和通过结构体变量来访问它的成员一样。类的成员变量和成员函数的作用域和生命周期由对象的作用域和生命周期决定。</p>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>对象可以被定义成数组对象，本质上与其它类型的数组变量没有区别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CGirl Girl[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(Girl [<span class="number">0</span>].m_name,”杨玉环”);</span><br><span class="line">Girl [<span class="number">0</span>].m_age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们很少用对象数组。</p>
<h3 id="对象的指针"><a href="#对象的指针" class="headerlink" title="对象的指针"></a>对象的指针</h3><p>类是一种自定义的数据类型，对象也是内存变量，也有内存地址，当然也就有了类的指针。</p>
<p>在指针章节中我们已经学习过，采用不同数据类型的指针指向不同数据类型的变量的地址，这一规则也适用于对象。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CGirl queen;</span><br><span class="line">CGirl *pst=&amp; queen;</span><br><span class="line"><span class="comment">//通过类指针可以访问对象的成员，一般形式为：</span></span><br><span class="line">(*pointer).memberName</span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure>

<p>第一种写法中，圆点.的优先级高于<code>*</code>，<code>(*pointer)</code>两边的括号不能少。如果去掉括号写作<code>*pointer.memberName</code>，那么就等效于<code>*(pointer.memberName)</code>，这样意义就完全不对了。</p>
<p>第二种写法中，-&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过对象的指针直接访问对象的成员。</p>
<p>上面的两种写法是等效的，我们通常采用后面的写法，这样更加直观。</p>
<h3 id="对象作为函数的参数"><a href="#对象作为函数的参数" class="headerlink" title="对象作为函数的参数"></a>对象作为函数的参数</h3><p>与结构体一样，对象可以作为函数参数传递，最好的办法也是传递对象的地址。</p>
<h3 id="对象的初始化和占用内存的大小"><a href="#对象的初始化和占用内存的大小" class="headerlink" title="对象的初始化和占用内存的大小"></a>对象的初始化和占用内存的大小</h3><p>按我们以前的经验，定义的变量使用前要初始化，C语言的基本数据类型可以直接赋值0，字符串和结构体用memset函数初始化，那么类的对象呢？对象不能用memset初始化，具体做法我们以后再介绍。</p>
<p>对象可以用sizeof运算符获取占用内存的大小。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这个阶段，类就是一个有成员函数的结构体，定义的关键字和语法不同，使用方法完全相同。</p>
<p>各位可能会认为类好像没什么用，不用类也可以活得很好，这不一定，因为我现在只是用尽可能简单的方式介绍类的相关知识，在接下来的章节中也是如此，如果我把实际开发的方法搬到教材中，大家可能接受不了，在实际开发中，某些类的代码非常长，类的定义就有好几页，还不包括成员函数体。希望各位保持好的心态，循序渐进的学习。</p>
<h3 id="面向对象编程（Object-Oriented-Programming，OOP）"><a href="#面向对象编程（Object-Oriented-Programming，OOP）" class="headerlink" title="面向对象编程（Object Oriented Programming，OOP）"></a>面向对象编程（Object Oriented Programming，OOP）</h3><p>类是一个通用的概念，C++、Java、C#、PHP 等很多编程语言中都支持类，都可以通过类创建对象。因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。</p>
<p>在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，而在C++中，多了一层封装，就是类（class），不要小看类（class）这一层封装，它有很多特性，极大地方便了程序员的开发，也让C++成为面向对象的语言。</p>
<p>面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数重载</title>
    <url>/2019/11/08/C-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="重载概念"><a href="#重载概念" class="headerlink" title="重载概念"></a>重载概念</h3><p>重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。这就是重载函数。重载函数常用来实现功能类似而所处理的数据类型不同的问题。不能只有函数返回值类型不同。</p>
<h3 id="C-实现函数重载原理"><a href="#C-实现函数重载原理" class="headerlink" title="C++实现函数重载原理"></a>C++实现函数重载原理</h3><p>C++代码在编译时会根据参数列表对函数进行重命名，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writetofile</span><span class="params">(<span class="keyword">char</span> *filename,<span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>重命名为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> _writetofile_char_int(<span class="keyword">char</span> *filename,<span class="keyword">int</span> value);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writetofile</span><span class="params">(<span class="keyword">char</span> *filename,<span class="keyword">long</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>重命名为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> _writetofile_char_long(<span class="keyword">char</span> *filename,<span class="keyword">long</span> value);</span><br></pre></td></tr></table></figure>

<p>函数被调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。</p>
<blockquote>
<p>不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。</p>
</blockquote>
<p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title>从C到C++</title>
    <url>/2019/11/07/%E4%BB%8EC%E5%88%B0C/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/wucz122140729/article/details/98477483" target="_blank" rel="noopener">https://blog.csdn.net/wucz122140729/article/details/98477483</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++简介</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile文件</title>
    <url>/2019/11/07/makefile%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>
<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98477445" target="_blank" rel="noopener">码农有道</a></p>
<p>  在软件的工程中的源文件是很多的，其按照类型、功能、模块分别放在若干个目录和文件中，哪些文件需要编译，那些文件需要后编译，那些文件需要重新编译，甚至进行更复杂的功能操作，这就有了我们的系统编译的工具。</p>
<p>在linux和unix中，有一个强大的实用程序，叫make，可以用它来管理多模块程序的编译和链接，直至生成可执行文件。</p>
<p>make程序需要一个编译规则说明文件，称为makefile，makefile文件中描述了整个软件工程的编译规则和各个文件之间的依赖关系。</p>
<p>makefile就像是一个shell脚本一样，其中可以执行操作系统的命令，它带来的好处就是我们能够实现“自动化编译”，一旦写好，只要一个make命令，整个软件功能就完全自动编译，提高了软件开发的效率。</p>
<p>make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说大多数编译器都有这个命令，使用make可以是重新编译的次数达到最小化。</p>
<h3 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h3><p>makefile文件的规则可以非常复杂，比C程序还要复杂，我通过示例来介绍它的简单用法。</p>
<p>文件名：<strong><code>makefile</code></strong>，内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: book1 book46</span></span><br><span class="line"></span><br><span class="line"><span class="section">book1:book1.c</span></span><br><span class="line">	gcc -o book1 book1.c</span><br><span class="line"></span><br><span class="line"><span class="section">book46:book46.c _public.h _public.c</span></span><br><span class="line">	gcc -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f book1 book46</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:book book46</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>all: 这是固定的写法。<br>book book46表示需要编译目标程序的清单，中间用空格分隔开。</p>
<ul>
<li><p>第二行<br>makefile文件中的空行就像C程序中的空行一样，只是为了书写整洁，没有什么意义。</p>
</li>
<li><p>第三行</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book1:book1.c</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>book1:表示需要编译的目标程序。<br>book1.c表示如果要编译目标程序book1，需要依赖源程序book1.c，当book1.c的内容发生了变化，执行make的时候就会重新编译book1。</p>
<ul>
<li>第四行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o book1 book1.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这是一个编译命令，和在操作系统命令行输入的命令一样，但是要注意一个问题，在gcc之前要用tab键，看上去像8个空格，实际不是，一定要用tab，空格不行。</p>
<ul>
<li>第六行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book46:book46.c _public.h _public.c</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>与第三行的含义相同。<br>book46:表示编译的目标程序。<br>book46.c表示如果要编译目标程序book46，需要依赖源程序book46.c、<code>_public.h</code>和<code>_public.c</code>三个源程序，只要任何一个的内容发生了变化，执行make的时候就会重新编译book46。</p>
<ul>
<li>第七行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o book46 book46.c _public.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>与第四行的含义相同。</p>
<ul>
<li>第九行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>清除目标文件，清除的命令由第十行之后的脚本来执行。</p>
<ul>
<li>第十行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">rm  -f  book1 book46</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>清除目标文件的脚本命令，注意了，rm之前也是一个tab键，不是空格。</p>
<h3 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h3><p>makefile准备好了，在命令提示符下执行make就可以编译makefile中<strong>all参数指定的目标文件</strong>。</p>
<p>程序make编译目标程序。<br><img src="m1.png" alt="make"></p>
<p>再执行一次make。<br><img src="m2.png" alt="make"></p>
<p>因为全部的目标程序都是最新的，所以提示没有目标可以编译。</p>
<p>执行make clean，执行清除目标文件的指令。<br><img src="m3.png" alt="make"></p>
<p>再执行make重新编译。<br><img src="m4.png" alt="make"></p>
<p>修改<code>_public.c</code>程序，随便改点什么，只要改了就行。<br>然后再make<br><img src="m5.png" alt="make"></p>
<p>注意了，因为book46依赖的源程序之一<code>_public.c</code>改变了，所以book46重新编译。<br>book1没有重新编译，因为book1依赖的源文件并没有改变。</p>
<h3 id="makefile文件中的变量"><a href="#makefile文件中的变量" class="headerlink" title="makefile文件中的变量"></a>makefile文件中的变量</h3><p>makefile中，变量就是一个名字，变量的值就是一个文本字符串。在makefile中的目标，依赖，命令或其他地方引用变量时，变量会被它的值替代。</p>
<p>我还通过示例来介绍它的简单用法。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line">FLAG=-g</span><br><span class="line"></span><br><span class="line"><span class="section">all: book1 book46</span></span><br><span class="line"></span><br><span class="line"><span class="section">book1:book1.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(FLAG)</span> -o book1 book1.c</span><br><span class="line"></span><br><span class="line"><span class="section">book46:book46.c _public.h _public.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(FLAG)</span> -o book46 book46.c _public.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f book1 book46</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC=gcc</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>定义变量CC，赋值gcc。</p>
<ul>
<li>第二行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FLAG=-g</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>定义变量FLAG，赋值-g。</p>
<ul>
<li>第七行<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(FLAG)</span> -o book1 book1.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>$(CC)和$(FLAG)就是使用变量CC和FLAG的值，类似于C语言的宏定义，替换后的结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g -o book1 book1.c</span><br></pre></td></tr></table></figure>

<p>$(变量名)这是语法规定，不要问为什么，照这么用就行。</p>
<p>在makefile文件中，使用变量的好处有两个：1）如果在很多编译指令采用了变量，只要修改变量的值，就相当于修改全部的编译指令；2）把比较长的、公共的编译指令采用变量来表示，可以让makefile更简洁。</p>
<h3 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h3><pre><code>makefile文件的编写可以很复杂，复杂到不想看，在实际开发中，用不着那么复杂的makefile，我追求简单实用的方法，腾出更多的时间和精力去做更重要的事情。</code></pre>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>makefile文件</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试</title>
    <url>/2019/11/06/gdb%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>简写</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>set args</td>
<td></td>
<td>设置主程序的参数</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点,<code>b 20</code>表示在第20行设置断点,可设置多个断点</td>
</tr>
<tr>
<td>run</td>
<td>r</td>
<td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>执行当前行语句，如果该语句为函数调用，则进入函数(必须有源码)执行其中的第一条语句</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>显示变量值，例如：p name表示显示变量name的值</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续程序的运行，直到遇到下一个断点。</td>
</tr>
<tr>
<td>set varname=v</td>
<td></td>
<td>设置变量varname的值为v,字符串也用=,而不是strcpy</td>
</tr>
<tr>
<td>quit</td>
<td>q</td>
<td>退出gdb</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言编译预处理</title>
    <url>/2019/11/06/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<p>转自<a href="https://blog.csdn.net/wucz122140729/article/details/98477404" target="_blank" rel="noopener">码农有道</a></p>
<ul>
<li>C语言由源代码生成可执行程序的过程如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C源程序－&gt;编译预处理－&gt;编译－&gt;优化程序－&gt;汇编程序－&gt;链接程序－&gt;可执行文件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中编译预处理阶段，读取C源程序，对其中的预处理指令（以#开头的指令）和特殊符号进行处理。或者说是扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。</p>
<p>预处理过程先于编译器对源代码进行处理，读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行转换。预处理过程还会删除程序中的注释和多余的空白字符。</p>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>在C语言的程序中可包括各种以符号#开头的编译指令，这些指令称为预处理命令。预处理命令属于C语言编译器，而不是C语言的组成部分。通过预处理命令可扩展C语言程序设计的环境。</p>
<p>预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p>
<ul>
<li>预处理指令主要有以下三种：</li>
</ul>
<ul>
<li><input disabled type="checkbox"> 包含文件：将源文件中以#include格式包含的文件复制到编译的源文件中，可以是头文件，也可以是其它的程序文件。</li>
<li><input disabled type="checkbox"> 宏定义指令：#define 指令定义一个宏，#undef指令删除一个宏定义。</li>
<li><input disabled type="checkbox"> 条件编译：根据#ifdef和#ifndef后面的条件决定需要编译的代码。</li>
</ul>
<h3 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h3><p>当一个C语言程序由多个文件模块组成时，主模块中一般包含main函数和一些当前程序专用的函数。程序从main函数开始执行，在执行过程中，可调用当前文件中的函数，也可调用其他文件模块中的函数。</p>
<p>如果在模块中要调用其他文件模块中的函数，首先必须在主模块中声明该函数原型。一般都是采用文件包含的方法，包含其他文件模块的头文件。</p>
<p>文件包含中指定的文件名即可以用引号括起来，也可以用尖括号括起来，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"文件名"</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用尖括号&lt;&gt;括起文件名，则编译程序将到C语言开发环境中设置好的 include文件中去找指定的文件。</p>
<p>因为C语言的标准头文件都存放在include文件夹中，所以一般对标准头文件采用尖括号；对编程自己编写的文件，则使用双引号。</p>
<p>如果自己编写的文件不是存放在当前工作文件夹，可以在#include命令后面加在路径。</p>
<p><code>#include</code>命令的作用是把指定的文件模块内容插入到#include所在的位置，当程序编译链接时，系统会把所有#include指定的文件链接生成可执行代码。文件包含必须以#开头，表示这是编译预处理命令，行尾不能用分号结束。</p>
<p><code>#include</code>所包含的文件，其扩展名可以是“.c”,表示包含普通C语言源程序。也可以是 “.h”,表示C语言程序的头文件。C语言系统中大量的定义与声明是以头文件形式提供的。</p>
<h3 id="宏定义指令"><a href="#宏定义指令" class="headerlink" title="宏定义指令"></a>宏定义指令</h3><p>使用#define命令并不是真正的定义符号常量，而是定义一个可以替换的宏。被定义为宏的标识符称为“宏名”。在编译预处理过程时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏替换”或“宏展开”。</p>
<p>在C语言中，宏分为有参数和无参数两种。</p>
<h4 id="无参数的宏"><a href="#无参数的宏" class="headerlink" title="无参数的宏"></a>无参数的宏</h4><p>其定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名  字符串</span></span><br></pre></td></tr></table></figure>

<p>在以上宏定义语句中，各部分的含义如下：</p>
<blockquote>
<p><code>#</code>表示这是一条预处理命令(凡是以“#”开始的均为预处理命令)。<br>define 关键字“define”为宏定义命令。<br>宏名 是一个标示符，必须符合C语言标示符的规定，一般以大写字母标识宏名。<br>字符串 可以是常数，表达式，格式串等。在前面使用的符号常量的定义就是一个无参数宏定义。</p>
</blockquote>
<p>注意：预处理命令语句后面一般不会添加分号，如果在#define最后有分号，在宏替换时分号也将替换到源代码中去。在宏名和字符串之间可以有任意个空格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例（pre1.c）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行预编译指令<code>gcc -E -o pre1.E pre1.c</code>，得到预处理<code>pre1.E</code>文件，如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre1.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, <span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见<code>PI</code>被替换为了3.14</p>
</blockquote>
<ul>
<li>在使用宏定义时，还需要注意以下几点：</li>
</ul>
<p>宏定义是宏名来表示一个字符串，在宏展开时又以该字符串取代宏名。这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。</p>
<p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层替换。</p>
<p>习惯上宏名用大写字母表示，以方便与变量区别。但也可以用小写字母。</p>
<h4 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h4><p><code>#define</code>命令定义宏时，还可以为宏设置参数。与函数中的参数类似，在宏定义中的参数为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，还要用实参去代换形参。</p>
<p>带参宏定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(形参表) 字符串</span></span><br></pre></td></tr></table></figure>

<p>在定义带参数的宏时，宏名和形参表之间不能有空格出现，否则，就将宏定义成为无参数形式，而导致程序出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y)  ((x)&gt;(y)?(x):(y))</span></span><br></pre></td></tr></table></figure>

<p>以上的宏定义中，如果x的值大于y，得到x，否则得到y。</p>
<ul>
<li>示例（pre2.c）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a&gt;b)?a:b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, MAX(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>运行gcc -E -o pre2.E pre2.c并查看</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre2.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=%f\n"</span>, ((<span class="number">5</span>&gt;<span class="number">6</span>)?<span class="number">5</span>:<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带参的宏和带参的函数相似，但其本质是不同的。使用带参宏时，在预处理时将程序源代码替换到相应的位置，编译时得到完整的目标代码，而不进行函数调用，因此程序执行效率要高些。而函数调用只需要编译一次函数，代码量较少，一般情况下，对于简单的功能，可使用宏替换的形式来使用。</p>
<p>带参数的宏不容易理解，所以，在实际开发中，我不建议使用带参数的宏。</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>条件编译有多种格式，在这里我只介绍最常用的两种格式#ifdef和#ifndef。</p>
<h4 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a>#ifdef</h4><ul>
<li>#ifdef命令的使用格式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">    程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其意义是，如果#ifdef后面的标识符已被定义过，则对“程序段1”进行编译；如果没有定义标识符，则编译“程序段2”。一般不使用#else及后面的“程序2”。</p>
<ul>
<li><p>示例（pre3.c）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINUX</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LINUX</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是linux操作系统\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他操作系统\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行预编译指令gcc -E -o pre3.E pre3.c，得到pre3.E文件，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"pre3.c"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"这是linux操作系统\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h4><p>而#ifndef的意义与#ifdef相反，其格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 标识符</span></span><br><span class="line">    程序段 <span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段 <span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其意义是，如果未定义标识符，则编译“程序段1”；否则编译“程序段2”</p>
<p>在实际开发中，程序员用#ifndef来防止头文件被重复包含。</p>
<p>打开<code>/usr/include/stdio.h</code>，第一条有效行的代码是<code>#ifndef _STDIO_H</code>，接下来是<code>#define _STDIO_H 1</code>，最后一行是<code>#endif</code>。</p>
<p>程序员自定义的头文件，我们也会这么写，如：</p>
<p>如果头文件被包含多次，就表示头文件中的函数被多次声明，全局变量被多次定义，在以前的C语言编译器中，这是不允许的，编译时会报错，但是，现在的部分编译器比较智能，多次定义全局变量或多次声明函数也不会报错。这些新的特征让我这个老家伙很不适应。</p>
<h4 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h4><p><code>#undef</code>取消已定义的标识符。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言系统错误信息</title>
    <url>/2019/11/05/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437350" target="_blank" rel="noopener">原文链接</a></p>
<p>为防止和正常的返回值混淆，库函数的调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为 errno 的全局变量中，errno 不同数值所代表的错误消息定义在 &lt;errno.h&gt; 文件中。如果库函数调用失败，可以通过读出 errno 的值来确定问题所在，推测程序出错的原因，这也是调试程序的一个重要方法。</p>
<p>配合 strerror和perror两个库函数，还可以很方便地查看出错的详细信息。</p>
<h3 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h3><ul>
<li>strerror 在 &lt;string.h&gt; 中声明，用于获取错误码对应的消息描述。</li>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errno)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数说明：strerror()用来依参数errno 的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。<br>返回值：返回描述错误原因的字符串地址。<br>在gcc4.4.7版本中，定义了130多个错误代码，我们用程序把它们全部显示出来。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> errorno;</span><br><span class="line">    <span class="keyword">for</span>(errorno=<span class="number">0</span>; errorno&lt;<span class="number">150</span>; errorno++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d--&gt;%s\n"</span>, errorno, strerror(errorno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出结果<br><img src="e1.png" alt="错误信息"> <img src="e2.png" alt="错误信息"></p>
</blockquote>
<p>一共有130多个错误代码和描述，上面的截图只显示了前5条和最后5条。这些错误代码和描述看一下就行了，不需要记住。</p>
<h3 id="perror-在-lt-stdio-h-gt-中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。"><a href="#perror-在-lt-stdio-h-gt-中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。" class="headerlink" title="perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。"></a>perror 在 &lt;stdio.h&gt; 中声明，用于在屏幕上最近一次系统错误码及其消息描述，在实际开发中，我们写的程序运行于后台，在屏幕上显示错误信息没有意义。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这个文件不存在</span></span><br><span class="line">    <span class="keyword">if</span>(remove(<span class="string">"/abcd/efg.txt"</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"删除文件失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="e3.png" alt="运行"></p>
</blockquote>
<h3 id="errno的细节"><a href="#errno的细节" class="headerlink" title="errno的细节"></a>errno的细节</h3><ul>
<li>调用库函数失败不一定会设置errno<br>如果库函数调用失败，库函数会设置errno的值，程序员通过 errno 的值来判断出错的具体原因，但是，并不是全部的库函数在调用失败时都会设置errno的值，那么，哪些库函数会设置errno的值呢，要看函数的说明，例如fopen函数，在命令行下输入man fopen，在诸多的文字中，有以下行说明文字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The fopen() function may also fail and set errno for any of the errors specified for the routine open(2).</span><br></pre></td></tr></table></figure>

<p>不属于系统调用的函数不会设置errno，属于系统调用的函数才会设置errno。</p>
<ul>
<li><p>errno不能作为调用库函数失败的标志<br>在 C 语言中，如果库函数被正确地执行，那么 errno 的值不会被清零。换句话说，errno 的值只有在一个库函数调用发生错误时才会被设置，当库函数调用成功运行时，errno 的值不会被修改，当然也不会主动被置为 0。也正因为如此，在实际编程中，判断函数执行是否成功还得靠函数的返回值，只有在返回值是失败的情况下，才需要关注errno的值。</p>
</li>
<li><p>程序员可以不用errno<br>关注errno的目的是为了获取更详细错误信息，这些错误信息对程序员诊断程序可能会有帮助，但不是必须的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>错误信息</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言目录操作补充</title>
    <url>/2019/11/05/C%E8%AF%AD%E8%A8%80%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437217" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="access库函数"><a href="#access库函数" class="headerlink" title="access库函数"></a>access库函数</h3><blockquote>
<p>access函数用于判断当前操作系统用户对文件或目录的存取权限。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<br>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。<br>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK 2    <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回值：<br>当pathname满足mode的条件时候返回0，不满足返回-1。<br>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p>
<h3 id="stat库函数"><a href="#stat库函数" class="headerlink" title="stat库函数"></a>stat库函数</h3><h4 id="stat结构体"><a href="#stat结构体" class="headerlink" title="stat结构体"></a>stat结构体</h4><p>struct stat结构体用于存放文件和目录的状态信息，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev;   <span class="comment">// device 文件的设备编号</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino;   <span class="comment">// inode 文件的i-node</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode;   <span class="comment">// protection 文件的类型和存取的权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;   <span class="comment">// number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1.</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;   <span class="comment">// user ID of owner 文件所有者的用户识别码</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;   <span class="comment">// group ID of owner 文件所有者的组识别码</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;  <span class="comment">// device type 若此文件为设备文件, 则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;  <span class="comment">// total size, in bytes 文件大小, 以字节计算</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;  <span class="comment">// blocksize for filesystem I/O 文件系统的I/O 缓冲区大小.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;  <span class="comment">// number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节.</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime;  <span class="comment">// time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变.</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime;  <span class="comment">// time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime;  <span class="comment">// time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>struct stat结构体的成员变量比较多，对程序员来说，重点关注st_mode、st_size和st_mtime成员就可以了。注意st_mtime是一个整数表达的时间，需要程序员自己写代码转换格式。<br>st_mode成员的取值很多，或者使用如下两个宏来判断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_ISREG (st_mode) 是否为一般文件</span><br><span class="line">S_ISDIR (st_mode) 是否为目录</span><br></pre></td></tr></table></figure>

<h4 id="stat库函数-1"><a href="#stat库函数-1" class="headerlink" title="stat库函数"></a>stat库函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p>stat函数获取path指定文件或目录的信息，并将信息保存到结构体buf中，执行成功返回0，失败返回-1。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(access(argv[<span class="number">1</span>], F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件或目录%s不存在"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st_stat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件状态信息</span></span><br><span class="line">    <span class="keyword">if</span>(stat(argv[<span class="number">1</span>], &amp;st_stat) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(st_stat.st_mode))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s是一个文件\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(S_ISDIR(st_stat.st_mode))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s是一个目录\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件名%s\n类型%d\n最终修改时间%ld\n大小%ld\n"</span> ,\</span><br><span class="line">            argv[<span class="number">1</span>], st_stat.st_mode, st_stat.st_mtime, st_stat.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<blockquote>
<p>运行结果<br><img src="d1.png" alt="结果"></p>
</blockquote>
<h3 id="utime库函数"><a href="#utime库函数" class="headerlink" title="utime库函数"></a>utime库函数</h3><p>utime函数用于修改文件的存取时间和更改时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：utime()用来修改参数filename 文件所属的inode 存取时间。如果参数times为空指针(NULL), 则该文件的存取时间和更改时间全部会设为目前时间。结构utimbuf 定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> actime;</span><br><span class="line">    <span class="keyword">time_t</span> modtime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值：执行成功则返回0，失败返回-1。</p>
<h3 id="rename库函数"><a href="#rename库函数" class="headerlink" title="rename库函数"></a>rename库函数</h3><p>rename函数用于重命名文件或目录，相当于操作系统的mv命令，对程序员来说，在程序中极少重命名目录，但重命名文件是经常用到的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rename(<span class="string">"/home/user/aaa.txt"</span>, <span class="string">"/home/user/aaa_new.txt"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参数说明：<br>oldpath 文件或目录的原名。<br>newpath 文件或目录的新的名称。<br>返回值：0-成功，-1-失败。</p>
<h3 id="remove库函数"><a href="#remove库函数" class="headerlink" title="remove库函数"></a>remove库函数</h3><p>remove函数用于删除文件或目录，相当于操作系统的rm命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含头文件：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 函数声明：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：<br>pathname 待删除的文件或目录名。<br>返回值：0-成功，-1-失败。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>目录操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言时间操作</title>
    <url>/2019/11/04/C%E8%AF%AD%E8%A8%80%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<p><a href="https://blog.csdn.net/wucz122140729/article/details/98437007" target="_blank" rel="noopener">原文连接</a></p>
<h3 id="time-t别名"><a href="#time-t别名" class="headerlink" title="time_t别名"></a>time_t别名</h3><p>在C语言中，用time_t来表示时间数据类型，它是一个long（长整数）类型的别名，在time.h文件中定义，表示一个日历时间，是从1970年1月1日0时0分0秒到现在的秒数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出time_t其实是一个长整型。</p>
<h3 id="time库函数"><a href="#time库函数" class="headerlink" title="time库函数"></a>time库函数</h3><p>time函数的用途是返回一个值，也就是从1970年1月1日0时0分0秒到现在的秒数。<br>time函数是C语言标准库中的函数，在time.h文件中声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span> *t);</span><br></pre></td></tr></table></figure>

<ul>
<li>time函数有两种调用方法：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> tnow;</span><br><span class="line">tnow =time(<span class="number">0</span>);     <span class="comment">// 将空地址传递给time函数，并将time返回值赋给变量tnow</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">time(&amp;tnow);       <span class="comment">// 将变量tnow的地址作为参数传递给time函数</span></span><br></pre></td></tr></table></figure>

<p>各位可以写代码测试一下这两种方式，效果完全相同。</p>
<h3 id="tm结构体"><a href="#tm结构体" class="headerlink" title="tm结构体"></a>tm结构体</h3><p>time_t只是一个长整型，不符合我们的使用习惯，需要转换成可以方便表示时间的结构体，即tm结构体，tm结构体在time.h中声明，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">int</span> tm_sec;     <span class="comment">/* 秒 – 取值区间为[0,59]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_min;    <span class="comment">/* 分 - 取值区间为[0,59]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_hour;   <span class="comment">/* 时 - 取值区间为[0,23] */</span></span><br><span class="line">       <span class="keyword">int</span> tm_mday;  <span class="comment">/* 一个月中的日期 - 取值区间为[1,31]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_mon;   <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11]  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_year;   <span class="comment">/* 年份，其值等于实际年份减去1900  */</span></span><br><span class="line">       <span class="keyword">int</span> tm_wday;   <span class="comment">/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span><br><span class="line">       <span class="keyword">int</span> tm_yday;   <span class="comment">/* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</span></span><br><span class="line">       <span class="keyword">int</span> tm_isdst;   <span class="comment">/* 夏令时标识符，该字段意义不大，我们不用夏令时。 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个结构定义了年、月、日、时、分、秒、星期、当年中的某一天、夏令时。用这个结构体可以很方便的显示时间。</p>
</blockquote>
<h3 id="localtime库函数"><a href="#localtime库函数" class="headerlink" title="localtime库函数"></a>localtime库函数</h3><p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间，函数返回struct tm结构体的地址。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm * <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>struct tm结构体包含了时间的各要素，但还不是我们习惯的时间表达方式，我们可以用格式化输出printf、sprintf或fprintf等函数，把struct tm结构体转换为我们想要的结果。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">st_tm</span>;</span></span><br><span class="line">    <span class="keyword">time_t</span> tnow, tnow1;</span><br><span class="line">    tnow = time(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now=%ld\n"</span>, tnow);</span><br><span class="line">    st_tm = localtime(&amp;tnow);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d年%d月%d日 星期%d %02d:%02d:%02d\n"</span>, \</span><br><span class="line">            st_tm-&gt;tm_year+<span class="number">1900</span>, st_tm-&gt;tm_mon+<span class="number">1</span>, st_tm-&gt;tm_mday, \</span><br><span class="line">            st_tm-&gt;tm_wday, st_tm-&gt;tm_hour, st_tm-&gt;tm_min, st_tm-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p>输出结果<br><img src="t1.png" alt="结果"></p>
</blockquote>
<h3 id="mktime库函数"><a href="#mktime库函数" class="headerlink" title="mktime库函数"></a>mktime库函数</h3><p>mktime函数的功能与localtime函数相反。</p>
<blockquote>
<p>localtime函数用于把time_t表示的时间转换为struct tm表示的时间。<br>mktime  函数用于把struct tm表示的时间转换为time_t表示的时间,函数返回time_t的值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> mktime(struct tm *tm);</span><br></pre></td></tr></table></figure>

<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">st_tm</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;st_tm, <span class="number">0</span>, <span class="keyword">sizeof</span>(st_tm));</span><br><span class="line">    st_tm.tm_year = <span class="number">2019</span><span class="number">-1900</span>;</span><br><span class="line">    st_tm.tm_mon = <span class="number">11</span><span class="number">-1</span>;</span><br><span class="line">    st_tm.tm_mday = <span class="number">4</span>;</span><br><span class="line">    st_tm.tm_hour = <span class="number">20</span>;</span><br><span class="line">    st_tm.tm_min = <span class="number">18</span>;</span><br><span class="line">    st_tm.tm_sec = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the long num is %lu\n"</span>, mktime(&amp;st_tm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="t2.png" alt="结果"></p>
</blockquote>
<h3 id="程序睡眠"><a href="#程序睡眠" class="headerlink" title="程序睡眠"></a>程序睡眠</h3><p>在实际开发中，我们经常需要把程序挂起一段时间，可以使用sleep和usleep两个库函数，需要包含unistd.h头文件中。函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usleep</span><span class="params">(<span class="keyword">useconds_t</span> usec)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sleep函数的参数是秒，usleep函数的参数是微秒，1秒=1000000微秒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sleep(<span class="number">1</span>);           <span class="comment">// 程序睡眠1秒。</span></span><br><span class="line">sleep(<span class="number">10</span>);          <span class="comment">// 程序睡眠10秒。</span></span><br><span class="line">usleep(<span class="number">100000</span>);    <span class="comment">// 程序睡眠十分之一秒。</span></span><br><span class="line">usleep(<span class="number">1000000</span>);   <span class="comment">// 程序睡眠一秒。</span></span><br></pre></td></tr></table></figure>

<p>程序员不关心sleep和usleep函数的返回值。</p>
<h3 id="精确到微秒的计时器"><a href="#精确到微秒的计时器" class="headerlink" title="精确到微秒的计时器"></a>精确到微秒的计时器</h3><h4 id="timeval结构体"><a href="#timeval结构体" class="headerlink" title="timeval结构体"></a>timeval结构体</h4><p>timeval结构体在sys/time.h文件中定义，声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span>  tv_sec;            <span class="comment">// 1970年1月1日到现在的秒。</span></span><br><span class="line">    <span class="keyword">long</span>  tv_usec;         <span class="comment">// 当前秒的微妙，即百万分之一秒。</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h4 id="timezone-结构体"><a href="#timezone-结构体" class="headerlink" title="timezone 结构体"></a>timezone 结构体</h4><p>timezone 结构体在sys/time.h文件中定义，声明为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">timezone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tz_minuteswest;     <span class="comment">// 和greenwich 时间差了多少分钟。</span></span><br><span class="line">    <span class="keyword">int</span> tz_dsttime;           <span class="comment">// type of DST correction。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gettimeofday库函数"><a href="#gettimeofday库函数" class="headerlink" title="gettimeofday库函数"></a>gettimeofday库函数</h4><p>gettimeofday是获得当前的秒和微秒的时间，其中的秒是指1970年1月1日到现在的秒，微秒是指当前秒已逝去的微秒数，可以用于程序的计时。调用gettimeofday函数需要包含sys/time.h头文件。</p>
<ul>
<li>函数声明：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct  timeval *tv, struct  timezone *tz )</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当前的时间存放在tv 结构体中，当地时区的信息则放到tz所指的结构中。<br>函数执行成功后返回0，失败后返回-1。</p>
<blockquote>
<p>在使用gettimeofday()函数时，第二个参数一般都为空，我们一般都只是为了获得当前时间，不关心时区的信息。</p>
</blockquote>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">begin</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;begin, <span class="number">0</span>);  <span class="comment">//第二个参数一般固定填0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"begin time(0)=%lu tv_sec=%lu, tv_usec=%lu\n"</span>,\</span><br><span class="line">            time(<span class="number">0</span>), begin.tv_sec, begin.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始睡眠1000000us\n"</span>);</span><br><span class="line">    usleep(<span class="number">1000000</span>);</span><br><span class="line">    gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"end time(0)=%lu tv_sec=%lu, tv_usec=%lu\n"</span>,\</span><br><span class="line">            time(<span class="number">0</span>), end.tv_sec, end.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计时过去了%luus\n"</span>, \</span><br><span class="line">            (end.tv_sec-begin.tv_sec)*<span class="number">1000000</span>+(end.tv_usec-begin.tv_usec));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="t3.png" alt="结果"></p>
</blockquote>
<p>程序采用usleep睡眠十分之一秒，但是计时器显示的实际时间大于十分之一秒，为何？原因很简单，因为程序执行需要时间，虽然这个时间很短，在千分之一秒内，那也是需要时间。</p>
<p>还有一个要注意的问题，time.h 是ISO C99 标准日期时间头文件。sys/time.h 是Linux 系统的日期时间头文件，也就是说，timeval、timezone结构体和gettimeofday函数在windows平台中不能使用。</p>
<blockquote>
<p>应用经验<br>在实际开发中，除了当前的时间，还经常需要一个偏移量的时间，例如获取十分钟之后的时间，做法是采用time函数得到一个整数后，再加上<code>10*60</code>秒，再用localtime函数转换为结构体。</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>时间操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言目录操作</title>
    <url>/2019/10/31/C%E8%AF%AD%E8%A8%80%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98436646" target="_blank" rel="noopener">码农有道的博客</a></li>
</ul>
<h3 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h3><p>在系统命令行下我们可以直接输入命令<code>pwd</code>来获取当前的工作目录，在C语言中可以使用<code>getcwd</code>函数来获取当前工作目录</p>
<ul>
<li><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含于&lt;unistd.h&gt;中</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> * buf,<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strpwd[<span class="number">301</span>];</span><br><span class="line">    <span class="built_in">memset</span>(strpwd, <span class="number">0</span>, <span class="keyword">sizeof</span>(strpwd));</span><br><span class="line">    getcwd(strpwd, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前目录：%s\n"</span>, strpwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>就像我们在shell里使用cd命令来切换目录一样，在程序里则可以使用chdir系统调用来实现目录的变更。返回值：0-切换成功；非0-失败。<br>切换目录只是切换程序的运行环境目录，而不会改变用户的目录</p>
</blockquote>
<h3 id="目录的创建和删除"><a href="#目录的创建和删除" class="headerlink" title="目录的创建和删除"></a>目录的创建和删除</h3><p> 在系统命令行下我们可以通过mkdir和rmdir命令通过shell来创建一个目录和删除一个目录,在C语言中</p>
<ul>
<li>函数声明<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建目录,返回0为成功，-1为失败</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;<span class="comment">//mode是权限设置，如00755</span></span><br><span class="line"><span class="comment">//删除目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="获取目录中的文件列表"><a href="#获取目录中的文件列表" class="headerlink" title="获取目录中的文件列表"></a>获取目录中的文件列表</h3><p>获取目录中的文件列表，类似于ls命令<br>在实际开发中，我们经常要处理文件，文件是存放在目录中的，在处理文件之前，必须先知道目录中有哪些文件，所以要获取目录中的文件列表。涉及到的库函数如下：</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开目录的函数opendir的声明。</span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="comment">//读取目录的函数readdir的声明。</span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="comment">//关闭目录的函数closedir的声明。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>DIR是目录指针，就像文件操作时的文件指针。<br>调用一次readdir，返回结构体struct dirent（在dirent.h中声明，程序员只管用就行了）的指针，存放本次读取到的文件的信息，就像文件操作时调用一次fgets一样，但是fgets调用获取的内容是一个字符串，readdir返回的是结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> d_ino;                    <span class="comment">// inode number 索引节点号</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off;                    <span class="comment">// offset to this dirent 在目录文件中的偏移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;       <span class="comment">// length of this d_name 文件名长</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;          <span class="comment">// the type of d_name 文件类型</span></span><br><span class="line">    <span class="keyword">char</span> d_name [NAME_MAX+<span class="number">1</span>];  <span class="comment">// file name文件名，最长255字符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们只需要关注结构体的d_type和d_name成员，其它的不必关心。<br>d_name文件名或目录名。<br>d_type描述了文件的类型，有多种取值，最重要的是8和4，8-常规文件（A regular file）；4-目录（A directory），其它的暂时不关心.</p>
<ul>
<li><p>示例程序：获取某个目录下的文件和目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要输入一个目录参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    <span class="keyword">if</span>((dir=opendir(argv[<span class="number">1</span>]))==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//用于存放读取到的文件和目录信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">stdinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((stdinfo=readdir(dir))==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"name=%s;type=%d\n"</span>, stdinfo-&gt;d_name, stdinfo-&gt;d_type);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例程序：获取目录下的文件及子目录下的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//列出目录及子目录下的文件</span></span><br><span class="line">    ReadDir(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dir;  <span class="comment">//定义目录指针</span></span><br><span class="line">    <span class="keyword">char</span> child_path[<span class="number">256</span>];  <span class="comment">//子目录的全路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开目录</span></span><br><span class="line">    <span class="keyword">if</span>((dir=opendir(path))==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放从目录读到的文件和目录信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">stdinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((stdinfo=readdir(dir))==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略隐藏文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(stdinfo-&gt;d_name, <span class="string">"."</span>, <span class="number">1</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stdinfo-&gt;d_type==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//child_path = stdinfo-&gt;d_name;</span></span><br><span class="line">            <span class="built_in">sprintf</span>(child_path, <span class="string">"%s/%s"</span>, path, stdinfo-&gt;d_name);</span><br><span class="line">            ReadDir(child_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stdinfo-&gt;d_type==<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s/%s\n"</span>, \</span><br><span class="line">                    path, stdinfo-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><h4 id="mkdir函数"><a href="#mkdir函数" class="headerlink" title="mkdir函数"></a>mkdir函数</h4><h4 id="access库函数"><a href="#access库函数" class="headerlink" title="access库函数"></a>access库函数</h4><ul>
<li>access用于判断当前操作系统下用户对文件或目录的存取权限</li>
<li>包含头文件<code>&lt;unistd.h&gt;</code></li>
<li>函数声明<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>pathname文件名或目录名，可以是当前目录的文件或目录，也可以列出全路径。<br>mode 需要判断的存取权限。在头文件unistd.h中的预定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK 4     <span class="comment">// R_OK 只判断是否有读权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK 2     <span class="comment">// W_OK 只判断是否有写权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK 1     <span class="comment">// X_OK 判断是否有执行权限</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK 0     <span class="comment">// F_OK 只判断是否存在</span></span></span><br></pre></td></tr></table></figure>

<p>返回值<br>当pathname满足mode的条件时候返回0，不满足返回-1<br>在实际开发中，access函数主要用于判断文件或目录是否是存在。</p>
<ul>
<li>示例程序：创建目录(可多级创建)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数个数错误\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个用于创建目录的函数，可多级创建\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"示例： ./mkdir_r /a/b/c\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mkdir_r(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path_name[<span class="number">301</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">strlen</span>(path); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测间隔符‘/’或字符串末尾</span></span><br><span class="line">        <span class="keyword">if</span>(path[i]!=<span class="string">'/'</span> &amp;&amp; path[i+<span class="number">1</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">memset</span>(path_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(path_name));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(path[i+<span class="number">1</span>]==<span class="string">'\0'</span>)</span><br><span class="line">            <span class="built_in">strncpy</span>(path_name, path, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strncpy</span>(path_name, path, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(access(path_name, F_OK)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"文件path_name=%s已存在\n"</span>, path_name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建文件path_name=%s\n"</span>, path_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mkdir(path_name, <span class="number">00755</span>)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"创建文件path_name=%s失败\n"</span>, path_name);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>目录操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言动态内存管理</title>
    <url>/2019/10/26/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98435626" target="_blank" rel="noopener">https://blog.csdn.net/wucz122140729/article/details/98435626</a></p>
<a id="more"></a>
<p>在C语言中，编写程序的时候不能确定内存变量应该定义为多大，程序员希望在程序运行的时候根据数据量的大小向系统动态获得内存空间。所谓动态内存管理，就是指在程序执行的过程中动态地申请和回收内存空间。动态内存管理不像变量和数组那样在程序编写时预先分配内存空间，而是根据程序的需要即时分配，而且分配的内存大小就是程序要求的大小。</p>
<p>C语言允许程序动态申请内存，用于存放一些数据，需要时随时开辟，不需要时随时释放。C语言中，内存的动态分配是通过系统提供的库函数来实现的，主要有malloc和free 函数。</p>
<h2 id="相关的库函数"><a href="#相关的库函数" class="headerlink" title="相关的库函数"></a>相关的库函数</h2><h3 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc 函数"></a>malloc 函数</h3><p>其函数的申明为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">void *malloc(unsigned int size)；</span><br></pre></td></tr></table></figure>

<p>其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">100</span>)； <span class="comment">// 开辟 100 个字节的临时分配域，返回值为其第一个字节的地址</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意地址的基类型为 void，即不指向任何类型的数据，只提供一个地址。如果此函数未能成功的执行（例如内存空间不足），则返回空（NULL，即0）。</p>
<p>程序员需要定义一个指针来指向动态分配的内存地址。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a>free 函数</h3><p>函数申明为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其作用是释放指针 p 所指向的动态空间的地址。p 是调用 malloc 函数时的返回的地址。free函数无返回值。</p>
<ul>
<li>例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);     <span class="comment">// 释放指针变量pi指向的已分配的动态空间</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在使用动态分配内存技术的时候，分配出来的内存必须及时释放，否则会引起系统内存耗尽，这话说起来简单，好像很容易做到，但是在实际开发中，程序员往往是漏洞百出。<br>内存问题是C程序员的主要问题之一，程序崩溃是初中级程序员的恶梦。</p>
<h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针就是无效的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。</p>
<ul>
<li>指针变量未初始化<br>指针变量刚被创建时不一定会自动成为空指针（与编译器有关），它的缺省值是可能随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针的值设置为0，要么让它指向合法的内存。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi=&amp;I;</span><br></pre></td></tr></table></figure>

<ul>
<li>指针释放后之后未置空<br>指针在free后不一定会赋值 0（也与编译器有关），便会使人以为是合法的。free只是把指针所指的内存给释放掉，此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为0。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="应用经验"><a href="#应用经验" class="headerlink" title="应用经验"></a>应用经验</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在C语言的早期标准中，定义数组必须用常量指明大小，不能用变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">101</span>];        <span class="comment">// 可以这样</span></span><br><span class="line"><span class="keyword">int</span> len=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> str[len];         <span class="comment">// 不可以这样</span></span><br></pre></td></tr></table></figure>

<p>程序在运行的时候，如果要定义一个字符串存放100个字符，那怎么办，只能通过动态分配内存技术。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str=<span class="built_in">malloc</span>(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>现在，定义数组可以用变量指明大小，所以就不必为数组动态分配内存了。<br>还有，C++的string是一个字符串，非常好用，程序员根本不必关心内存的问题。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是C语言的一个经典的数据结构，相当于一个动态的结构体数组，非常巧妙，功能强大，但操作也麻烦，在这里我就不介绍了。</p>
<p>在C++中，容器全完代替了链表的功能，极其好用，程序员也不必关心内存的问题。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言文件操作</title>
    <url>/2019/10/25/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<p>转载自<a href="https://blog.csdn.net/wucz122140729/article/details/98435952" target="_blank" rel="noopener">码农有道的博客</a></p>
<h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p> 打开文件的时候，C语言为打开的文件分配一个文件信息区，该信息区中包含文件描述信息、该文件所使用的缓冲区大小及缓冲区位置、该文件当前读写到的位置等基本信息。这些信息保存在一个结构体类型变量中<code>struct _IO_FILE</code>，这个结构体有一个别名<code>FILE</code>–<code>typedef struct _IO_FILE FILE</code>，<code>FILE</code>结构体和对文件操作的库函数在<code>stdio.h</code>头文件中声明的。<br>  打开文件的时候，调用打开文件的函数<code>fopen</code>时会动态分配一个<code>FILE</code>结构体，并把<code>FILE</code>结构体地址作为函数的返回值，即文件指针。调用关闭文件的函数<code>fclose</code>时候，除了关闭文件，还会释放文件指针占用的内存空间</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><ul>
<li>使用<code>fopen</code>创建或者打开一个文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> FILE *<span class="title">fopen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__filename,</span></span></span><br><span class="line"><span class="function"><span class="params">		    <span class="keyword">const</span> <span class="keyword">char</span> *__modes)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数filename 是字符串，表示需要打开的文件名，可以包含目录名，如果不包含路径就表示程序运行的目录。实际开发中，采用文件的全路径，即包含目录名。<br>参数mode也是字符串，表示打开文件的模式，打开模式可以是下列值中的一个</p>
</blockquote>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rt</td>
<td>只读</td>
<td>文件必须存在，否则打开失败</td>
</tr>
<tr>
<td>wt</td>
<td>只写</td>
<td>文件存在，则清除原文件内容；文件不存在，则新建文件</td>
</tr>
<tr>
<td>at</td>
<td>追加只写</td>
<td>同上</td>
</tr>
<tr>
<td>rt+</td>
<td>读写</td>
<td>文件必须存在，+表示在只读上增加可写功能</td>
</tr>
<tr>
<td>wt+</td>
<td>读写</td>
<td>在只写上增加可读</td>
</tr>
<tr>
<td>at+</td>
<td>读写</td>
<td>在追加只写基础上增加可读</td>
</tr>
</tbody></table>
<ul>
<li><p>如果是二进制文件，则模式改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;rb&quot;、&quot;wb&quot;、&quot;ab&quot;、&quot;rb+&quot;、&quot;wb+&quot;、&quot;ab+&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果打开文本，则<code>t</code>可以省略，<code>rt</code>可以简写为<code>r</code></p>
</li>
</ul>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span> <span class="params">(FILE *__stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h2><blockquote>
<p>在实际开发中，文本文件以行为单位存放字符串，如C程序的源代码，一段文字等，所以一般是按行写入或读取数据。</p>
</blockquote>
<h3 id="向文件中写入数据"><a href="#向文件中写入数据" class="headerlink" title="向文件中写入数据"></a>向文件中写入数据</h3><ul>
<li>可使用<code>fputc</code>, <code>fputs</code>, <code>fprintf</code>写文件，一般使用<code>fprintf</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span> <span class="params">(FILE *__stream,<span class="keyword">const</span> <span class="keyword">char</span> *__format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>与<code>printf</code>用法大致相同，只是第一个参数多了个<code>FILE</code>文件指针</p>
</blockquote>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p> C语言从文件中读取数据的库函数有fgetc、fgets、fscanf，在实际开发中，fgetc和fscanf没什么用，只介绍fgets就可以了。fgets函数的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span> <span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> size, FILE *__stream)</span></span></span><br></pre></td></tr></table></figure>

<p>fgets的功能是从文件中读取一行<br>参数buf是一个字符串，用于保存从文件中读到的数据<br>参数size是打算读取内容的长度<br>参数fp是待读取文件的文件指针。</p>
<p>如果文件中将要读取的这一行的内容的长度小于size，fgets函数就读取一行，如果这一行的内容大于等于size，fgets函数就读取size-1字节的内容。<br>调用fgets函数如果成功的读取到内容，函数返回buf，如果读取错误或文件已结束，返回空，即0。如果fgets返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现</p>
<h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><p> fwrite() 库函数用来向文件中写入块数据，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>

<p>参数的说明：<br>ptr：为内存区块的指针，存放了要写入的数据的地址，它可以是数组、变量、结构体等。<br>size：固定填1。<br>nmemb：表示打算写入数据的字节数。<br>fp：表示文件指针。</p>
<p>函数的返回值是本次成功写入数据的字节数，一般情况下，程序员不必关心fwrite函数的返回值。</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;GIRL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GIRL girl;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二进制只写打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"/home/duguosheng/study/c/file/f1.txt"</span>, <span class="string">"wb"</span>))==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(girl.name, <span class="string">"小红"</span>);</span><br><span class="line">    girl.age = <span class="number">18</span>;</span><br><span class="line">    girl.height = <span class="number">167</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结构体存入文件</span></span><br><span class="line">    fwrite(&amp;girl, <span class="number">1</span>, <span class="keyword">sizeof</span>(girl), fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>vi打开该二进制文件<br><img src="f1.png" alt="二进制文件"></p>
</blockquote>
<h3 id="从文件中读取数据-1"><a href="#从文件中读取数据-1" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *fp);</span><br></pre></td></tr></table></figure>

<p>ptr：用于存放从文件中读取数据的变量地址，它可以是数组、变量、结构体等。<br>size：固定填1。<br>nmemb：表示打算读取的数据的字节数。<br>fp：表示文件指针。</p>
<blockquote>
<p>调用fread函数如果成功的读取到内容，函数返回读取到的内容的字节数，如果读取错误或文件已结束，返回空，即0。如果fread返回空，可以认为是文件结束而不是发生了错误，因为发生错误的情况极少出现。</p>
</blockquote>
<h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p> 在文件内部有一个位置指针，用来指向当前读写的位置，也就是读写到第几个字节。在文件打开时，如果打开模式是r和w，位置指针指向文件的第一个字节，如果打开模式是a，位置指针指向文件的尾部。每当从文件里读n个字节或文件里写入n个字节之后位置指针也会向后移动n个字节<br> C语言提供了ftell、rewind和fseek三个库函数来实现文件定位功能。</p>
<h3 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h3><p>  ftell函数用来返回当前文件位置指针的值，这个值是当前位置相对于文件开始位置的字节数。它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h3><p>rewind函数用来将位置指针移动到文件开头，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span> <span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h3><p>fseek() 用来将位置指针移动到任意位置，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span> <span class="params">( FILE *fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fp 为文件指针，也就是被移动的文件。</li>
<li>offset 为偏移量，也就是要移动的字节数。之所以为 long 类型，是希望移动的范围更大，能处理的文件更大。offset 为正时，向后移动；offset 为负时，向前移动。</li>
<li>origin 为起始位置，也就是从何处开始计算偏移量。C语言规定的起始位置有三种，分别为：0-文件开头；1-当前位置；2-文件末尾。</li>
</ul>
<p>fseek(fp,100,0);     // 从文件的开始位置计算，向后移动100字节。<br>fseek(fp,100,1);     // 从文件的当前位置计算，向后移动100字节。<br>fseek(fp,-100,2);    // 从文件的尾部位置计算，向前移动100字节</p>
<h2 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h2><p> 在操作系统中，存在一个内存缓冲区，当调用fprintf、fwrite等函数往文件写入数据的时候，数据并不会立即写入磁盘文件，而是先写入缓冲区，等缓冲区的数据满了之后才写入文件。还有一种情况就是程序调用了fclose时也会把缓冲区的数据写入文件。<br>在实际开发中，如果程序员想把缓冲区的数据立即写入文件，可以调用fflush库函数，它的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数的参数只有一个，即文件指针，返回0成功，其它失败，程序员一般不关心它的返回值。</p>
<h2 id="标准输入，标准输出，标准错误"><a href="#标准输入，标准输出，标准错误" class="headerlink" title="标准输入，标准输出，标准错误"></a>标准输入，标准输出，标准错误</h2><p>  Linux操作系统为每个程序默认打开三个文件，即标准输入stdin、标准输出stdout和标准错误输出stderr，其中0就是stdin，表示输入流，指从键盘输入，1代表stdout，2代表stderr，1,2默认是显示器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world.\n"</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello world.\n"</span>);</span><br></pre></td></tr></table></figure>

<p>这几个文件指针没什么用，让大家了解一下就行。在实际开发中，我们一般会关闭这几个文件指针。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言main函数的参数</title>
    <url>/2019/10/25/C%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>

<p>修改自<a href="https://blog.csdn.net/wucz122140729/article/details/98435291" target="_blank" rel="noopener">码农有道的博客</a></p>
<h2 id="main函数的参数"><a href="#main函数的参数" class="headerlink" title="main函数的参数"></a>main函数的参数</h2><p> main函数有三个参数，argc、argv和envp表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> argc，用于存放命令行参数的个数。</span><br><span class="line"><span class="keyword">char</span> *argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。</span><br><span class="line"><span class="keyword">char</span> *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。</span><br></pre></td></tr></table></figure>

<h3 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv"></a>argc和argv</h3><ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argc is %d\n"</span>, argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d] is %s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>终端下执行并输出<br><img src="m1.png" alt="结果"></p>
</blockquote>
<p>1）argc的值是参数个数加1，因为程序名称是程序的第一个参数，即argv[0]，在上面的示例中，argv[0]是./main1<br>2）main函数的参数，不管是书写的整数还是浮点数，全部被认为是字符串。<br>3）参数的命名argc和argv是程序员的约定，你也可以用argd或args，但是不建议这么做。</p>
<h3 id="用于提示信息"><a href="#用于提示信息" class="headerlink" title="用于提示信息"></a>用于提示信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入参数个数不匹配\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个选秀的程序，根据输入的信息为其评定\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"用法： ./main2 age appearance character\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"例如： ./main2 18 漂亮 开朗\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"age          年龄\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"appearance   颜值\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"character    性格\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((atoi(argv[<span class="number">1</span>])&gt;=<span class="number">18</span> &amp;&amp; atoi(argv[<span class="number">1</span>])=&lt;<span class="number">25</span>)</span><br><span class="line">            &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"漂亮"</span>)==<span class="number">0</span></span><br><span class="line">            &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">"开朗"</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"选秀合格"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"还需努力"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当输入参数个数不满足预期设定时<br><img src="m2.png" alt="弹出提示信息"></p>
</blockquote>
<blockquote>
<p>当输入满足预期时<br><img src="m3.png" alt="正确执行"></p>
</blockquote>
<h3 id="envp"><a href="#envp" class="headerlink" title="envp"></a>envp</h3><blockquote>
<p>存放当前程序运行环境的参数 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(envp[num++]!=<span class="number">0</span>) <span class="comment">//数组最后一个元素是0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, envp[num]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果(部分截图)<br><img src="m4.png" alt="环境变量"></p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>main函数</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言格式化输出</title>
    <url>/2019/10/23/C%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<a id="more"></a>


<h2 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flags][width][.prec]type</span><br></pre></td></tr></table></figure>

<h3 id="类型符type"><a href="#类型符type" class="headerlink" title="类型符type"></a>类型符type</h3><table>
<thead>
<tr>
<th>说明</th>
<th>标识符</th>
<th>含义</th>
<th>标识符</th>
<th>含义</th>
<th>标识符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>十进制有符号</td>
<td>%hd</td>
<td>short</td>
<td>%d</td>
<td>int</td>
<td>%ld</td>
<td>long</td>
</tr>
<tr>
<td>十进制无符号</td>
<td>%hu</td>
<td>short</td>
<td>%u</td>
<td>int</td>
<td>%lu</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>%c</td>
<td>输出字符</td>
<td>%f</td>
<td>float</td>
<td>%lf</td>
<td>double</td>
</tr>
<tr>
<td></td>
<td>%s</td>
<td>输出字符串</td>
<td>%e</td>
<td>科学计数法输出double</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="宽度width"><a href="#宽度width" class="headerlink" title="宽度width"></a>宽度width</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"=%5s=\n"</span>, <span class="string">"abc"</span>);  <span class="comment">//输出=  abc=</span></span><br></pre></td></tr></table></figure>

<h3 id="对齐标志flags"><a href="#对齐标志flags" class="headerlink" title="对齐标志flags"></a>对齐标志flags</h3><ul>
<li><code>+</code> 左对齐</li>
<li><code>-</code> 右对齐</li>
<li>缺省为<code>+</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"=%-5s="</span>, <span class="string">"abc"</span>);  <span class="comment">//输出=abc  =</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果输出整数或浮点数可在左补0<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%05d="</span>, <span class="number">123</span>);  <span class="comment">//输出=00123=</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="精度prec"><a href="#精度prec" class="headerlink" title="精度prec"></a>精度prec</h3><ul>
<li>如果输出是浮点数，它用于控制输出内容的精度，即保留位数，后面的四舍五入<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"=%010.2lf="</span>, <span class="number">123.456</span>);  <span class="comment">//输出=0000123.46=</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="格式化输出到字符串"><a href="#格式化输出到字符串" class="headerlink" title="格式化输出到字符串"></a>格式化输出到字符串</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>是参数个数可变的函数</p>
<p>功能：printf是把结果输出到屏幕，sprintf把格式化输出的内容保存到字符串str中，snprintf的n类似于strncpy中的n，意思是只获取输出结果的前n-1个字符，不是n个字符。</p>
<p>在之前的章节中，介绍过把字符串转换为整数和浮点数据的库函数，C语言没有提供把整数和浮点数据转换为字符串的库函数，而是采用sprintf和snprintf函数格式化输出到字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">300</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"%s今年%d岁了\n"</span>, <span class="string">"小明"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="built_in">snprintf</span>(str, <span class="number">11</span>, <span class="string">"%s今年%d岁了"</span>, <span class="string">"小明"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小明今年18岁了</span><br><span class="line">小明今�</span><br></pre></td></tr></table></figure>

<blockquote>
<p>snprintf截取中文不当会乱码</p>
</blockquote>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @func: 解析xml文件</span></span><br><span class="line"><span class="comment"> * @param: in_XMLBuffer所要查询的段落，in_FieldName所要查询的信息，out_Value获取内容存放的变量的指针</span></span><br><span class="line"><span class="comment"> * @return: 0-成功，-1-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetXMLBuffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *in_XMLBuffer,<span class="keyword">const</span> <span class="keyword">char</span> *in_FieldName,<span class="keyword">char</span> *out_Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> begin_filed_name[<span class="built_in">strlen</span>(in_FieldName)+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> end_filed_name[<span class="built_in">strlen</span>(in_FieldName)+<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(begin_filed_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(begin_filed_name));</span><br><span class="line">    <span class="built_in">memset</span>(end_filed_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(end_filed_name));</span><br><span class="line">    <span class="built_in">sprintf</span>(begin_filed_name, <span class="string">"&lt;%s&gt;"</span>, in_FieldName);</span><br><span class="line">    <span class="built_in">sprintf</span>(end_filed_name, <span class="string">"&lt;/%s&gt;"</span>, in_FieldName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *start, *end;</span><br><span class="line">    start = end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//寻找开始和结束地址</span></span><br><span class="line">    start = <span class="built_in">strstr</span>(in_XMLBuffer, begin_filed_name);</span><br><span class="line">    end = <span class="built_in">strstr</span>(in_XMLBuffer, end_filed_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start==<span class="number">0</span> || end==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:not found\n"</span>, in_FieldName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = end-start;</span><br><span class="line">    <span class="built_in">strncpy</span>(out_Value, start+<span class="built_in">strlen</span>(begin_filed_name), end-start-<span class="built_in">strlen</span>(begin_filed_name));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    char str_XML_buffer[301], str_value[51], str_age[51];</span></span><br><span class="line"><span class="comment">    memset(str_XML_buffer, 0, sizeof(str_XML_buffer));</span></span><br><span class="line"><span class="comment">    memset(str_value, 0, sizeof(str_value));</span></span><br><span class="line"><span class="comment">    strcpy(str_XML_buffer, "&lt;name&gt;西施&lt;/name&gt;&lt;age&gt;18&lt;/age&gt;&lt;sc&gt;火辣&lt;/sc&gt;&lt;yz&gt;漂亮&lt;/yz&gt;");</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "name", str_value);</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "nme", str_value);</span></span><br><span class="line"><span class="comment">    GetXMLBuffer(str_XML_buffer, "age", str_age);</span></span><br><span class="line"><span class="comment">    printf("%s", str_value);</span></span><br><span class="line"><span class="comment">    printf("%s", str_age);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>格式化输出</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中数据类型扩展</title>
    <url>/2019/10/23/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<a id="more"></a>

<p>一大部分摘自<a href="https://blog.csdn.net/wucz122140729" target="_blank" rel="noopener">码农有道</a></p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><h3 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h3><ul>
<li><p>输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制使用‘0b’或者‘0B’</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0b101</span>;</span><br><span class="line"><span class="comment">//八进制使用‘0‘</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0706</span>;</span><br><span class="line"><span class="comment">//十六进制使用‘0x‘或’0X‘</span></span><br><span class="line"><span class="keyword">int</span> b_num = <span class="number">0xabc</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出<br><img src="c1.png" alt="输出"></p>
</li>
</ul>
<h3 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h3><ul>
<li>以下库函数包含在<code>stdlib.h</code>中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> +nptr)</span></span>;  <span class="comment">//将字符串转化为int整数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;  <span class="comment">// 把字符串nptr转换为long整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> j)</span></span>;        <span class="comment">// 求int整数的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">labs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> j)</span></span>;  <span class="comment">// 求long整数的绝对值</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;  <span class="comment">//随机数生成器的初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span></span>;  <span class="comment">//获得一个随机数</span></span><br></pre></td></tr></table></figure>

<p>srand函数初始化随机数发生器（俗称种子），在实际开发中，我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同，通常我们采用<code>&lt;time.h&gt;</code>头文件中的<code>time</code>函数即可得到一个精确到秒的时间作为种子。<br><code>rand</code>函数会随机生成一个位于<code>0 ~ RAND_MAX</code>之间的整数。而对<code>RAND_MAX</code>是<code>&lt;stdlib.h&gt;</code>头文件中的一个宏，它用来指明<code>rand</code>所能返回的随机数的最大值</p>
<ul>
<li>示例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果<br><img src="c2.png" alt="随机数"></p>
</blockquote>
<ul>
<li>生成一定范围的随机数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">50</span>;   <span class="comment">// 产生0~49 </span></span><br><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">100</span>;   <span class="comment">// 产生100~150的随机数</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul>
<li>常用的库函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalpha</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是字母（'A'-'Z','a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isalnum</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是字母（'A'-'Z','a'-'z'）或数字（'0'-'9'），返回非0值,否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isdigit</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是数字（'0'-'9'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是小写字母（'a'-'z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是大写字母（'A'-'Z'）返回非0值，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tolower</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是大写字母（'A'-'Z'）返回相应的小写字母（'a'-'z'）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toupper</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;  <span class="comment">//若ch是小写字母（'a'-'z'）返回相应的大写字母（'A'-'Z'）</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> num1 = <span class="number">111.1</span>;</span><br><span class="line">    <span class="keyword">double</span> num2 = <span class="number">111.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num1=%f\n"</span>,num1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num2=%lf\n"</span>,num2);</span><br><span class="line">    <span class="keyword">if</span>(num1==<span class="number">111.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"11111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num2==<span class="number">111.1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"22222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num1=<span class="number">111.099998</span></span><br><span class="line">num2=<span class="number">111.100000</span></span><br><span class="line"><span class="number">22222</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可见<blockquote>
<p>float数据类型表达的是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大<br>double数据类型表达的也是一个近似的数，不是准确的，小数点后的n位有误差，浮点数的位数越大，误差越大<br>float不可以用来比较是否相等，double可以</p>
</blockquote>
</li>
</ul>
<h3 id="常用库函数-1"><a href="#常用库函数-1" class="headerlink" title="常用库函数"></a>常用库函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atof</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *nptr)</span></span>;       <span class="comment">// 把字符串nptr转换为double</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fabs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// 求双精度实数x的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;     <span class="comment">// 求 x 的 y 次幂（次方）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> x)</span></span>;              <span class="comment">// double四舍五入</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;                 <span class="comment">// double向上取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> x)</span></span>;               <span class="comment">// double向下取整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fmod</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>;     <span class="comment">// 求x/y整除后的双精度余数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">modf</span><span class="params">(<span class="keyword">double</span> val,<span class="keyword">double</span> *ip)</span></span>; <span class="comment">// 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中，返回小数部分。</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="常用库函数-2"><a href="#常用库函数-2" class="headerlink" title="常用库函数"></a>常用库函数</h3><ul>
<li>获取字符串的长度（strlen）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span>  <span class="built_in">strlen</span>( <span class="keyword">const</span> <span class="keyword">char</span>*  str);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：计算字符串长度，不包含\0<br>返回值：返回字符串的字符数<br>strlen 函数计算的是字符串的实际长度，遇到第一个\0结束。<br>函数返回值一定是size_t，是无符号的整数，即typedef unsigned int size_t。<br>如果你只定义字符串没有初始化，结果是不定的，它会从首地址一直找下去，直到遇到\0停止。</p>
<p>还有一个注意事项，sizeof返回的是变量所占的内存数，不是实际内容的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(buf)为<span class="number">10</span>。</span><br><span class="line"><span class="built_in">strlen</span>(buf)是<span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串复制或赋值（strcpy）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功 能: 将参数src字符串拷贝至参数dest所指的地址。<br>返回值: 返回参数dest的字符串起始地址。<br>复制完字符串后，在dest后追加0。<br>如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串复制或赋值（strncpy）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：把src前n字符的内容复制到dest中<br>返回值：dest字符串起始地址。<br>如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。<br>如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0；<br>dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串拼接（strcat）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：将src字符串拼接到dest所指的字符串尾部。<br>返回值：返回dest字符串起始地址。<br>dest最后原有的结尾字符\0会被覆盖掉，并在连接后的字符串的尾部再增加一个\0。<br>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串拼接（strncat）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span> <span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。<br>返回值：返回dest字符串的起始地址。<br>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n大于字符串src的长度，只追加src的前n个字符。<br>strncat会将dest字符串最后的\0覆盖掉，字符追加完成后，再追加\0。<br>dest要有足够的空间来容纳要拼接的字符串，否则可能会造成缓冲溢出的错误情况。</p>
<ul>
<li>字符串比较（strcmp、strncmp）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2 )</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；<br>int strncmp(const char *str1,const char *str2 ,const size_t n);<br>功能：比较str1和str2的大小;返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；<br>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。<br>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</p>
<ul>
<li>字符查找（strchr、strrchr）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>返回一个指向在字符串s中第一个出现c的位置，如果找不到，返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">const</span> <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回一个指向在字符串s中最后一个出现c的位置，如果找不到，返回0。</p>
<ul>
<li>字符串查找（strstr）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">const</span> <span class="keyword">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>功能：检索子串在字符串中首次出现的位置。<br>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>css伪类标签</title>
    <url>/2019/10/12/css%E4%BC%AA%E7%B1%BB%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<a id="more"></a>

<table>
<thead>
<tr>
<th>伪类标签</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>a:link</code></td>
<td>普通的、未被访问的链接</td>
</tr>
<tr>
<td><code>a:visited</code></td>
<td>用户已访问的链接</td>
</tr>
<tr>
<td><code>a:hover</code>, <code>p:hover</code>, <code>#id:hover</code></td>
<td>鼠标指针位于链接的上方</td>
</tr>
<tr>
<td><code>a:active</code>, <code>p:active</code>, <code>#id:active</code></td>
<td>链接被点击的时刻</td>
</tr>
<tr>
<td><code>E:not(#p1)</code></td>
<td>所有的<code>&lt;E&gt;</code>标签，除了<code>id</code>为<code>p1</code>的</td>
</tr>
<tr>
<td><code>E:first-child</code></td>
<td>父类的第一个子级，如<code>li:first-child</code>表示选择所有作为第一个子级的<code>li</code></td>
</tr>
<tr>
<td><code>E:last-child</code></td>
<td>父类的最后一个子级，如<code>li:last-child</code>表示选择所有作为最后一个子级的<code>li</code></td>
</tr>
<tr>
<td><code>E:only-child</code></td>
<td>只有一个子级，如<code>li:only-child</code>表示选择<code>li</code>，且它的同级必须只有一个<code>li</code></td>
</tr>
<tr>
<td><code>E:empty</code></td>
<td>匹配为空的<code>&lt;E&gt;</code>标签</td>
</tr>
<tr>
<td><code>E:checked</code></td>
<td>匹配用户界面上处于选中状态的元素<code>&lt;E&gt;</code>，用于<code>input type</code>为<code>radio</code>与<code>checkbox</code>时，或<code>&lt;option&gt;</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>伪对象标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>E::before</code></td>
<td>在<code>&lt;E&gt;</code>前面添加内容</td>
</tr>
<tr>
<td><code>E::after</code></td>
<td>在<code>&lt;E&gt;</code>后面添加内容</td>
</tr>
</tbody></table>
<ul>
<li><p>当为链接的不同状态设置样式时，请按照以下次序规则：</p>
<blockquote>
<p>a:hover 必须位于 a:link 和 a:visited 之后<br>a:active 必须位于 a:hover 之后</p>
</blockquote>
</li>
<li><p>first-child实例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*注意不是ul:first-child*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line">            background-color: gold;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css1.png" alt="效果"></p>
</blockquote>
<ul>
<li>checked实例<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">option</span><span class="selector-pseudo">:checked</span>&#123;</span></span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* +表示同级 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">input</span><span class="selector-pseudo">:checked+span</span>&#123;</span></span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css2.png" alt="效果"></p>
</blockquote>
<ul>
<li>伪对象标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">            content: "你好";</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>效果<br><img src="css3.png" alt="效果"></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>css关系选择器和属性选择器</title>
    <url>/2019/10/11/css%E5%85%B3%E7%B3%BB%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><ul>
<li>包含关系选择器<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1 element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取所有包含于<code>element1</code>中的<code>element2</code>元素，可以是子级，孙级等等</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div p&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="css1.png" alt="结果"><br>只有<code>&lt;div&gt;</code>中的<code>&lt;p&gt;</code>设置了红色背景</p>
</blockquote>
<ul>
<li>父子关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1&gt;element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取包含于<code>element1</code>中的<code>element2</code>元素，只选取子级，孙级及以下不选取</p>
</blockquote>
<ul>
<li>相邻关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1+element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选取<code>element1</code>后面紧跟的第一个<code>element2</code>元素</p>
</blockquote>
<ul>
<li>兄弟关系<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element1~element2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>选择<code>element1</code>之后出现的所有<code>element2</code>,两种元素必须拥有相同的父元素，但是<code>element2</code>不必直接紧随<code>element1</code></p>
</blockquote>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li>只要包含某一个属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element[attribute]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性的元素</p>
</blockquote>
<ul>
<li>选取定值属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">element[attribute=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值为<code>value</code>的元素</p>
</blockquote>
<ul>
<li>选取包含某值的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute~=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值包含<code>value</code>元素，如<code>title~=abc</code>，则<code>title</code>中所有带有<code>abc</code>的都会被选中</p>
</blockquote>
<ul>
<li>选取以整个单词开头的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute|=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>开头的元素，如<code>title|=abc</code>，则<code>title</code>中所有以<code>abc</code>开头的都会被选中,该值必须是整个单词</p>
</blockquote>
<ul>
<li>选取以某个团素开头的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute^=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>开头的元素，如<code>title^=abc</code>，则<code>title</code>中所有以<code>abc</code>开头的都会被选中</p>
</blockquote>
<ul>
<li>选取以某个元素结尾的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute$=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值以<code>value</code>结尾的元素，如<code>title$=abc</code>，则<code>title</code>中所有以<code>abc</code>结尾的都会被选中</p>
</blockquote>
<ul>
<li>选择包含某个元素的属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[attribute*=value]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用于选取<code>element</code>带有<code>attribute</code>属性且它的值包含<code>value</code>，如<code>title*=abc</code>，则<code>title</code>中所有包含<code>abc</code>的都会被选中</p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css关系选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>css的布局和背景</title>
    <url>/2019/10/11/css%E7%9A%84%E5%B8%83%E5%B1%80%E5%92%8C%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><blockquote>
<p>常用布局格式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        header&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: goldenrod;</span><br><span class="line">        &#125;</span><br><span class="line">        aside&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:30</span>%;</span></span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: skyblue;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        article&#123;</span><br><span class="line"><span class="css">            <span class="comment">/*这里不要写70%，因为页面有一些其他元素需要一些空间*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:69</span>%;</span></span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        footer&#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: purple;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>效果<br><img src="css1.png" alt="布局"></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p><a href="https://www.w3school.com.cn/css/css_background.asp" target="_blank" rel="noopener">详细资料</a><br><img src="css2.png" alt="背景"></p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用css样式的方式和基础选择器</title>
    <url>/2019/10/10/%E4%BD%BF%E7%94%A8css%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="使用css的方式"><a href="#使用css的方式" class="headerlink" title="使用css的方式"></a>使用css的方式</h3><h4 id="段内导入"><a href="#段内导入" class="headerlink" title="段内导入"></a>段内导入</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"background-color:red;"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="head中定义"><a href="#head中定义" class="headerlink" title="head中定义"></a><code>head</code>中定义</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    p&#123;</span><br><span class="line">        background-color: gold;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后这个文件中所有的<code>&lt;p&gt;</code>都会为<code>gold</code>颜色</p>
</blockquote>
<h4 id="导入其他的css文件"><a href="#导入其他的css文件" class="headerlink" title="导入其他的css文件"></a>导入其他的css文件</h4><p>在<code>css</code>文件夹下新建<code>base.css</code>文件<br>在<code>&lt;head&gt;</code>中导入：</p>
<ul>
<li><p>导入方式一</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/base.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入方式二</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    @<span class="keyword">import</span> url(<span class="string">"base.css"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><blockquote>
<p>通用选择器是一个符号<code>*</code>，像通配符</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: 0<span class="selector-tag">px</span>;    <span class="comment">/*取消所有的外间距*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><blockquote>
<p>id在文件中最好是唯一的</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*使用#指定对应的id，多个id使用逗号隔开*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-id">#d1</span>, <span class="selector-id">#p1</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d1"</span>&gt;</span>你好，世界!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>你好世界!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/*使用.指定类，多个类之间用逗号隔开*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.cls1</span>, <span class="selector-class">.cls2</span>&#123;</span></span><br><span class="line">            background-color: purple;</span><br><span class="line">            margin: 3px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"cls1"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"cls1"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"cls2"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.baidu.com"</span> <span class="attr">class</span>=<span class="string">"cls2"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一个标签可以属于多个类，多个类之间用<code>空格</code>隔开</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"cls1 cls2"</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><blockquote>
<p>即指定对应的标签给定样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/*给所有的input标签指定样式*/</span></span></span><br><span class="line">    input&#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h4><ul>
<li>id&gt;class&gt;标签&gt;通配符</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html5新增标签</title>
    <url>/2019/10/10/html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>详细的html教程 <a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">w3school</a></p>
<a id="more"></a>
<h2 id="常见的新增语义标签"><a href="#常见的新增语义标签" class="headerlink" title="常见的新增语义标签"></a>常见的新增语义标签</h2><p><code>&lt;header&gt;</code>: 页面头部<br><code>&lt;footer&gt;</code>: 页脚<br><code>&lt;article&gt;</code>: 定义页面独立的内容区域<br><code>&lt;aside&gt;</code>: 定义页面的侧边栏内容<br><a href="#details"><code>&lt;</code>details<code>&gt;</code></a>: 文档某个部分的细节<br><code>&lt;summary&gt;</code>: 是detail中的标题<br><code>&lt;figure&gt;</code>: 独立的文档流，在<code>&lt;figure&gt;</code>中定义的内容会自动缩进一部分<br><code>&lt;figcaption&gt;</code>: 是<code>&lt;figure&gt;</code>的标题<br><code>&lt;mark&gt;</code>: 重点标记，高亮显示<br><code>&lt;nav&gt;</code>: 导航连接<br><a href="#ruby"><code>&lt;</code>ruby<code>&gt;</code></a>: 加注释<br><a href="#datalist"><code>&lt;</code>datalist<code>&gt;</code></a>: 提示框<br><a href="#meter"><code>&lt;</code>meter<code>&gt;</code></a>: 用来表示范围已知且可度量的内容<br><a href="#progress"><code>&lt;</code>progress<code>&gt;</code></a>: 进度条，<code>max</code>指定最大值，<code>value</code>属性指定当前进度<br><a href="#audio"><code>&lt;</code>audio<code>&gt;</code></a>: 播放音频<br><a href="#video"><code>&lt;</code>video<code>&gt;</code></a>: 播放视频<br><a href="#embed"><code>&lt;</code>embed<code>&gt;</code></a>: 嵌入插件，网页<br><a href="#画布">画布</a></p>
<h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4><p><code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>联用</p>
<blockquote>
<p><code>&lt;summary&gt;</code>默认为<em>详细信息</em></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>点击查看<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是一张动漫图<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/img_1.jpg"</span> <span class="attr">width</span>=<span class="string">"80px"</span> <span class="attr">height</span>=<span class="string">"50px"</span> <span class="attr">alt</span>=<span class="string">"动漫"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h1.png" alt="效果"><br>点击查看后<br><img src="h2.png" alt="效果"></p>
</blockquote>
<h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><ul>
<li>加拼音，使用<code>&lt;rt&gt;</code>标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">    汪<span class="tag">&lt;<span class="name">rt</span>&gt;</span>w<span class="tag">&lt;<span class="name">ruby</span>&gt;</span>a<span class="tag">&lt;<span class="name">rt</span>&gt;</span>_<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span>ng<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行<br><img src="h3.png" alt="注释"></p>
</blockquote>
<h4 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h4><ul>
<li>和<code>&lt;input&gt;</code>联用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用list指定数据来源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">list</span>=<span class="string">"mydata"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用id指定名称，不是name--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"mydata"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用value指定提示内容--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--中间的文字是一些其他附属信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>热度100<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"bcd"</span>&gt;</span>热度70<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"emm"</span>&gt;</span>热度50<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"bat"</span>&gt;</span>热度30<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="h4.png" alt="datalist"><br>当键入<code>a</code>时，自动弹出了和<code>a</code>相关的提示</p>
<h4 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h4><blockquote>
<p>比较大小</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0<span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"40"</span>&gt;</span><span class="tag">&lt;/<span class="name">meter</span>&gt;</span>100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h5.png" alt="meter"></p>
</blockquote>
<h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><blockquote>
<p>进度条</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0<span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"80"</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span>100</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h6.png" alt="meter"></p>
</blockquote>
<h4 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h4><ul>
<li>属性<br><code>src</code>: 音频地址<br><code>autoplay</code>: 自动播放<br><code>controls</code>: 显示控件，比如播放按钮<br><code>loop</code>: 循环播放<blockquote>
<p>可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"someaudio.mp3"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 audio 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><ul>
<li>属性部分同<code>audio</code><br><code>width</code>: 设置宽度<br><code>height</code>: 设置高度<br><code>poster</code>: 设置封面</li>
</ul>
<h4 id="embed"><a href="#embed" class="headerlink" title="embed"></a>embed</h4><blockquote>
<p>定义嵌入的内容，比如插件，网页。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">"/i/helloworld.swf"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="h7.png" alt="embed"><br>成功嵌入了网页，并且可以使用网页的功能</p>
</blockquote>
<h4 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h4><p><code>&lt;canvas&gt;</code>标签用于绘制标签，<canvas> 元素本身并没有绘制能力（它仅仅是图形的容器，必须使用脚本来完成实际的绘图任务。</canvas></p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title>晒晒自己的桌面</title>
    <url>/2019/10/06/%E6%99%92%E6%99%92%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<a id="more"></a>
<p><img src="desktop.png" alt="桌面"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>桌面</tag>
        <tag>i3</tag>
      </tags>
  </entry>
  <entry>
    <title>安装谷歌访问助手</title>
    <url>/2019/10/06/%E5%AE%89%E8%A3%85%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<a id="more"></a>

<p>&emsp;&emsp;众所周知，谷歌浏览器最牛逼的地方就是在于插件众多，而插件可以提供丰富的用法，从而造就谷歌丰富的功能。一般来说，谷歌插件（也叫扩展）可以在谷歌应用商店下载安装，但是emmmm没办法直接上应用商店下载，但是有一个谷歌插件完美解决了这个问题，那就是<strong>谷歌访问助手</strong>。</p>
<p>&emsp;&emsp;本篇文章要讲的就是如何安装<strong>谷歌访问助手</strong>，然后利用这个插件登上应用商店，下载各种各样的谷歌插件，走向人生巅峰！</p>
<h2 id="1-下载谷歌访问助手的安装包"><a href="#1-下载谷歌访问助手的安装包" class="headerlink" title="1.下载谷歌访问助手的安装包"></a>1.下载谷歌访问助手的安装包</h2><p>链接：<a href="https://pan.baidu.com/s/1gjbVfFjDRQvUcKjNfYeAXQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1gjbVfFjDRQvUcKjNfYeAXQ</a>  提取码：x9ox</p>
<ul>
<li><p>首先就是下载这个安装包，然后解压，解压后是一个文件夹，而不是一个单纯的.crx文件，现在单纯的.crx文件已经不能直接安装在浏览器上了。</p>
</li>
<li><p>解压后打开谷歌浏览器，点击浏览器右上角的三个竖点点，点击更多工具—&gt;扩展程序（当然，也可以直接在地址栏中输入chrome://extensions/，和这些操作结果是一样的。）</p>
</li>
</ul>
<p>如下图<img src="https://img-blog.csdnimg.cn/20190731082506181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>进入这个扩展程序页面（即插件页面）</p>
<p><img src="https://img-blog.csdnimg.cn/20190731082613464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>记得打开<strong>开发者模式</strong>。</p>
<ul>
<li>将刚才解压好的文件夹里的文件夹直接拖进来。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083342927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>拖进来就直接安装了（因为我之前安装过，为了演示删掉重装，没安装过得应该可能会弹出提示，点击确定就行了）</p>
<p><img src="https://img-blog.csdnimg.cn/201907310836365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>点击永久免费激活，进入如下图页面，再点击往选项页面</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083813800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>勾选网址</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731083912722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>安装好了就是这个样子</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190731084013654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTE1NzIyMw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>温馨提示：有时候这个插件是灰色的，不能用就刷新重启，不然就把浏览器关了再来。</p>
</li>
<li><p>接下去就是去谷歌应用商店愉快地下载插件了，点击应用，我的是在浏览器左上角<img src="https://img-blog.csdnimg.cn/20190731084201348.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>转自：<a href="https://www.jianshu.com/p/ca06b16613cc" target="_blank" rel="noopener">https://www.jianshu.com/p/ca06b16613cc</a></p>
]]></content>
      <categories>
        <category>problems</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>arch下PKGBUILD包的安装</title>
    <url>/2019/10/04/arch%E4%B8%8BPKGBUILD%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>cd到有<code>PKGBUILD</code>文件的目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成后缀.pkg.tar.xz的压缩文件</span></span><br><span class="line">makepkg</span><br><span class="line"><span class="comment"># 使用pacman安装</span></span><br><span class="line">sudo pacman -U *.pkg.tar.xz</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>PKGBUILD</tag>
      </tags>
  </entry>
  <entry>
    <title>polybar主题配置</title>
    <url>/2019/10/04/polybar%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<a id="more"></a>

<blockquote>
<p>折腾了一天的<code>polybar</code>主题，来记录一下</p>
</blockquote>
<h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><ul>
<li>首先，你已经下好了polybar</li>
<li>然后下载<code>polybar</code>的主题<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/adi1090x/polybar-themes.git</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>然后在<code>.config</code>目录下就会有一个名为<code>polybar-themes</code>的文件夹</p>
</blockquote>
<h2 id="配置字体"><a href="#配置字体" class="headerlink" title="配置字体"></a>配置字体</h2><ul>
<li>就会看到一共九个主题，每个主题下都有一个名为<code>fonts</code>的文件夹，想要使用哪个主题，先将主题的字体复制到你系统的字体文件夹下<blockquote>
<p>这个字体我搞了好长时间(大概一下午加晚上)，一直以为要自己下载，下载了还显示不出来，原来他自带，我….</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> polybar-themes</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以<code>polybar-6</code>为例，它的字体目录如下</p>
<p><img src="p1.png" alt="字体"></p>
<p>我的字体目录是<code>/usr/share/fonts/</code>，我的<code>ttf</code>尾缀的字体在<code>/usr/share/fonts/TTF/</code>下，所以我将<code>ttf</code>字体复制到这里面，然后<code>termsyn</code>是个字体文件夹，直接放在<code>fonts</code>目录下即可，<code>siji</code>放在<code>/usr/share/fonts/misc/</code>下</p>
<blockquote>
<p>最后将原来的<code>~/.config/polybar/</code>这个目录改个名字，如果不需备份的话直接删除就好了，然后我用的<code>polybar-5</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r ~/.config/polybar-themes/polybar-5 ~/.config/polybar</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来运行脚本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.config/polybar/</span><br><span class="line">./launsh.sh</span><br></pre></td></tr></table></figure>

<h2 id="配置-polybar-5"><a href="#配置-polybar-5" class="headerlink" title="配置(polybar-5)"></a>配置(polybar-5)</h2><ul>
<li>如果想更改标题栏顺序，可以在主题中<code>config.ini</code>中修改<br>建议将<code>[bar/top]</code>下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules-left = menu title right-end-top left-end-bottom workspaces right-end-top left-end-bottom colors-switch right-end-top</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules-left = menu workspaces right-end-top left-end-bottom colors-switch right-end-top left-end-bottom title right-end-top</span><br></pre></td></tr></table></figure>

<p>用起来感觉好些</p>
<ul>
<li><p>如果要更改左上角菜单栏中<code>Files</code>，<code>Terminal</code>等的程序，可以在主题下<code>user_modules.ini</code>中<code>[module/menu]</code>下更改</p>
</li>
<li><p>解决polybar显示不了中文<br>打开主题目录下<code>config.ini</code>，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-0 = Iosevka Nerd Font:style=Medium:size=14;3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-0 = unifont:style=Medium:size=14;3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然也可以下载其他支持中文的字体</p>
</blockquote>
<ul>
<li>我用的<code>i3wm</code>所以它的右上角<code>powermenu</code>菜单中<code>logout</code>用不了</li>
</ul>
<p>首先下载<code>i3exit</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S i3exit</span><br></pre></td></tr></table></figure>

<p>然后更改主题文件夹下<code>scripts/powermenu</code>，将</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*Logout) openbox --<span class="built_in">exit</span> ;;</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*Logout) i3exit <span class="built_in">logout</span> ;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>polybar</tag>
      </tags>
  </entry>
  <entry>
    <title>html表格表单</title>
    <url>/2019/10/03/html%E8%A1%A8%E6%A0%BC%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul>
<li><code>&lt;caption&gt;</code>标签：表格标题</li>
<li><code>&lt;table&gt;</code>标签：声明一个表格，它的常用属性如下<ul>
<li><code>bgcolor</code>：定义背景色</li>
<li><code>background</code>：背景图片</li>
<li><code>border</code>：定义表格的边框，设置值是数值</li>
<li><code>bordercolor</code>：定义表格的边框的颜色</li>
<li><code>width</code>：表格宽度</li>
<li><code>height</code>：表格高度</li>
<li><code>cellpadding</code>：定义单元格内容与边框之间的间距，设置值是数值</li>
<li><code>cellspacing</code>：定义单元格与单元格之间的间距，设置值是数值</li>
<li><code>align</code>：设置整体表格相对于浏览器窗口的水平对齐方式，设置值有<code>left</code>，<code>center</code>，<code>right</code></li>
</ul>
</li>
<li><code>&lt;tr&gt;</code>标签：定义表格中的一行</li>
<li><code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>标签：定义一行中的一个单元格，<code>&lt;td&gt;</code>表示普通单元格，<code>&lt;th&gt;</code>表示表头单元格，常用属性如下<ul>
<li><code>align</code>：设置单元格中的内容水平对齐方式，设置值有<code>left</code>，<code>center</code>，<code>right</code></li>
<li><code>valign</code>：设置单元格中内容垂直对齐方式：设置值有<code>top</code>，<code>middle</code>，<code>bottom</code></li>
<li><code>colspan</code>：设置单元格水平合并，设置值是数值</li>
<li><code>rowspan</code>：设置单元格垂直合并，设置值是数值</li>
<li><code>bgcolor</code>：设置背景色</li>
</ul>
</li>
</ul>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><blockquote>
<p>用于收集不同类型的用户输入</p>
</blockquote>
<h4 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h4><ul>
<li>定义整体的表单区域<blockquote>
<p> <code>action</code>属性定义表单数据提交地址</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>登陆界面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"success.html"</span>&gt;</span>    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入帐号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入手机号或者邮箱"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>另外在当前目录下新建一个<code>success.html</code>显示内容为<strong>欢迎你</strong></p>
<blockquote>
<p>运行</p>
</blockquote>
<p><img src="ht_3.png" alt="action"><br>点击登录<br><img src="ht_4.png" alt="登录"></p>
<p>成功跳转</p>
<blockquote>
<p><code>method</code>属性定义表单提交的方式，一般有<code>get</code>和<code>post</code>方式<br><code>post</code>方法通常用于提交数据，数据的内容不会显示在浏览器的地址栏中，且对数据的长度没有限制。<br><code>get</code>方法会将你的数据在浏览器地址栏中显示出来，而且由于URL长度有限，所以传递的数据长度也受限制。</p>
</blockquote>
<h4 id="lt-input-gt-标签："><a href="#lt-input-gt-标签：" class="headerlink" title="&lt;input&gt;标签："></a><code>&lt;input&gt;</code>标签：</h4><blockquote>
<p><code>type</code>属性：<br>  type=”text”：输入文本<br>  type=”password”：输入密码<br>  type=”submit”：提交表单，显示文字默认是<strong>提交</strong>，可以使用<code>value=&quot;&quot;</code>更改<br>  type=”reset”：清空数据，显示文字默认是<strong>重置</strong>，可以使用<code>value=&quot;&quot;</code>更改<br>  type=”botton”：自定义按键<br>  type=”checkbox”：多选框<br>  type=”radio”：单选框，必须有<code>name</code>属性，且<code>name</code>值必须相同<br>  type=”hidden”：隐藏<br>  type=”file”：上传文件<br>h5新增：<br>  type=”date”：输入日期<br>  type=”week”：输入第几周<br>  type=”url”：输入网址<br>  type=”email”：输入邮箱<br>  type=”cloor”：输入颜色<br>  type=”range”：还需要设定最小值，最大值，是一个拖动条<br>  type=”search”：搜索内容</p>
</blockquote>
<blockquote>
<p><code>name</code>属性：为输入内容定义名字</p>
</blockquote>
<blockquote>
<p><code>checked</code>属性：布尔类型，在某个单选或复选框内加入表示默认选择</p>
</blockquote>
<blockquote>
<p><code>required</code>属性：布尔类型，加上它表示此项必须要填</p>
</blockquote>
<blockquote>
<p><code>readonly</code>属性：布尔类型，只读，表示只能查看，不能修改</p>
</blockquote>
<blockquote>
<p><code>value</code>属性：<br>存储填入的值</p>
<ul>
<li><code>placeholder</code>：提示信息</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入帐号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入手机号或者邮箱"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="ht_1.png" alt="提示信息"></p>
</blockquote>
<h4 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h4><ul>
<li><code>&lt;select&gt;</code>标签：定义下拉框区域<blockquote>
<p><code>size</code>属性：定义显示的下拉菜单中的数量</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>name</code>属性：定义名称</p>
<ul>
<li><code>&lt;option&gt;</code>标签：下拉框中的选项<br><code>selected</code>属性：布尔类型，表示缺省选择这个选项</li>
</ul>
</blockquote>
<ul>
<li><code>&lt;optgroup&gt;</code>标签：定义下拉框组，里面继续嵌套<code>&lt;option&gt;</code></li>
</ul>
<h4 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h4><ul>
<li><code>&lt;textarea&gt;</code>标签:<blockquote>
<p><code>rows</code>：定义行数<br><code>cols</code>：定义列数</p>
</blockquote>
</li>
<li><code>placeholder</code>：提示信息</li>
</ul>
<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><blockquote>
<p>一般可以给如上面的<em>请输入帐号</em>加一个<code>&lt;label&gt;</code>标签，无实际效果，只是为了后面加样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>请输入帐号<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>注册表单<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span> 男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span> 女</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>爱&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 看电影</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 学习</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span> 读书</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>照&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;片：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"photo"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>描&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;述：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span>籍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;贯：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>天津<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>重庆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果<br><img src="ht_2.png" alt="表单"></p>
</blockquote>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>html基本标签</title>
    <url>/2019/10/02/html%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="html基本结构"><a href="#html基本结构" class="headerlink" title="html基本结构"></a>html基本结构</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        网页显示内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h2><ul>
<li>属性(不推荐使用)：<ul>
<li><code>bgcolor</code>：设置背景色</li>
<li><code>background</code>：设置背景图</li>
</ul>
</li>
</ul>
<h2 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释内容--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><ul>
<li>通过<code>&lt;h1&gt;</code>，<code>&lt;h2&gt;</code>…<code>&lt;h6&gt;</code>来确定标题等级<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式的段落中首段开头的空格和换行不会识别，段落中的多个空格只识别一个<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>    这是  一段</span><br><span class="line">内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<p><img src="ht_1.png" alt="结果"></p>
<h3 id="html字符实体"><a href="#html字符实体" class="headerlink" title="html字符实体"></a>html字符实体</h3><table>
<thead>
<tr>
<th>字符</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>换行符</td>
<td><code>&lt;br /&gt;</code></td>
</tr>
</tbody></table>
<h2 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a><div>块标签</div></h2><blockquote>
<p>块元素，表示一块内容，没有具体的语义<br>可以设置宽高，缺省为内容的高度，宽为整个网页<br>独占一行，两个块之间默认换行</p>
<ul>
<li>与<code>&lt;p&gt;&lt;/p&gt;</code>的区别，在<code>body</code>中写如下内容</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">一段   内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<p><img src="ht_2.png" alt="区别"></p>
<blockquote>
<p>可以看到，<code>p</code>标签两端内容间有空行，即<code>p</code>标签是带有格式的，而<code>div</code>没有格式</p>
</blockquote>
<h2 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a><span>内联标签</span></h2><blockquote>
<p>行内标签，表示一行中的一小段内容，没有具体的语义(在做样式的地方会用到)<br>不能嵌套换行<br>不能设置宽高，宽高都是内容的宽高</p>
</blockquote>
<h2 id="font标签"><a href="#font标签" class="headerlink" title="font标签"></a>font标签</h2><ul>
<li>属性：<ul>
<li><code>color</code>：设置字体颜色</li>
<li><code>size</code>：设置字体大小 </li>
</ul>
</li>
</ul>
<h2 id="含样式和语义的标签"><a href="#含样式和语义的标签" class="headerlink" title="含样式和语义的标签"></a>含样式和语义的标签</h2><ul>
<li><code>&lt;em&gt;</code>标签：行内元素，表示语气中的强调词，倾斜</li>
<li><code>&lt;i&gt;</code>标签：行内元素，表示专业词汇，倾斜</li>
<li><code>&lt;b&gt;</code>标签：行内元素，表示文档中的关键词或者产品名，加粗</li>
<li><code>&lt;strong&gt;</code>标签：行内元素，表示非常重要的内容，加粗</li>
<li><code>&lt;u&gt;</code>：下划线</li>
<li><code>&lt;del&gt;</code>：删除线</li>
<li><code>&lt;sup&gt;</code>：上标，如<code>x&lt;sup&gt;2&lt;/sup&gt;</code></li>
<li><code>&lt;sub&gt;</code>：下标，如<code>x&lt;sub&gt;2&lt;/sub&gt;</code></li>
<li><code>&lt;address&gt;</code>：地址标签，倾斜</li>
<li><code>&lt;pre&gt;</code>：预编译，不推荐使用，即写入什么格式就显示什么</li>
<li><code>&lt;big&gt;</code>：字体稍大</li>
<li><code>&lt;small&gt;</code>：字体稍小</li>
</ul>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片路径 "</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>width</code>:宽度</li>
<li><code>height</code>:高度</li>
<li><code>alt</code>:图片不能显示时的显示文字 </li>
<li><code>title</code>:鼠标悬浮在图片上显示的文字</li>
</ul>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span> <span class="attr">title</span>=<span class="string">"鼠标悬停时的描述信息"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>文字或图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>href=&quot;#&quot;</code>：表示跳转到顶部<br><code>target=&quot;_self&quot;</code>：使用框架，替换当前区域，不设定时默认为<code>_self</code><br><code>target=&quot;_parent&quot;</code>：使用框架，替换父级页面<br><code>target=&quot;_top&quot;</code>：使用框架，替换全局页面<br><code>target=&quot;_blank&quot;</code>：新开一个页面</p>
</blockquote>
<ul>
<li><p>跳转到指定位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#test"</span>&gt;</span>点我跳转到hello<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>点我跳转百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以使用图片跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/bd.jpg"</span> <span class="attr">alt</span>=<span class="string">"百度logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="有序标签"><a href="#有序标签" class="headerlink" title="有序标签"></a>有序标签</h3><ul>
<li><p>定义有序列表可以用<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>配合使用来使用，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>属性：<br>type=”1”：12345<br>type=”a”：abcde<br>type=”A”：ABCDE<br>type=”i”：i ii iii<br>type=”I”：罗马字母</p>
</li>
</ul>
<blockquote>
<p>执行结果: </p>
</blockquote>
<p><img src="ht_3.png" alt="执行结果"></p>
<blockquote>
<p>可以使用快捷键生成列表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- 生成五个有序列表 --&gt;</span><br><span class="line">ol&gt;li*<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li><p>定义无序列表可以用<code>&lt;ul&gt;</code>和<code>&lt;li&gt;</code>配合使用来使用，可嵌套，代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"disc"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表文字三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>type</code>属性：<br>type=”none”：无<br>type=”disc”：默认黑色圆点<br>type=”circle”：空心圆点<br>type=”square”：方块</p>
</li>
</ul>
<blockquote>
<p>执行结果: </p>
</blockquote>
<p><img src="ht_4.png" alt="执行结果"></p>
<blockquote>
<p>可以使用快捷键生成列表</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;!-- 生成五个有序列表 --&gt;</span><br><span class="line">ul&gt;li*<span class="number">5</span></span><br></pre></td></tr></table></figure>


<h3 id="列表嵌套链接"><a href="#列表嵌套链接" class="headerlink" title="列表嵌套链接"></a>列表嵌套链接</h3><ul>
<li><p>一般标题是可以点击跳转的，所以对标题增加链接功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用快捷键生成上述内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ul&gt;(li&gt;a&#123;列表标题&#125;)*3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><ul>
<li>定义列表通常用于术语的定义，<code>&lt;dl&gt;</code>标签定义术语的题目，<code>&lt;dd&gt;</code>标签是术语的解释，一个<code>&lt;dl&gt;</code>中可以有多个题目和解释<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>html<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>超文本标记语言<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Http<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>超文本传输协议<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Url<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>统一资源定位符<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<p><img src="ht_5.png" alt="结果"></p>
<ul>
<li>快捷键<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">dl&gt;(dt+dd)*3</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html基础</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2019/09/27/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>cowsay软件--linux轻松一下</title>
    <url>/2019/09/27/cowsay%E8%BD%AF%E4%BB%B6-linux%E8%BD%BB%E6%9D%BE%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cowsay 文本</span></span><br><span class="line">cowsay hahaha</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="cow.png" alt="cow"></p>
</blockquote>
<h3 id="使用其他动物"><a href="#使用其他动物" class="headerlink" title="使用其他动物"></a>使用其他动物</h3><h4 id="罗列所有动物"><a href="#罗列所有动物" class="headerlink" title="罗列所有动物"></a>罗列所有动物</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowsay -l</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cow files in /usr/share/cows:</span><br><span class="line">beavis.zen blowfish bong bud-frogs bunny cheese cower daemon default dragon</span><br><span class="line">dragon-and-cow elephant elephant-in-snake eyes flaming-sheep ghostbusters</span><br><span class="line">head-in hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose</span><br><span class="line">mutilated ren satanic sheep skeleton small sodomized stegosaurus stimpy</span><br><span class="line">supermilker surgery telebears three-eyes turkey turtle tux udder vader</span><br><span class="line">vader-koala www</span><br></pre></td></tr></table></figure>

<h4 id="切换动物"><a href="#切换动物" class="headerlink" title="切换动物"></a>切换动物</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如换成dragon-and-cow</span></span><br><span class="line">cowsay -f dragon-and-cow hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行<br><img src="cow_d.png" alt="cow_dragon"></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cowsay</tag>
        <tag>字符软件</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式re模块</title>
    <url>/2019/09/26/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h2><blockquote>
<p><code>match()</code>方法默认判断开头</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入re模块</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用match方法查看是否满足规则，如果匹配失败，返回None</span><br><span class="line"># 字符串前加r表示这是非转义的原始字符串</span><br><span class="line">ret = re.match(r&quot;指环王[1-3]&quot;, &quot;指环王2&quot;)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"># 可以使用group方法查看匹配的对象</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;指环王2&apos;&gt;</span><br><span class="line">指环王2</span><br></pre></td></tr></table></figure>

<h2 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h2><blockquote>
<p><code>search</code>可以从文章的任意位置开始，但只能找到第一个满足条件的文本</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = re.search(<span class="string">r"\d+"</span>, <span class="string">"阅读次数为：4567; 点赞数为：345"</span>)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4567</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>match</code>则<code>4567</code>必须在开头才能被匹配到<br>只能取到第一个满足的文本</p>
</blockquote>
<h2 id="findall方法"><a href="#findall方法" class="headerlink" title="findall方法"></a>findall方法</h2><ul>
<li>可以检索到所有满足条件的文本<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = re.findall(<span class="string">r"\d+"</span>, <span class="string">"阅读次数为：4567; 点赞数为：345"</span>)</span><br><span class="line"><span class="comment"># 无需调用group，直接返回列表</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;4567&apos;, &apos;345&apos;]</span><br></pre></td></tr></table></figure>

<h2 id="sub方法"><a href="#sub方法" class="headerlink" title="sub方法"></a>sub方法</h2><ul>
<li><p>可以更改数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.sub(<span class="string">r"正则表达式"</span>, <span class="string">"要替换的文本"</span>, <span class="string">"被替换的文本"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = re.sub(<span class="string">r"\d+"</span>, <span class="string">"123米"</span>, <span class="string">"长达4324, 宽为678"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长达123米, 宽为123米</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全部都被替换了</p>
</blockquote>
<h3 id="嵌入表达式"><a href="#嵌入表达式" class="headerlink" title="嵌入表达式"></a>嵌入表达式</h3><ul>
<li><code>sub()</code>还支持调用表达式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(temp)</span>:</span></span><br><span class="line">    num = int(temp.group())</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> str(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new_content1 = re.sub(<span class="string">r"\d+"</span>, add, <span class="string">"长达4324, 宽为678"</span>)</span><br><span class="line">print(new_content1)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">长达4325, 宽为679</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现了数据<code>+1</code>的操作</p>
</blockquote>
<h2 id="spilt方法"><a href="#spilt方法" class="headerlink" title="spilt方法"></a>spilt方法</h2><ul>
<li>根据匹配进行切割字符串，并返回一个列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逗号，分号或空格分开字符串</span></span><br><span class="line">result = re.split(<span class="string">r",|;| "</span>, <span class="string">"abc def,gh;ij"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;abc&apos;, &apos;def&apos;, &apos;gh&apos;, &apos;ij&apos;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>re模块</tag>
      </tags>
  </entry>
  <entry>
    <title>IAR的基本使用</title>
    <url>/2019/09/26/iar_use/</url>
    <content><![CDATA[<h1 id="IAR"><a href="#IAR" class="headerlink" title="IAR"></a>IAR</h1><!-- vim-markdown-toc Redcarpet -->

<ul>
<li><a href="#iar软件界面介绍">IAR软件界面介绍</a><ul>
<li><a href="#如何显示工具栏">如何显示工具栏</a></li>
<li><a href="#更改字体">更改字体</a></li>
</ul>
</li>
<li><a href="#常用操作">常用操作</a><ul>
<li><a href="#新建并添加源文件">新建并添加源文件</a><ul>
<li><a href="#创建源文件">创建源文件</a></li>
<li><a href="#添加源文件">添加源文件</a></li>
</ul>
</li>
<li><a href="#管理文件">管理文件</a><ul>
<li><a href="#多文件">多文件</a></li>
<li><a href="#头文件管理">头文件管理</a><ul>
<li><a href="#头文件的一些说明">头文件的一些说明</a></li>
</ul>
</li>
<li><a href="#分组管理">分组管理</a></li>
</ul>
</li>
<li><a href="#分屏">分屏</a></li>
<li><a href="#livewatch功能">Livewatch功能</a></li>
<li><a href="#断点调试">断点调试</a></li>
</ul>
</li>
<li><a href="#常用快捷键">常用快捷键</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="IAR软件界面介绍"><a href="#IAR软件界面介绍" class="headerlink" title="IAR软件界面介绍"></a>IAR软件界面介绍</h2><p><img src="iar_1.png" alt="界面"></p>
<ul>
<li>一个标准的<strong>IDE界面</strong></li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> 菜单栏：涵盖几乎所有用户需要的功能</li>
<li><input checked disabled type="checkbox"> 工具栏：放置一些常用的功能，便于调用</li>
<li><input checked disabled type="checkbox"> 标签栏：显示用户打开的文件，方便切换</li>
<li><input checked disabled type="checkbox"> 文件目录树：显示用户文件目录树形结构，方便查找切换</li>
<li><input checked disabled type="checkbox"> 编程区域：占据了大部分空间，是我们写代码的地方</li>
<li><input checked disabled type="checkbox"> 结果显示窗口：相当于控制台，输出文件编译信息，如错误，警告</li>
</ul>
<h3 id="如何显示工具栏"><a href="#如何显示工具栏" class="headerlink" title="如何显示工具栏"></a>如何显示工具栏</h3><ul>
<li>可能有些同学没有图中的工具栏区域<blockquote>
<p>勾选<code>Windows-&gt;Toolbar-&gt;Main</code>即可显示工具栏<br><img src="iar_2.png" alt="工具栏"></p>
</blockquote>
</li>
</ul>
<h3 id="更改字体"><a href="#更改字体" class="headerlink" title="更改字体"></a>更改字体</h3><ul>
<li>默认的界面字体太小而且颜色单一，不利于阅读，和区分不同类型的代码，如关键字，注释等等</li>
<li>通过<code>按住Ctrl+滑动滚轮</code>的方式可以调节当前文件的字体</li>
<li>通过设置选项个人化配置：<code>Tools-&gt;Options-&gt;Editor-&gt;Colors and Fonts</code><br><img src="iar_16.png" alt="改字体"></li>
</ul>
<p><img src="iar_18.png" alt="改字体"></p>
<hr>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="新建并添加源文件"><a href="#新建并添加源文件" class="headerlink" title="新建并添加源文件"></a>新建并添加源文件</h3><h4 id="创建源文件"><a href="#创建源文件" class="headerlink" title="创建源文件"></a>创建源文件</h4><blockquote>
<ul>
<li>点击工具栏的新建文件选项<br><img src="iar_3.png" alt="工具栏创建"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>点击<code>File-&gt;New File</code><br><img src="iar_4.png" alt="菜单栏创建"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在这里我们可以看到右侧有快捷键提示，所以我们也可以使用<code>Ctrl+n</code>来创建一个未命名的空文件，创建后，会出现一个名为<code>untitled</code>的空白文件<br><img src="iar_5.png" alt="空白文件"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>我们鼠标<strong>右键单击</strong>标签栏中的空白文件名称，选择<code>Save Untitled</code>保存该文件，当然，你可可以直接使用<code>Ctrl+s</code>进行保存<br><img src="iar_6.png" alt="保存"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>一般我们保存在当前工程下的<code>app</code>目录下，如我当前的工程根目录是<code>LPLD_OSKinetis_V3/project/gsproject/</code>，那么我保存在<code>LPLD_OSKinetis_V3/project/gsproject/app</code>下，并且为这个文件起一个有意义的名字，<strong>如果是程序文件，则后缀名是<code>.c</code>，如果是头文件，后缀名是<code>.h</code></strong>，<blockquote>
<p>文件名字中，以及你的工程路径中都尽量不要包含中文，这和编码解码有关，可能导致无法预知的错误<br>文件名不要使用数字开头或者包含特殊符号，尽量以字母开头，使用字母，下划线，数字的组合，如<code>my_test1.c</code><br><img src="iar_7.png" alt="保存"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h4><ul>
<li><p>尽量将自己写的文件新建一个<code>Group</code>进行存放，以免和底层别人写的库函数混淆</p>
</li>
<li><p>创建<code>Group</code>：<code>右键单击文件目录树最顶层-&gt;Add-&gt;Add Group...</code>，之后输入你的组名字即可创建（不要有中文）<br><img src="iar_8.png" alt="Group"></p>
</li>
<li><p>添加源文件：<code>右键单击组-&gt;Add-&gt;Add Files...</code>，去刚才保存文件的目录下选择文件保存即可<br><img src="iar_9.png" alt="Add File"></p>
</li>
</ul>
<hr>
<h3 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h3><h4 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h4><ul>
<li>在智能车竞赛的开发中会建立函数，变量，建议将共同实现某一功能的程序放置在一个文件，而其他功能的程序根据所达成的功能分别创建不同的文件存放，方便查询，修改<blockquote>
<p>如建立名为<code>Motor.c</code>的文件存放电机驱动程序，<code>Motor.h</code>的文件声明全局变量，函数</p>
</blockquote>
</li>
</ul>
<h4 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h4><ul>
<li><p>在开发中会建立许多功能不同的程序文件，而他们之间往往需要引用到同一个头文件，假设有十个文件都需要引用<code>Camera.h</code>，<code>Motor.h</code>，<code>Oled.h</code>等等，那么你就需要在这十个文件的开头都写上</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Camera.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Motor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Oled.h"</span></span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>不免有些重复，所以我们可以建立一个名为<code>Include.h</code>的头文件（名字可以任取，起这个是为了<strong>见名知意</strong>），而将需要多次引用的头文件写在这个文件里，其他文件只需要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Include.h"</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>就可以导入这个文件中所有声明过的文件</p>
</li>
</ul>
<h5 id="头文件的一些说明"><a href="#头文件的一些说明" class="headerlink" title="头文件的一些说明"></a>头文件的一些说明</h5><ul>
<li><input checked disabled type="checkbox"> 防止重复编译<blockquote>
<p>大家应该在程序头文件中经常看到下面的代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOME_TEXT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOME_TEXT_H</span></span><br><span class="line"></span><br><span class="line">...  <span class="comment">//全局变量，函数声明，结构体定义等等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>那么，他有什么作用呢？</p>
<blockquote>
<p>直观可以看出，<code>ifndef</code>是<code>if not define</code>的缩写，前面有<code>#</code>是C语言中预编译指令的写法，也就是<em>如果<code>_SOME_TEXT_H</code>没有被定义，则定义<code>_SOME_TEXT_H</code></em>，并执行下面的代码，直到<code>#endif</code><br>我们设想一下，当多个文件<code>#include</code>同一个头文件的时候，没有上面的代码，那么每导入一次，这个头文件就会被执行（包含）一次，多次执行（包含后）就会造成<strong>重定义（Duplicate Definition）</strong>的问题而导致程序出错<br>而如果加上这段代码，第一次执行时，条件为真（True），执行下面的代码，而后来条件都为假（False），不再执行，就避免了上述问题</p>
</blockquote>
</li>
<li><p>说明</p>
<blockquote>
<p>这里的<code>_SOME_TEXT_H</code>可以任取，只要不重复，唯一标识头文件即可，一般取<strong>头文件名字大写，并以下划线分隔</strong><br>还可以使用下面的这段代码替换，但由于有的编译器不支持，所以一般还是写成上面的那种格式，</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#program once</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> extern</li>
</ul>
<ul>
<li>在引用或声明全局变量时，需要用<code>extern</code>关键字修饰</li>
<li>它的功能是说明这里并不是在定义一个变量，而是声明其他地方的变量</li>
<li>函数声明不需要<code>extern</code>修饰，因为函数本身不加修饰的话就是<code>extern</code></li>
<li><code>extern</code>声明全局变量时不可以复制，这个问题经常在从<code>.c</code>文件复制变量到<code>.h</code>文件声明时出现（复制过去忘记删除初始化值），导致程序出错</li>
</ul>
<h4 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h4><blockquote>
<p>刚才已经讲过了如何创建一个<strong>组</strong>，其实对于我们文件的管理也是基于<strong>组</strong>来管理的，这里推荐几种方式</p>
<ul>
<li>即创立两个组，一个组用来放入<code>.c</code>后缀的程序文件，另一个组用来放入<code>.h</code>后缀的头文件，将二者分开管理，如经典<code>Ruler</code>程序，<code>Header</code>放头文件，<code>Source</code>放程序文件<br><img src="iar_10.png" alt="Ruler"> <img src="iar_11.png" alt="Ruler"></li>
<li>只创建一个组，将自己的头文件和程序文件都放到里面，这样的优点是同名的<code>.c</code>和<code>.h</code>文件在一起，而往往更改一个程序文件的时候同时需要更改同名的头文件，这样可以方便找到，而不用来回滑动滚轮，如我的程序<br><img src="iar_12.png" alt="Sakura"></li>
<li>你还可以根据文件功能进行分组，如底层的文件（超声波，激光，OLED，摄像头等）分为一组，跑车算法文件分为一组，这里只是介绍几种，随个人喜好你可以任意配置</li>
</ul>
</blockquote>
<hr>
<h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><ul>
<li>在<code>IAR</code>中<strong>代码编辑区域</strong>有一条不太明显的<strong>竖线</strong>，它存在的作用可能就是提醒<code>iar</code>具有分屏功能</li>
<li>具体操作：<strong>鼠标左键按住标签栏中的文件向下拖动至代码编辑区域松开</strong>即可实现分屏，<code>iar</code>可以支持多个分屏<br><img src="iar_2.gif" alt="分屏"></li>
</ul>
<h3 id="Livewatch功能"><a href="#Livewatch功能" class="headerlink" title="Livewatch功能"></a>Livewatch功能</h3><ul>
<li><p><strong>注意：这个功能只有在调试模式才会找到</strong>，如下图，编辑模式和调试模式下的<code>View</code>菜单栏</p>
</li>
<li><p>位置：<code>View-&gt;Live Watch</code><br><img src="iar_13.png" alt="Live watch"></p>
</li>
<li><p>功能：在里面输入变量名就可以实时查看变量的数值变化（非常非常常用的重要功能，如查看数值变化，断点调试等）</p>
</li>
<li><p>修改<code>Live Watch</code>刷新速度：<code>Tools-&gt;Options-&gt;Debugger-&gt;Live Watch</code><br><img src="iar_16.png" alt="liveWatch"><br><img src="iar_17.png" alt="liveWatch"></p>
<blockquote>
<p>默认是1000ms刷新一次，根据实际需要可以调节</p>
</blockquote>
</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>当程序不能按照我们的预期得到结果时，我们要使用Debug功能，设置断点</li>
<li>在指定位置设置断点，程序执行到这里以后，会停止向下执行，而保存当前的数据，我们通过多处设置断点，一步步查看数据值，即可一步步缩小程序的错误排查范围，并最终找到问题所在</li>
<li>案例：求平均值(我在VS2017中进行演示，用它的Debug功能，这和Live Watch原理是差不多的）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AD模块采集到的值</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> ad_value[<span class="number">5</span>] = &#123; <span class="number">17878</span>, <span class="number">15267</span>, <span class="number">15667</span>, <span class="number">17621</span>, <span class="number">22132</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += ad_value[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"结果是：%d\n"</span>, aver());</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<ul>
<li>执行后控制台输出结果<br><img src="iar_14.png" alt="结果"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>显然不是我们想要的正确结果，我们观察程序执行的流程，在循环语句处设置断点，如下图<br><img src="iar_15.png" alt="断点"></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>然后debug，逐步执行，查看结果<br><img src="iar_1.gif" alt="debug"></li>
</ul>
</blockquote>
<blockquote>
<p>通过Debug我们发现，程序在累加的过程中<strong>和突然减小</strong>，那么显然这是由于相加后数据大于65535溢出造成的，我们可以通过更换更大的数据类型或者改用其他算法来规避这个问题<br>实际问题会复杂一些，这里只是抛砖引玉</p>
</blockquote>
<hr>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ctrl+S</code></td>
<td>保存文件，建议没事就<code>Ctrl+S</code>一下</td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>向右缩进（具体缩进多少可在<code>Tools-&gt;Options-&gt;Editor-&gt;Indent Size</code>更改）</td>
</tr>
<tr>
<td><code>Shift+Tab</code></td>
<td>向左缩进，和<code>Tab</code>一样可以选中多行文本执行</td>
</tr>
<tr>
<td><code>Ctrl+T</code></td>
<td>将选中的文本自动排版</td>
</tr>
<tr>
<td><code>Ctrl+K</code></td>
<td>注释选中文本（未选中文本注释当前行）</td>
</tr>
<tr>
<td><code>Ctrl+Shift+K</code></td>
<td>取消注释选中的文本（未选中文本取消注释当前行），注意：当选中的文本中有一行没有被注释时，命令不会执行</td>
</tr>
<tr>
<td><code>Ctrl+Tab</code></td>
<td>返回上一个界面</td>
</tr>
<tr>
<td><code>Ctrl+F</code></td>
<td>查找文本</td>
</tr>
<tr>
<td><code>Ctrl+H</code></td>
<td>查找文本并支持替换文本</td>
</tr>
<tr>
<td><code>Ctrl+B</code></td>
<td>括号匹配，会将同一个<code>()</code>或者<code>[]</code>或者<code>{}</code>的内容选中，再次执行此命令会继续扩大范围</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>iar</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/09/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="python中使用正则表达式"><a href="#python中使用正则表达式" class="headerlink" title="python中使用正则表达式"></a>python中使用正则表达式</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入re模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用match方法查看是否满足规则，如果匹配失败，返回None</span></span><br><span class="line"><span class="comment"># 字符串前加r表示这是非转义的原始字符串</span></span><br><span class="line">ret = re.match(<span class="string">r"指环王[1-3]"</span>, <span class="string">"指环王2"</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用group方法查看匹配的对象</span></span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 4), match=&apos;指环王2&apos;&gt;</span><br><span class="line">指环王2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>match()</code>方法默认判断开头</p>
</blockquote>
<h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意一个字符，<code>\n</code>除外</td>
<td></td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配<code>[]</code>中列举的字符</td>
<td>“[1-34-6a-nA-N]”(可以匹配1-3, 4-6, a-n, A-N之间的数字或字符)</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配一位数字，即1-9</td>
<td>“\d”(可以匹配0-9之间的一位数字)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配非数字</td>
<td>“\d”(可以匹配0-9之间的一位数字)</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配单个字符，包括<code>0-9</code>，<code>a-z</code>，<code>A-Z</code>，<code>_</code>(下划线)其他语言中的单个字符</td>
<td></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符，如一些特殊符号</td>
<td></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空白字符，如<code>空格</code>，<code>tab</code>，<code>\n</code>等</td>
<td></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配非空白字符</td>
<td></td>
</tr>
</tbody></table>
<h2 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>{m}</code></td>
<td>限制前面表达式的位数为m个</td>
<td><code>\d{3}</code>表示必须是一个三位数</td>
</tr>
<tr>
<td><code>{m,n}</code></td>
<td>限制前面表达式的位数为m-n个，注意<code>,</code>后面不要有空格</td>
<td><code>\d{1, 3}</code>表示一个1-3位数</td>
</tr>
<tr>
<td><code>？</code></td>
<td>指定前面的字符要么有一个，要么没有</td>
<td><code>021-?\d{7}</code>表示<code>-</code>可有可无，如<code>021-1234567</code>或<code>0211234567</code>都满足</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配任意多个字符，可以为空</td>
<td><code>.*</code>匹配所有字符</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配任意多个字符，但不能为空</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><code>.</code>默认是不匹配换行符的，如果想要匹配所有字符，可以与<code>*</code>连用并在<code>match()</code>方法中加一个参数<code>re.S</code>使之可以匹配换行，如</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">re.match(<span class="string">".*"</span>, <span class="string">"some \n text"</span>, re.S)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当匹配中需要使用到<code>.</code>，<code>*</code>等作为普通字符，需要前面加转义字符，如<code>\.</code>，<code>\*</code></p>
</blockquote>
<h2 id="匹配开头结尾"><a href="#匹配开头结尾" class="headerlink" title="匹配开头结尾"></a>匹配开头结尾</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配结尾</td>
</tr>
</tbody></table>
<h2 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&#124;</td>
<td>匹配左右任意一个表达式</td>
</tr>
<tr>
<td><code>(ab)</code></td>
<td>1. 括号内的优先运算 2. 将括号中的字符作为一个分组，在python中根据括号的先后顺序，可分别使用<code>group(1)</code>，<code>group(2)</code>取出分组的数据，<a href="#()使用演示">使用演示</a></td>
</tr>
<tr>
<td><code>\num</code></td>
<td>引用第<code>num</code>组匹配到的字符串，<a href="#\使用演示">使用演示</a></td>
</tr>
<tr>
<td><code>(?P&lt;name&gt;)</code></td>
<td>分组起别名</td>
</tr>
<tr>
<td>(?P=name)</td>
<td>引用别名为<code>name</code>分组匹配到的字符串，<a href="#别名使用演示">使用演示</a></td>
</tr>
</tbody></table>
<h3 id="使用演示"><a href="#使用演示" class="headerlink" title="()使用演示"></a><code>()</code>使用演示</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""输入邮箱用户名为4-20位"""</span></span><br><span class="line">    email = input(<span class="string">"请输入您的邮箱："</span>)</span><br><span class="line">    <span class="comment"># 利用()设置分组，并且使或运算仅限于163与126</span></span><br><span class="line">    result = re.match(<span class="string">r"^([0-9a-zA-Z_]&#123;4,20&#125;)@(163|126)\.com$"</span>, email)</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="comment"># 利用group取出分组的值</span></span><br><span class="line">        print(<span class="string">"您注册的用户名是&#123;0&#125;，邮箱类型是&#123;1&#125;邮箱"</span>.format(result.group(<span class="number">1</span>), result.group(<span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"格式错误，请重新输入"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行程序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入您的邮箱：zhangsan_123@126.com</span><br><span class="line">您注册的用户名是zhangsan_123，邮箱类型是126邮箱</span><br></pre></td></tr></table></figure>

<h3 id="使用演示-1"><a href="#使用演示-1" class="headerlink" title="\使用演示"></a><code>\</code>使用演示</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"请重复输入两次用户名和密码\n用户名与密码间以,间隔\n第一次和第二次间用;间隔"</span>)</span><br><span class="line">    name_pass = input(<span class="string">"==&gt;"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        result = re.match(<span class="string">r"^([a-zA-Z0-9]&#123;3,10&#125;),([a-zA-Z0-9]&#123;6,16&#125;);\1,\2$"</span>, name_pass)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            print(<span class="string">"OK"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name_pass = input(<span class="string">"请重新输入==&gt;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行程序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请重复输入两次用户名和密码</span><br><span class="line">用户名与密码间以,间隔</span><br><span class="line">第一次和第二次间用;间隔</span><br><span class="line">==&gt;jack,123456;jack,654321</span><br><span class="line">请重新输入==&gt;jack,123456;john,123456</span><br><span class="line">请重新输入==&gt;jack,123456;jack,123456</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="别名使用演示"><a href="#别名使用演示" class="headerlink" title="别名使用演示"></a>别名使用演示</h3><ul>
<li>上面的判断代码可以写为<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = re.match(<span class="string">r"^(?P&lt;name&gt;[a-zA-Z0-9]&#123;3,10&#125;),(?P&lt;pass&gt;[a-zA-Z0-9]&#123;6,16&#125;);(?P=name),(?P=pass)$"</span>, name_pass)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro解决idea,pycharm,clion等菜单中文乱码小方框</title>
    <url>/2019/09/26/%E8%A7%A3%E5%86%B3idea-pycharm-clion%E7%AD%89%E8%8F%9C%E5%8D%95%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%B0%8F%E6%96%B9%E6%A1%86/</url>
    <content><![CDATA[<a id="more"></a>

<blockquote>
<p>这是由于字体不支持中文造成的</p>
<ul>
<li>解决方法<br>终端下载字体</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ide设置<code>Appearance-&gt;Theme下勾选use custom font-&gt;选择WenQuanYi micro hei</code>更改字体<br><img src="jet_1.png" alt="更改字体"></p>
</blockquote>
<blockquote>
<p>接下来就可以看到中文了<br><img src="jet_2.png" alt="更改字体"></p>
</blockquote>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>idea乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>python中range与xrange</title>
    <url>/2019/09/24/python%E4%B8%ADrange%E4%B8%8Exrange/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul>
<li><code>range(start, stop, step)</code>与<code>xrange(start, stop, step)</code>用法相同<ul>
<li>start：起始数字，可不填，默认0</li>
<li>stop：结束数字，必须填</li>
<li>step：步长，可不填，默认1</li>
</ul>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><code>range()</code>直接生成一个列表，需要立即开辟内存空间</li>
<li><code>xrange()</code>生成一个可以迭代的对象，即用即取</li>
<li>要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python2</span></span><br><span class="line"><span class="comment"># *-* coding: utf-8 *-*</span></span><br><span class="line">print(<span class="string">"测试range"</span>)</span><br><span class="line">my_range = range(<span class="number">10</span>)</span><br><span class="line">print(my_range)</span><br><span class="line">print(<span class="string">"测试xrange"</span>)</span><br><span class="line">my_xrange = xrange(<span class="number">10</span>)</span><br><span class="line">print(my_xrange)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试range</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">测试xrange</span><br><span class="line">xrange(10)</span><br></pre></td></tr></table></figure>

<ul>
<li>而使用for循环输出结果一致<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(3):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">for i in xrange(3):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2019/09/23/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>迭代是访问集合元素的一种方式，迭代器是一种可以记住遍历的位置的对象，从集合的第一个元素开始访问知道所有的元素访问完结束</p>
</blockquote>
<h3 id="查看是否可以迭代"><a href="#查看是否可以迭代" class="headerlink" title="查看是否可以迭代"></a>查看是否可以迭代</h3><ul>
<li>可迭代的对象可以使用<code>isinstance</code>验证与<code>Iterable</code>的关系，返回<code>True</code>则可以迭代</li>
<li>迭代器可以使用<code>isinstance</code>验证与<code>Iterator</code>的关系，返回<code>True</code>则可以迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">print(isinstance([<span class="number">11</span>, <span class="number">22</span>], Iterable))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="定义可以迭代的类"><a href="#定义可以迭代的类" class="headerlink" title="定义可以迭代的类"></a>定义可以迭代的类</h2><ul>
<li><p>如果想让创建的对象可以迭代，必须实现<code>__iter__()</code>方法，且需要返回一个迭代器</p>
<blockquote>
<p>返回的迭代器也是一个对象，这个对象要包含<code>__iter__()</code>方法和<code>__next__()</code>，方法，其中<code>__next__()</code>方法的返回值就是迭代的内容</p>
<blockquote>
<p>可以重新写一个迭代器的类，用于返回值<br>可以直接返回<code>self</code>，并在本类中实现<code>__next__()</code></p>
</blockquote>
</blockquote>
</li>
<li><p>两个类实现迭代</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.names = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_iterator</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回一个迭代器对象</span></span><br><span class="line">        <span class="keyword">return</span> my_itor(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_itor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; len(self.obj.names):</span><br><span class="line">            ret = self.obj.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 超过容量抛出StopIteration来终止迭代</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iterator = my_iter()</span><br><span class="line">my_iterator.my_iterator(<span class="string">"张三"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"李四"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"王五"</span>)</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_iterator:</span><br><span class="line">    print(temp)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现了迭代功能</p>
</blockquote>
<ul>
<li>一个类实现迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.names = list()</span><br><span class="line">        self.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_iterator</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回自身,会自动调用__next__()方法</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_num &lt; len(self.names):</span><br><span class="line">            ret = self.names[self.current_num]</span><br><span class="line">            self.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 超过容量抛出StopIteration来终止迭代</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_iterator = my_iter()</span><br><span class="line">my_iterator.my_iterator(<span class="string">"张三"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"李四"</span>)</span><br><span class="line">my_iterator.my_iterator(<span class="string">"王五"</span>)</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_iterator:</span><br><span class="line">    print(temp)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也实现了迭代功能</p>
</blockquote>
<ul>
<li>迭代器在类型转换中的作用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list = [ <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span> ]</span><br><span class="line">my_tuple = tuple(my_list)</span><br><span class="line">print(my_tuple)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(11, 22, 33)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实质上是先生成一个空的元组，然后调用<code>my_list</code>中的迭代方法，向<code>my_tuple</code>中添加内容</p>
</blockquote>
<h3 id="iter-和next-方法"><a href="#iter-和next-方法" class="headerlink" title="iter()和next()方法"></a><code>iter()</code>和<code>next()</code>方法</h3><ul>
<li><code>iter()</code>用于获取可迭代对象的迭代器，实质上是调用了可迭代对象的<code>__iter__()</code>方法</li>
<li><code>next()</code>方法用于获取迭代对象的下一条数据，迭代完成后抛出<code>StopIteration</code>的异常终止迭代<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1_iter = iter(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(l1_iter)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li>生成器是一种特殊的迭代器<h3 id="创建生成器"><a href="#创建生成器" class="headerlink" title="创建生成器"></a>创建生成器</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4></li>
<li>将列表生成式的<code>[]</code>换成<code>()</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x7f924b6088d0</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><ul>
<li>使用<code>yield</code>创建</li>
<li><code>yield</code>会返回它后面的值，并将程序停留于此，等待下一次调用从当前位置开始执行</li>
<li>示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出斐波纳奇数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    print(<span class="string">"---1---"</span>)</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        print(<span class="string">"---2---"</span>)</span><br><span class="line">        <span class="comment"># 如果一个函数中有yield语句，那么这个就不再是函数，而是一个生成器的模板</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        print(<span class="string">"---3---"</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"---4---"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在调用create_num的时候，发现这个函数中有yield，那么此时不是调用函数，而是创建一个生成器对象</span></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> obj:</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">0</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">1</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">1</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">2</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---2---</span><br><span class="line">3</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见只输出了一次<code>---1---</code>，而当第二次循环的时候没有进行初始化，直接在<code>while</code>循环中的<code>yield</code>下面继续执行，即<code>yield</code>返回后面的<code>a</code>后，停留在当前位置，等待下一次执行</p>
</blockquote>
<blockquote>
<p>另外，当使用同一个模板创建了多个生成器时，相互之间互不影响</p>
<ul>
<li>当生成器执行完成后有返回值时，可以使用异常获取</li>
</ul>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"遍历结束"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 使用next()启用生成器</span></span><br><span class="line">        ret = next(obj)</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 获取返回值</span></span><br><span class="line">        print(e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">遍历结束</span><br></pre></td></tr></table></figure>

<h3 id="启动生成器"><a href="#启动生成器" class="headerlink" title="启动生成器"></a>启动生成器</h3><h4 id="使用next-启动"><a href="#使用next-启动" class="headerlink" title="使用next()启动"></a>使用<code>next()</code>启动</h4><blockquote>
<p>上面的例子中都是使用<code>next()</code>启动的，这里不再介绍</p>
</blockquote>
<h4 id="使用send-启动"><a href="#使用send-启动" class="headerlink" title="使用send()启动"></a>使用<code>send()</code>启动</h4><ul>
<li><code>send()</code>中可以填入参数作为<code>yield</code>执行后的返回值<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_num</span><span class="params">(all_num)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current_num &lt; all_num:</span><br><span class="line">        res = <span class="keyword">yield</span> a</span><br><span class="line">        print(res)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"遍历结束"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = create_num(<span class="number">5</span>)</span><br><span class="line">ret = next(obj)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ret = obj.send(<span class="string">"你好"</span>)</span><br><span class="line">        print(ret)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">你好</span><br><span class="line">1</span><br><span class="line">你好</span><br><span class="line">1</span><br><span class="line">你好</span><br><span class="line">2</span><br><span class="line">你好</span><br><span class="line">3</span><br><span class="line">你好</span><br><span class="line">遍历结束</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见，<code>send()</code>将<code>&quot;你好&quot;</code>作为参数传递给了<code>yield</code>执行后的结果<code>res</code>，并且，它是下一次进入函数才传递的，这点可以从结果中先输出<code>0</code>(<code>print(ret)</code>)，后输出<code>你好</code>(<code>print(res)</code>)可以看出来<br>因此，<code>send()</code>如果作为第一次启动生成器时，必须使用<code>obj.send(None)</code>，即不传入参数，或使用<code>next(obj)</code>来第一次启动</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——协程</title>
    <url>/2019/09/23/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h2><h3 id="使用yield和next-创建协程"><a href="#使用yield和next-创建协程" class="headerlink" title="使用yield和next()创建协程"></a>使用<code>yield</code>和<code>next()</code>创建协程</h3><ul>
<li>关于<a href="http://www.duguosheng.xyz/2019/09/23/迭代器与生成器/" target="_blank" rel="noopener">yield和next()</a><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----1----"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"****2****"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    next(task1())</span><br><span class="line">    next(task2())</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">----1----</span><br><span class="line">****2****</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<h3 id="使用greenlet"><a href="#使用greenlet" class="headerlink" title="使用greenlet"></a>使用<code>greenlet</code></h3><ul>
<li><p>如果没有可以使用<code>pip3</code>安装<code>greenlet</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install greenlet</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>greenlet</code>对于<code>yield</code>进行了封装，使用户可以按照正常写函数的方式实现多任务</p>
</li>
<li><p>使用：</p>
<ul>
<li><code>gr = greenlet(目标函数)</code>创建对象</li>
<li><code>gr.switch()</code>切换执行任务</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"----1----"</span>)</span><br><span class="line">        <span class="comment"># 切换到task2</span></span><br><span class="line">        gr2.switch()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"****2****"</span>)</span><br><span class="line">        <span class="comment"># 切换到task1</span></span><br><span class="line">        gr1.switch()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet.greenlet(task1)</span><br><span class="line">gr2 = greenlet.greenlet(task2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到task1</span></span><br><span class="line">gr1.switch()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用gevent"><a href="#使用gevent" class="headerlink" title="使用gevent"></a>使用gevent</h3><ul>
<li>如果没有可以使用下面的命令安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install gevent</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>gevent</code>是在<code>greenlet</code>的基础上再次封装的</p>
</blockquote>
<ul>
<li><code>gevent</code>遇到延时操作自动切换任务，这个延时操作不能是<code>time.sleep()</code>而需要是<code>gevent.sleep()</code></li>
<li>代码示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># 获取当前协程id</span></span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        gevent.sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g2 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb710: fun(3)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x7f92a16fb830: fun(3)&gt; 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现三者交替执行，实现了多任务</p>
</blockquote>
<ul>
<li>上述创建协程方法有些麻烦，还可以使用<code>joinall([任务1, 任务2, ...])</code>的方式，它的参数是一个列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">gevent.joinall([gevent.spawn(fun, <span class="number">3</span>),</span><br><span class="line">                gevent.spawn(fun, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如果原来的程序中使用了time-sleep-进行延时"><a href="#如果原来的程序中使用了time-sleep-进行延时" class="headerlink" title="如果原来的程序中使用了time.sleep()进行延时"></a>如果原来的程序中使用了<code>time.sleep()</code>进行延时</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(gevent.getcurrent(), i)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g2 = gevent.spawn(fun, <span class="number">3</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7fe70455e710: fun(3)&gt; 2</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x7fe70455e830: fun(3)&gt; 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，两个任务并没有交替执行，而是一个执行完了另一个再执行，并没有实现多任务</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>在执行前之前写如下代码，使用patch_all()解决<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>wordPress文章版本</title>
    <url>/2019/09/22/wordPress%E6%96%87%E7%AB%A0%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<a id="more"></a>

<p>修改站点的<code>wp-config.php</code>文件，在其中添加如下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'WP_POST_REVISIONS'</span>, <span class="number">0</span>);     <span class="comment">//不启用修订版本</span></span><br><span class="line">define(<span class="string">'WP_POST_REVISIONS'</span>, <span class="number">3</span>);     <span class="comment">//共保存3个版本</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>文章版本</tag>
        <tag>wordPress配置</tag>
      </tags>
  </entry>
  <entry>
    <title>wordPress的文章和页面</title>
    <url>/2019/09/22/wordPress-1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="文章和页面"><a href="#文章和页面" class="headerlink" title="文章和页面"></a>文章和页面</h2><blockquote>
<p>文章：是网站的主要内容<br>页面：是网站的其他一些信息</p>
</blockquote>
<ul>
<li>以<strong>哔哩哔哩</strong>网为例<blockquote>
<p>它的主要内容是视频，所以打开它的网站可以看到许多视频推送，这就是它的<strong>文章</strong><br><img src="wp_1.png" alt="文章"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>而下拉到末尾，可以看到其他一些次要信息，这些就是<strong>页面</strong><br><img src="wp_2.png" alt="页面"></p>
</blockquote>
<ul>
<li>由于<strong>文章</strong>内容繁杂，所以可以创建分类便于管理和用户查询，而页面没有分类功能<br><img src="wp_2.png" alt="分类"></li>
</ul>
]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>wordpress一些基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title>时域分析</title>
    <url>/2019/09/22/%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="一阶动态性能指标"><a href="#一阶动态性能指标" class="headerlink" title="一阶动态性能指标"></a>一阶动态性能指标</h2><p><img src="sy_1.png" alt="一阶"></p>
]]></content>
      <categories>
        <category>自动控制原理</category>
      </categories>
      <tags>
        <tag>时域分析</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——进程</title>
    <url>/2019/09/20/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="进程及其状态"><a href="#进程及其状态" class="headerlink" title="进程及其状态"></a>进程及其状态</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序：例如<code>xxx.py</code>这是程序，是静态的</li>
<li>进程：程序运行起来后，<strong>代码+用到的资源</strong>称为进程</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>任务数往往大于CPU核数，因而一定有一些任务正在进行，另一些任务等待，这样就导致了进程有不同的状态<br><img src="pro_1.png" alt="进程的状态"></p>
<ul>
<li>就绪态：运行条件都满足，等待CPU调度</li>
<li>执行态：CPU正在执行</li>
<li>等待态：等待某些条件满足，例如一个程序<code>sleep</code>中</li>
</ul>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="使用multiprocessing模块"><a href="#使用multiprocessing模块" class="headerlink" title="使用multiprocessing模块"></a>使用<code>multiprocessing</code>模块</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testProcess</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"process------"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    my_pro = multiprocessing.Process(target=testProcess)</span><br><span class="line">    <span class="comment"># 启动进程</span></span><br><span class="line">    my_pro.start()</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><blockquote>
<p>线程间资源共享<br>进程间资源不共享，是独立的</p>
<ul>
<li>举例说明</li>
</ul>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"test1-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"test2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pro</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"测试进程"</span>)</span><br><span class="line">    p1 = multiprocessing.Process(target=test1)</span><br><span class="line">    p2 = multiprocessing.Process(target=test2)</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_thr</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"测试线程"</span>)</span><br><span class="line">    t1 = threading.Thread(target=test1)</span><br><span class="line">    t2 = threading.Thread(target=test2)</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># test_pro()</span></span><br><span class="line">    test_thr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试线程</span><br><span class="line">test1-----10</span><br><span class="line">test2-----20</span><br></pre></td></tr></table></figure>

<ul>
<li>改变<code>main()</code>函数<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    test_pro()</span><br><span class="line">    <span class="comment"># test_thr()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>再次执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试进程</span><br><span class="line">test1-----10</span><br><span class="line">test2-----10</span><br></pre></td></tr></table></figure>

<ul>
<li>实现进程间通信：<strong><code>Queue</code></strong><blockquote>
<p><code>Queue</code>是队列的意思，遵循先进先出的原则<br>一个进程向<code>Queue</code>中写入数据，另一个进程从<code>Queue</code>中取出，就可实现通信<br>这是一种比较低端的方式，还可使用<code>socket</code>，<code>redis</code>等实现</p>
</blockquote>
</li>
<li>代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_from_web</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="string">"""模拟从网上下载数据"""</span></span><br><span class="line">    data = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向对列中写入数据</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> data:</span><br><span class="line">        queue.put(temp)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"已全部存入队列"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_data</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="string">"""数据处理"""</span></span><br><span class="line">    d_data = list()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        data = queue.get()</span><br><span class="line">        d_data.append(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"接收完成--%s"</span> % d_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程，将队列的引用当作实参传递到里面</span></span><br><span class="line">    p1 = multiprocessing.Process(target=download_from_web, args=(queue, ))</span><br><span class="line">    p2 = multiprocessing.Process(target=analysis_data, args=(queue, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已全部存入队列</span><br><span class="line">接收完成--[11, 22, 33, 44]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>成功实现了进程间的通讯</p>
</blockquote>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><blockquote>
<p>进程不多时可以直接使用<code>Process</code>动态生成多个进程，但如果所需进程过多，手动创建进程工作量太大，且不利于cpu的运行，因而可以使用进程池<code>Pool</code><br>进程池是资源进程、管理进程组成的技术的应用(引自<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%B1%A0/3765641?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</p>
<blockquote>
<p>资源进程：预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。<br>管理进程：管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。<br>这样进程使有进有出，有序管理</p>
<ul>
<li>代码</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义进程池</span></span><br><span class="line">po = Pool(<span class="number">3</span>)    <span class="comment"># 3指最多同时执行3个进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加进程队列，target指进程地址，args是进程函数的参数，是一个元组</span></span><br><span class="line">po.apply_asyns(target, args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池</span></span><br><span class="line">po.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待po中所有子进程完成，必须在close()语句之后，没有这句代码，可以使主进程先结束，子进程也无法继续进行</span></span><br><span class="line">po.join()</span><br></pre></td></tr></table></figure>

<ul>
<li>案例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">"&#123;0&#125;开始执行，进程号&#123;1&#125;"</span>.format(msg, os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg, <span class="string">"执行完毕，耗时%f"</span> % (t_stop-t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    po = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        po.apply_async(worker, (i+<span class="number">1</span>, ))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---start---"</span>)</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"----end----"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---start---</span><br><span class="line">1开始执行，进程号22044</span><br><span class="line">2开始执行，进程号22045</span><br><span class="line">3开始执行，进程号22046</span><br><span class="line">1 执行完毕，耗时0.175232</span><br><span class="line">4开始执行，进程号22044</span><br><span class="line">3 执行完毕，耗时0.217286</span><br><span class="line">5开始执行，进程号22046</span><br><span class="line">5 执行完毕，耗时0.187288</span><br><span class="line">6开始执行，进程号22046</span><br><span class="line">4 执行完毕，耗时0.613512</span><br><span class="line">7开始执行，进程号22044</span><br><span class="line">2 执行完毕，耗时0.860506</span><br><span class="line">8开始执行，进程号22045</span><br><span class="line">7 执行完毕，耗时0.470875</span><br><span class="line">9开始执行，进程号22044</span><br><span class="line">6 执行完毕，耗时0.969476</span><br><span class="line">10开始执行，进程号22046</span><br><span class="line">9 执行完毕，耗时0.312829</span><br><span class="line">8 执行完毕，耗时0.909825</span><br><span class="line">10 执行完毕，耗时0.897377</span><br><span class="line">----end----</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以从进程号看出一直在重复利用<code>22044, 22045, 22046</code>三个pid<br>从输出来看，可以看出来同一时间最多只有三个进程执行</p>
</blockquote>
<ul>
<li>注意：<strong>在进程池间使用队列通信，不能使用<code>multiprocessing.Queue()</code>，而要使用<code>multiprocessing.Manager().Queue()</code></strong></li>
</ul>
<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><ul>
<li>实现文件复制功能<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_file</span><span class="params">(queue, file_name, src_dir, dest_dir)</span>:</span></span><br><span class="line">    src_file = open(src_dir+<span class="string">"/"</span>+file_name, <span class="string">"rb"</span>)</span><br><span class="line">    <span class="comment"># print("正在复制%s" % src_file)</span></span><br><span class="line">    content = src_file.read()</span><br><span class="line">    dest_file = open(dest_dir+<span class="string">"/"</span>+file_name, <span class="string">"wb"</span>)</span><br><span class="line">    dest_file.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果拷贝完了文件，就向队列写入数据，表示下载完成</span></span><br><span class="line">    queue.put(file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取用户需要copy的文件名</span></span><br><span class="line">    src_dir = input(<span class="string">"请输入要复制的文件夹："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个新的文件夹</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dest_dir = src_dir+<span class="string">"_copy"</span></span><br><span class="line">        os.mkdir(dest_dir)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"该文件夹已存在"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件夹中所有的待copy的文件名字listdir()</span></span><br><span class="line">    file_names = os.listdir(src_dir)</span><br><span class="line">    total_num = len(file_names)</span><br><span class="line">    current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    po = multiprocessing.Pool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    queue = multiprocessing.Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向进程池添加复制任务</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_names:</span><br><span class="line">        po.apply_async(copy_file, (queue, file_name, src_dir, dest_dir))</span><br><span class="line"></span><br><span class="line">    po.close()</span><br><span class="line">    <span class="comment"># po.join()</span></span><br><span class="line">    <span class="comment"># 显示执行进度</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        file_name = queue.get()</span><br><span class="line">        current_num += <span class="number">1</span></span><br><span class="line">        now_step = current_num/total_num</span><br><span class="line">        print(<span class="string">"\r已拷贝%s-------进度%.2f %%              "</span> % (file_name, <span class="number">100</span>*now_step), end=<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">if</span> now_step == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>python多任务——线程</title>
    <url>/2019/09/19/python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Thread创建线程"><a href="#Thread创建线程" class="headerlink" title="Thread创建线程"></a>Thread创建线程</h2><h3 id="使用Threading模块"><a href="#使用Threading模块" class="headerlink" title="使用Threading模块"></a>使用Threading模块</h3><ul>
<li><p>语法格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入threading模块</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程</span></span><br><span class="line">my_thread = threading.Thread(target=函数名)</span><br><span class="line"><span class="comment"># 开启线程</span></span><br><span class="line">my_thread.start()</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"hello"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thrd = threading.Thread(target=testThread)</span><br><span class="line">    thrd.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果： 每隔一秒打印一次hello</p>
</blockquote>
<h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><ul>
<li>步骤<ul>
<li>创建类，继承Thread类</li>
<li>在这个类中重写<code>run()</code>方法</li>
</ul>
</li>
<li>示例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="string">"""继承Thread类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写run()方法"""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mythread = MyThread()</span><br><span class="line">    <span class="comment"># 调用start()方法后会自动调用run()方法</span></span><br><span class="line">    mythread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果：每隔一秒打印一次hello</p>
</blockquote>
<h2 id="查看线程数量"><a href="#查看线程数量" class="headerlink" title="查看线程数量"></a>查看线程数量</h2><ul>
<li><p>使用Threading模块中的<code>enumerate()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(threading.enumerate())</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">"thread---1"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testThread2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">"thread---2"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    thrd1 = threading.Thread(target=testThread1)</span><br><span class="line">    thrd2 = threading.Thread(target=testThread2)</span><br><span class="line">    thrd1.start()</span><br><span class="line">    thrd2.start()</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.enumerate())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">[&lt;_MainThread(MainThread, started 140351833364096)&gt;, &lt;Thread(Thread-1, sta</span><br><span class="line">rted 140351824549632)&gt;, &lt;Thread(Thread-2, started 140351746602752)&gt;]</span><br><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">thread---1</span><br><span class="line">thread---2</span><br><span class="line">[&lt;_MainThread(MainThread, started 140351833364096)&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 只有调用了<code>start()</code>方法时才会创建线程并开始执行，而使用<code>Thread(target=)</code>只是创建一个对象，所以只有放在<code>start()</code>后和线程结束前才可以使用<code>enumerate()</code>查看</p>
</blockquote>
<ul>
<li>由运行结果可见，当一个线程结束后，不会再打印它的信息，即列表中不再存在，由此可以判断其他线程是否都结束<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当只有主线程的时候</span></span><br><span class="line"><span class="keyword">if</span> len(threading.enumerate()) == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="线程中传递参数args"><a href="#线程中传递参数args" class="headerlink" title="线程中传递参数args"></a>线程中传递参数args</h2><ul>
<li>线程中传递的参数使用args指定，必须是一个元组<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_list1 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">g_list2 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(list1)</span>:</span></span><br><span class="line">    list1.append(<span class="number">33</span>)</span><br><span class="line">    print(<span class="string">"在test1中，list1=%s"</span> % list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(list1, list2)</span>:</span></span><br><span class="line">    list1.append(<span class="number">44</span>)</span><br><span class="line">    list2.append(<span class="number">33</span>)</span><br><span class="line">    print(<span class="string">"在test2中，list1=%s"</span> % list1)</span><br><span class="line">    print(<span class="string">"在test2中，list2=%s"</span> % list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># target指定函数地址</span></span><br><span class="line">    <span class="comment"># args指定参数，必须是一个元组</span></span><br><span class="line">    t1 = threading.Thread(target=test1, args=(g_list1, ))  <span class="comment"># 当参数只有一个时，使用args=(temp, )的方式</span></span><br><span class="line">    t2 = threading.Thread(target=test2, args=(g_list1, g_list2))</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在test1中，list1=[11, 22, 33]</span><br><span class="line">在test2中，list1=[11, 22, 33, 44]</span><br><span class="line">在test2中，list2=[11, 22, 33]</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁解决资源竞争"><a href="#互斥锁解决资源竞争" class="headerlink" title="互斥锁解决资源竞争"></a>互斥锁解决资源竞争</h2><h3 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h3><ul>
<li>由于多线程共用资源，会产生资源竞争的问题，如下面的代码，让两个线程同时对全局变量执行加一的操作，若不存在资源竞争，应当结果为二者循环次数之和，而结果往往小于此</li>
<li>这是因为当一个线程拿到数据加一后，可能还未存放结果，这个数据就被另一个线程调用，这样就会使数值低于预期<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"thread2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_2</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"thread2-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=add_1, args=(<span class="number">1000000</span>, ))</span><br><span class="line">    t2 = threading.Thread(target=add_2, args=(<span class="number">1000000</span>, ))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 确保执行完毕,每隔1s判断一次</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(threading.enumerate()) == <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">"main-----%d"</span> % g_num)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread2----<span class="number">-1197292</span></span><br><span class="line">thread2----<span class="number">-1253537</span></span><br><span class="line">main----<span class="number">-1253537</span>    <span class="comment"># 这个结果不一定，但往往小于预期的2000000</span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li><p>当对象被线程调用时给对象上锁，只有使用完成后才释放，保证同一资源只有一个线程在调用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建锁，默认未锁定</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上例中的<code>add_1()</code>为例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line">    print(<span class="string">"thread1-----%d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_2()改变的格式同add_1()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread1----<span class="number">-1000000</span></span><br><span class="line">thread2----<span class="number">-2000000</span></span><br><span class="line">main----<span class="number">-2000000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的改动中将锁放在了循环之外，因而当一个线程抢到资源后后全部执行结束后才释放，在实际开发中，应当尽量减小锁的范围，本例中可将锁置于循环之中<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span><span class="params">(times)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">        mutex.acquire()</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()</span><br><span class="line">    print(<span class="string">"thread1-----%d"</span> % g_num)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">thread1----<span class="number">-1971999</span>     <span class="comment"># 两个线程交替拿到资源</span></span><br><span class="line">thread2----<span class="number">-2000000</span></span><br><span class="line">main----<span class="number">-2000000</span></span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，如<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    mutexA.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    mutexB.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    mutexA.acquire()</span><br><span class="line">    mutexB.release()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>上例中，<code>test1()</code>先将<code>mutexA</code>上锁，<code>test2()</code>先将<code>mutexB</code>上锁<br>当休眠结束后，<code>test1()</code>要给<code>mutexB</code>上锁，之后才能释放<code>mutexA</code>，而<code>mutexB</code>已经被<code>test2()</code>上锁占用，因而要等待<code>test2()</code>释放<code>mutexB</code><br>而<code>test2()</code>要释放<code>mutexB</code>，又要等待<code>test1()</code>释放<code>mutexA</code>，这样两者都不会进行到下一步，从而产生了<strong>死锁</strong> </p>
</blockquote>
<ul>
<li>避免：<ul>
<li>程序设计中避免</li>
<li>添加超时算法等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title>利用tcp下载文件</title>
    <url>/2019/09/19/%E5%88%A9%E7%94%A8tcp%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>即要接收文件的一方<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取服务器的ip port</span></span><br><span class="line">    dest_ip = input(<span class="string">"请输入对方的ip："</span>)</span><br><span class="line">    dest_port = input(<span class="string">"请输入对方的port："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接服务器</span></span><br><span class="line">    tcp_socket.connect((dest_ip, int(dest_port)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取下载的文件名称</span></span><br><span class="line">    download_file_name = input(<span class="string">"请输入要下载的文件名："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将文件名字发送到服务器</span></span><br><span class="line">    tcp_socket.send(download_file_name.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收文件数据</span></span><br><span class="line">    recv_data = tcp_socket.recv(<span class="number">1024</span>*<span class="number">1024</span>)  <span class="comment"># 1k*1024=1M</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存接收到的数据到一个文件中，如果内容为空则不创建文件</span></span><br><span class="line">    <span class="keyword">if</span> recv_data:</span><br><span class="line">        <span class="keyword">with</span> open (<span class="string">"[new]"</span>+download_file_name, <span class="string">"wb"</span>) <span class="keyword">as</span> d_file:</span><br><span class="line">            d_file.write(recv_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file_to_client</span><span class="params">(client_socket, client_addr)</span>:</span></span><br><span class="line">    <span class="comment"># 接收客户端要下载的文件名</span></span><br><span class="line">    file_name = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(<span class="string">"客户端&#123;0&#125;要下载的文件是&#123;1&#125;"</span>.format(client_addr, file_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开文件读取数据</span></span><br><span class="line">    file_content = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dl_file = open(file_name, <span class="string">"rb"</span>)</span><br><span class="line">        file_content = dl_file.read()</span><br><span class="line">        dl_file.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"没有该文件(%s)"</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close</span></span><br><span class="line">    <span class="keyword">if</span> file_content:</span><br><span class="line">        <span class="comment"># 回送数据</span></span><br><span class="line">        client_socket.send(file_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_serve_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定本地信息</span></span><br><span class="line">    tcp_serve_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让默认套接字由主动变为被动,listen</span></span><br><span class="line">    tcp_serve_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待客户端的连接accept,未连接到客户端会进入堵塞</span></span><br><span class="line">        print(<span class="string">"等待客户端连接..."</span>)</span><br><span class="line">        client_socket, client_addr = tcp_serve_socket.accept()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送文件</span></span><br><span class="line">        send_file_to_client(client_socket, client_addr)</span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">"已为客户服务完成"</span>)</span><br><span class="line"></span><br><span class="line">    tcp_serve_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li><p>首先先在当前目录下新建一个文件，以供调试使用，假设新建一个名为<code>test.txt</code>的文件，并在里面写下一些内容，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is some text</span><br><span class="line">这是一写文本</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看自己的ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般使用</span></span><br><span class="line">ifconfig | grep inet</span><br><span class="line"><span class="comment"># archlinux使用</span></span><br><span class="line">ip addr | grep inet</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>记住ip地址，假设为<code>123.12.10.154</code></p>
</blockquote>
<h3 id="同时运行两端代码"><a href="#同时运行两端代码" class="headerlink" title="同时运行两端代码"></a>同时运行两端代码</h3><ul>
<li><p>客户端依次输入ip地址，端口号(程序中指定了7788，可更改为1024–65535之间的其他数字)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入对方的ip：123.12.10.154</span><br><span class="line">请输入对方的port：7788</span><br><span class="line">请输入要下载的文件名：test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器中自动打印出了如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">等待客户端连接...</span><br><span class="line">客户端(&apos;10.128.150.40&apos;, 34878)要下载的文件是test.txt</span><br><span class="line">已为客户服务完成</span><br><span class="line">等待客户端连接...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>打开文件管理器，发现在当前目录下出现了一个名为<code>[new]test.txt</code>的文件，打开，查看内容，发现与<code>test.txt</code>中内容一致，说明代码执行成功</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>enumerate()函数和推导式生成列表</title>
    <url>/2019/09/17/enumerate-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8E%A8%E5%AF%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><ul>
<li><code>enumerate()</code> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>以下是 enumerate() 方法的语法:<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数</p>
<blockquote>
<p>sequence – 一个序列、迭代器或其他支持迭代对象。<br>start – 下标起始位置。<br>返回值<br>返回 enumerate(枚举) 对象。</p>
</blockquote>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">letters = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br><span class="line">gnt = enumerate(letters, start=<span class="number">1</span>)</span><br><span class="line">print(gnt)</span><br><span class="line"><span class="comment"># 需要调用list方法</span></span><br><span class="line">my_enum = list(gnt)</span><br><span class="line">print(my_enum)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;enumerate object at <span class="number">0x7f67e867f2d0</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="实现给文件的每行增加行号"><a href="#实现给文件的每行增加行号" class="headerlink" title="实现给文件的每行增加行号"></a>实现给文件的每行增加行号</h2><ul>
<li><p>新建文本文件<code>test.txt</code>，里面写上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗前明月光</span><br><span class="line">疑是地上霜</span><br><span class="line">举头望明月</span><br><span class="line">低头思故乡</span><br></pre></td></tr></table></figure>
</li>
<li><p>在python文件写入以下代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    lines = my_file.readlines()</span><br><span class="line">    lines = [<span class="string">"#"</span>+str(index+<span class="number">1</span>)+<span class="string">" "</span>+line <span class="keyword">for</span> index, line <span class="keyword">in</span> list(enumerate(lines))]  <span class="comment"># 推导式生成推导式</span></span><br><span class="line">    <span class="comment"># 也可写成lines = ["#"+str(index+1)+" "+line for index, line in enumerate(lines)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    my_file.writelines(lines)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>打开<code>test.txt</code>查看执行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1 窗前明月光</span><br><span class="line">#2 疑是地上霜</span><br><span class="line">#3 举头望明月</span><br><span class="line">#4 低头思故乡</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>close()关闭流</title>
    <url>/2019/09/17/close-%E5%85%B3%E9%97%AD%E6%B5%81/</url>
    <content><![CDATA[<a id="more"></a>
<ul>
<li>为了确保打开的文件对象正常关闭，一般结合异常机制的<code>finally</code>或者<code>with</code>关键字实现无论何种情况都能关闭打开的文件对象</li>
</ul>
<h2 id="使用finally"><a href="#使用finally" class="headerlink" title="使用finally"></a>使用finally</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">r"my_text.txt"</span>, <span class="string">"a"</span>)</span><br><span class="line">    my_str = <span class="string">"hello"</span></span><br><span class="line">    f.write(str)</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h2 id="使用with"><a href="#使用with" class="headerlink" title="使用with"></a>使用with</h2><ul>
<li><code>with</code>关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出<code>with</code>块，都能确保文件正常的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r"test.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> my_file:</span><br><span class="line">    my_file.write(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行完后，可以自动关闭文件</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数嵌套</title>
    <url>/2019/09/17/python%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>封装——数据隐藏,外部无法访问<strong>嵌套函数</strong></li>
<li>提高代码复用率</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"f1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"f2"</span>)</span><br><span class="line"></span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"><span class="comment"># f2() 不可在外部调用</span></span><br></pre></td></tr></table></figure>

<h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><ul>
<li><strong>global</strong>声明全局变量</li>
<li><strong>ninlocal</strong>声明外部变量</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> b</span><br><span class="line">        b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用zip()并行迭代</title>
    <url>/2019/09/17/%E4%BD%BF%E7%94%A8zip-%E5%B9%B6%E8%A1%8C%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li><p>实例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">names = (<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>)</span><br><span class="line">ages = (<span class="number">20</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>)</span><br><span class="line">jobs = (<span class="string">"老师"</span>, <span class="string">"工程师"</span>, <span class="string">"程序员"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, age, job <span class="keyword">in</span> zip(names, ages, jobs):</span><br><span class="line">    print(<span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(name, age, job))</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-20-老师</span><br><span class="line">李四-30-工程师</span><br><span class="line">王五-35-程序员</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>当示例中一个元组<code>job</code>遍历结束后整个遍历就结束了，因而没有输出<code>赵六</code>的信息</p>
</blockquote>
<ul>
<li>不使用<code>zip()</code>实现上述功能的代码<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"&#123;0&#125;-&#123;1&#125;-&#123;2&#125;"</span>.format(names[i], ages[i], jobs[i]))</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>__call__方法</title>
    <url>/2019/09/17/call-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<ul>
<li>Python中，如果在创建类的时候写了<code>__call__()</code>方法， 那么该类实例化出实例后， <code>实例名()</code>就是调用<code>__call__()</code>方法。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryAccount</span>:</span></span><br><span class="line">    <span class="string">"""工资计算类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, salary)</span>:</span></span><br><span class="line">        print(<span class="string">"发工资"</span>)</span><br><span class="line">        year_salary = salary*<span class="number">12</span></span><br><span class="line">        day_salary = salary//<span class="number">22.5</span></span><br><span class="line">        hour_salary = day_salary//<span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dict(year_salary=year_salary, month_salary=salary, day_salary=day_salary, hour_salary=hour_salary)</span><br><span class="line"></span><br><span class="line">s = SalaryAccount()</span><br><span class="line">print(s(<span class="number">3000</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">发工资</span><br><span class="line">&#123;<span class="string">'year_salary'</span>: <span class="number">36000</span>, <span class="string">'month_salary'</span>: <span class="number">3000</span>, <span class="string">'day_salary'</span>: <span class="number">133.0</span>, <span class="string">'hour_salary'</span>: <span class="number">16.0</span>&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp网络编程</title>
    <url>/2019/09/16/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin" target="_blank" rel="noopener">TCP百度百科</a></p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>TCP通信需要经过<strong>创建链接，数据传送，终止连接</strong>三个步骤</li>
<li>通信双方都必须先建立连接才能进行通讯，双方都要为连接分配必要的系统内核资源，以管理连接的状态和传输</li>
<li>TCP的连接是一对一的，因此，<strong>基于广播的应用程序应使用UDP</strong>，</li>
</ul>
<h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><ul>
<li>TCP严格区分服务器和客户端，服务器就是提供服务的一方，客户端就是需要服务的一方，而UDP不区分</li>
</ul>
<h3 id="TCP客户端构建流程"><a href="#TCP客户端构建流程" class="headerlink" title="TCP客户端构建流程"></a>TCP客户端构建流程</h3><ul>
<li>代码流程<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建tcp的套接字</span></span><br><span class="line">    tcp_client_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接服务器</span></span><br><span class="line">    serve_ip = input(<span class="string">"请输入服务器ip："</span>)</span><br><span class="line">    serve_port = input(<span class="string">"请输入服务器port："</span>)</span><br><span class="line">    serve_addr = (serve_ip, int(serve_port))</span><br><span class="line">    tcp_client_socket.connect(serve_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送/接收数据,使用send方法，不需要多次指定套接字</span></span><br><span class="line">    send_data = input(<span class="string">"请输入要发送的数据："</span>)</span><br><span class="line">    tcp_client_socket.send(send_data.encode(<span class="string">"gbk"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    tcp_client_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="TCP服务器"><a href="#TCP服务器" class="headerlink" title="TCP服务器"></a>TCP服务器</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    tcp_serve_socket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定本地信息</span></span><br><span class="line">    tcp_serve_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让默认套接字由主动变为被动,listen</span></span><br><span class="line">    <span class="comment"># 使用socket创建的套接字默认的属性是主动的，使用listen可将其变为被动，这样就可以接收别人的连接了</span></span><br><span class="line">    tcp_serve_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环为多个客户端服务</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待客户端的连接accept,未连接到客户端会进入堵塞</span></span><br><span class="line">        <span class="comment"># 如果有新的客户端来连接服务器，那么就产生一个新的套接字专门为这个客户端服务</span></span><br><span class="line">        <span class="comment"># client_socket用来为这个客户端服务</span></span><br><span class="line">        <span class="comment"># tcp_serve_socket就可以省下来专门等待其他新的客户端的连接</span></span><br><span class="line">        print(<span class="string">"等待客户端连接..."</span>)</span><br><span class="line">        client_socket, client_addr = tcp_serve_socket.accept()</span><br><span class="line">        print(<span class="string">"新的客户端已连接：%s"</span> % str(client_addr))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环为同一个客户端服务</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 接收客户端请求,会进入堵塞</span></span><br><span class="line">            recv_data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">"客户端请求是：%s"</span> % recv_data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close</span></span><br><span class="line">            <span class="keyword">if</span> recv_data:</span><br><span class="line">                <span class="comment"># 回送数据</span></span><br><span class="line">                client_socket.send(<span class="string">"hello"</span>.encode(<span class="string">"gbk"</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">"已为客户服务完成"</span>)</span><br><span class="line"></span><br><span class="line">    tcp_serve_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>udp网络编程</title>
    <url>/2019/09/15/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://baike.baidu.com/item/UDP/33012?fr=aladdin" target="_blank" rel="noopener">UDP百度百科</a></p>
<a id="more"></a>

<h2 id="创建udp套接字"><a href="#创建udp套接字" class="headerlink" title="创建udp套接字"></a>创建udp套接字</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.DGRAM)</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>使用<code>sendto()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">send_data = input(<span class="string">"please input:"</span>)</span><br><span class="line"><span class="comment"># 发送的数据(utf-8编码)  (ip地址, 端口)</span></span><br><span class="line">udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (<span class="string">"X.X.X.X"</span>, port))  <span class="comment"># 如果发送方未绑定端口，系统会随机分配1024-65535</span></span><br></pre></td></tr></table></figure>

<h2 id="获取端口"><a href="#获取端口" class="headerlink" title="获取端口"></a>获取端口</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组，ip地址和端口号</span></span><br><span class="line">local_addr = (<span class="string">""</span>, <span class="number">7788</span>)    <span class="comment"># ip地址一般不用写，表示本机的任意一个ip</span></span><br><span class="line"><span class="comment"># 绑定</span></span><br><span class="line">udp_socket.bind(local_addr)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序实例<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""发送数据"""</span></span><br><span class="line">    dest_ip = input(<span class="string">"请输入对方的ip："</span>)</span><br><span class="line">    dest_port = input(<span class="string">"请输入对方的port："</span>)</span><br><span class="line">    send_data = input(<span class="string">"请输入发送的消息："</span>)</span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (dest_ip, int(dest_port)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_msg</span><span class="params">(udp_socket)</span>:</span></span><br><span class="line">    <span class="string">"""接收数据"""</span></span><br><span class="line">    <span class="comment"># 接收数据,1024是本次接收的最大字节数，如果未接收到会进入阻塞状态</span></span><br><span class="line">    recv_data = udp_socket.recvfrom(<span class="number">1024</span>)  <span class="comment"># 会接收到数据和发送方的ip地址和端口</span></span><br><span class="line">    recv_msge = recv_data[<span class="number">0</span>]</span><br><span class="line">    send_addr = recv_data[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印接收到的数据, 需要指定解码，如果是windows发送，应当使用gbk解码</span></span><br><span class="line">    print(<span class="string">"接收到的数据是：%s 来源于：%s"</span> % (recv_msge.decode(<span class="string">"utf-8"</span>), str(send_addr)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 绑定信息</span></span><br><span class="line">    udp_socket.bind((<span class="string">""</span>, <span class="number">7788</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"0退出，1发送，2接收"</span>)</span><br><span class="line">        option = input(<span class="string">"请输入指令："</span>)</span><br><span class="line">        <span class="keyword">if</span> option == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> option == <span class="string">"1"</span>:</span><br><span class="line">            <span class="comment"># 发送</span></span><br><span class="line">            send_msg(udp_socket)</span><br><span class="line">        <span class="keyword">elif</span> option == <span class="string">"2"</span>:</span><br><span class="line">            <span class="comment"># 接收并显示</span></span><br><span class="line">            recv_msg(udp_socket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入错误，请重新输入"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>socket</code>套接字是<strong>全双工</strong>工作模式，即可以同时收发</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>网络的一些基本概念</title>
    <url>/2019/09/12/%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="ip地址的分类"><a href="#ip地址的分类" class="headerlink" title="ip地址的分类"></a>ip地址的分类</h2><h3 id="ipv4-百度百科"><a href="#ipv4-百度百科" class="headerlink" title="ipv4(百度百科)"></a>ipv4(<a href="https://baike.baidu.com/item/IPv4/422599?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</h3><ul>
<li><code>internet protocol version 4</code>指互联网协议的第四种版本，<code>ipv1</code>，<code>ipv2</code>，<code>ipv3</code>是实验版本</li>
<li>特点： <ul>
<li>由四组数字组成：如<code>127.168.8.32</code>，其中每组最大值是255<h3 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h3></li>
</ul>
</li>
<li><code>internet protocol version 6</code>指第六种版本，<code>ipv5</code>是实验版本</li>
<li>表示方法：(引自<a href="https://baike.baidu.com/item/IPv6/172297?fr=aladdin" target="_blank" rel="noopener">百度百科</a>)</li>
</ul>
<ol>
<li><strong>冒分十六进制表示法</strong><blockquote>
<p>格式为<code>X:X:X:X:X:X:X:X</code>，其中每个X表示地址中的16b，以十六进制表示，例如：<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>这种表示法中，每个X的前导0是可以省略的，例如：<code>2001:0DB8:0000:0023:0008:0800:200C:417A</code>→ <code>2001:DB8:0:23:8:800:200C:417A</code></p>
</blockquote>
</li>
<li><strong>0位压缩表示法</strong><blockquote>
<p>在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为<code>::</code>。但为保证地址解析的唯一性，地址中<code>::</code>只能出现一次，例如：<code>FF01:0:0:0:0:0:0:1101</code> → <code>FF01::1101</code>，<code>0:0:0:0:0:0:0:1</code> → <code>::1</code>，<code>0:0:0:0:0:0:0:0</code> → <code>::</code></p>
</blockquote>
</li>
<li><strong>内嵌IPv4地址表示法</strong><blockquote>
<p>为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：<code>X:X:X:X:X:X:d.d.d.d</code>，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如<code>::192.168.0.1</code>与<code>::FFFF:192.168.0.1</code>就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用</p>
</blockquote>
</li>
</ol>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><ul>
<li>ip用来标识主机，端口(port)用来指定数据传输的主机程序</li>
</ul>
<h3 id="知名端口-Well-Known-Ports"><a href="#知名端口-Well-Known-Ports" class="headerlink" title="知名端口(Well Known Ports)"></a>知名端口(Well Known Ports)</h3><ul>
<li>知名端口是众所周知的端口号，范围从0到1023，如：<ul>
<li><code>80</code>端口分配给HTTP服务</li>
<li><code>21</code>端口分配给FTP服务<h3 id="动态端口-Dynamic-Ports"><a href="#动态端口-Dynamic-Ports" class="headerlink" title="动态端口(Dynamic Ports)"></a>动态端口(Dynamic Ports)</h3></li>
</ul>
</li>
<li>动态端口范围是1024-65535</li>
<li>之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配<blockquote>
<p>动态分配：程序需要网络通信时，它向主机申请一个端口，主机从可用的端口中为它分配一个，当这个程序关闭时，同时也就释放了它所占用的端口</p>
</blockquote>
</li>
</ul>
<h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><ul>
<li>网络套接字是IP地址与端口的组合。套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信.</li>
</ul>
<h3 id="在python中使用socket"><a href="#在python中使用socket" class="headerlink" title="在python中使用socket"></a>在python中使用socket</h3><ul>
<li>在python中使用socket模块即可<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">socket.socket(AddressFamily, Type)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>参数说明</p>
<blockquote>
<p>AddressFamily: 可以选择<code>AF_INET</code>(用于Internet进程间通讯)或者<code>AF_UNIX</code>(用于同一台机器进程间通讯)，实际工作中常用<code>AF_INET</code><br>Type: 套接字类型，可以是<code>SOCK_STREAM</code>(流式套接字，主要用于<strong>TCP协议</strong>)，或者<code>SOCK_DGRAM</code>(数据报套接字，主要用于<strong>UDP协议</strong>)</p>
</blockquote>
</blockquote>
<ul>
<li>创建一个tcp套接字<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建tcp的套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用套接字的功能</span></span><br><span class="line"><span class="meta">... </span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可以发现，它的基本流程与文件的操作大致相同</p>
</blockquote>
<ul>
<li>创建一个udp套接字<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""测试udp发送数据"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建udp套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 接收要发送的数据</span></span><br><span class="line">    send_data = input(<span class="string">"请输入发送的数据："</span>)</span><br><span class="line">    <span class="comment"># 发送数据  使用utf-8编码，后接元组(ip地址，端口)</span></span><br><span class="line">    udp_socket.sendto(send_data.encode(<span class="string">"utf-8"</span>), (<span class="string">"192.168.32.32"</span>, <span class="number">8080</span>))</span><br><span class="line">    <span class="comment"># 关闭套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>@property装饰器</title>
    <url>/2019/09/11/property%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>@property</code>装饰器可以让方法像属性一样进行调用</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><h4 id="不使用-property装饰器"><a href="#不使用-property装饰器" class="headerlink" title="不使用@property装饰器"></a>不使用@property装饰器</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">jack = Person(<span class="number">18</span>)</span><br><span class="line">print(jack.get_age())</span><br><span class="line">jack.set_age(<span class="number">20</span>)</span><br><span class="line">print(jack.get_age())</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.__age</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意这里是age.setter</span></span><br><span class="line"><span class="meta">	@age.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">		self.__age = age</span><br><span class="line"></span><br><span class="line">jack = Person(<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 像属性一样调用方法</span></span><br><span class="line">print(jack.age)</span><br><span class="line"><span class="comment"># 像属性一样调用方法</span></span><br><span class="line">jack.age = <span class="number">20</span></span><br><span class="line">print(jack.age)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>property装饰器</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>eval()函数</title>
    <url>/2019/09/10/eval-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数学计算</span></span><br><span class="line">input:  eval(<span class="string">"1+1"</span>)</span><br><span class="line">output: <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串重复</span></span><br><span class="line">input:  eval(<span class="string">"'*' * 10"</span>)</span><br><span class="line">output: **********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转化为列表</span></span><br><span class="line">input:  type(eval(<span class="string">"[1, 2, 3, 4]"</span>))</span><br><span class="line">output: list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换为字典</span></span><br><span class="line">input:  type(eval(<span class="string">"&#123;'name': 'xiaoming', 'age': 18&#125;"</span>))</span><br><span class="line">output: dict</span><br></pre></td></tr></table></figure>

<h3 id="演示案例：计算器"><a href="#演示案例：计算器" class="headerlink" title="演示案例：计算器"></a>演示案例：计算器</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(eval(input(<span class="string">"请输入计算式: "</span>)))</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入计算式: <span class="number">5</span>+<span class="number">2</span>*<span class="number">5</span>**<span class="number">2</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="不要滥用eval"><a href="#不要滥用eval" class="headerlink" title="不要滥用eval"></a>不要滥用eval</h3><ul>
<li><p>使用eval()直接转换输入结果可能导致安全漏洞，如上例中用户输入<code>__import__(&#39;os&#39;).system(&#39;ls&#39;)</code></p>
</li>
<li><p>等价于</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">"ls"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入计算式: __import__(<span class="string">'os'</span>).system(<span class="string">'ls'</span>)</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出了当前目录下文件列表，同理也可执行其他增删改的终端命令，很不安全</p>
</blockquote>
<ul>
<li>执行成功，返回0</li>
<li>执行失败，返回错误信息</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>eval</tag>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python的文件操作</title>
    <url>/2019/09/09/python%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><h3 id="操作文件的函数-方法"><a href="#操作文件的函数-方法" class="headerlink" title="操作文件的函数/方法"></a>操作文件的函数/方法</h3><table>
<thead>
<tr>
<th>函数/方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>open</td>
<td>打开文件，并返回操作对象</td>
</tr>
<tr>
<td>read</td>
<td>将文件读取到内存</td>
</tr>
<tr>
<td>write</td>
<td>将指定内容写入文件</td>
</tr>
<tr>
<td>writeLines</td>
<td>将指定内容写入文件，不填加换行符</td>
</tr>
<tr>
<td>fiush</td>
<td>把缓冲区的内容写入文件，但不关闭文件</td>
</tr>
<tr>
<td>close</td>
<td>把缓冲区的内容写入文件，并关闭文件</td>
</tr>
</tbody></table>
<blockquote>
<p><code>read</code> <code>write</code> <code>close</code>三者都要通过<strong>文件对象</strong>来进行调用</p>
</blockquote>
<h3 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h3><ul>
<li><code>open()</code>第一个参数是要打开的文件名(区分大小写)</li>
<li>打开后操作完成要使用<code>close()</code>关闭，否则会消耗系统资源，影响后续对文件的访问</li>
<li>通常先编写打开和关闭文件代码，在编写中间的读写操作</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开</span></span><br><span class="line">file = open(<span class="string">"文件名"</span>)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">text = file.read()</span><br><span class="line">print(text)</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>关于文件指针<ul>
<li>python中读取完内容后会将指针移动到读取内容的末尾，默认是文件末尾</li>
<li><strong>连续两次读取文件，由于第一次读完指针已经在末尾，因而第二次读不到内容</strong></li>
</ul>
</li>
</ul>
<h3 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h3><ul>
<li><code>open()</code>默认以只读打开</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"文件名"</span>, <span class="string">"访问方式"</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>访问方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读，指针在文件开头，不存在会抛出异常</td>
</tr>
<tr>
<td>w</td>
<td>只写，若文件存在则覆盖，不存在则创建</td>
</tr>
<tr>
<td>a</td>
<td>追加，文件存在，指针就放在文件末尾，不存在，抛出异常</td>
</tr>
<tr>
<td>r+</td>
<td>读写，文件指针在开头，若不存在，抛出异常</td>
</tr>
<tr>
<td>w+</td>
<td>读写，文件存在则覆盖，不存在就创建</td>
</tr>
<tr>
<td>a+</td>
<td>读写，文件存在则指针放在末尾，文件不存在，创建新文件</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式，可与其他模式组合</td>
</tr>
</tbody></table>
<ul>
<li>使用<strong>读写方式</strong>打开，会影响文件读写效率，开发中更多的是<strong>以只读，只写的方式</strong>打开</li>
<li>对于二进制文件需要加<code>b</code>，如打开模式为<code>wb</code>，<code>rb</code></li>
</ul>
<h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><ul>
<li><code>read()</code>方法默认读取全部，读取大文件对于系统内存占用会非常严重</li>
</ul>
<h4 id="readLine方法"><a href="#readLine方法" class="headerlink" title="readLine方法"></a>readLine方法</h4><ul>
<li>一次读取一行，方法执行后，指针向下移动一行</li>
<li>读取大文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行</span></span><br><span class="line">    text = file.readLine()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#判断是否读取到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#每读到一行末尾已经有"\n"</span></span><br><span class="line">    print(text, end=<span class="string">""</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">file_r = open(<span class="string">"test"</span>)</span><br><span class="line">file_w = open(<span class="string">"test_copy"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    text = file_r.readLine()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    file_w.write(text)</span><br><span class="line"></span><br><span class="line">file_r.close()</span><br><span class="line">file_w.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后打开<code>file_w</code>文件，发现已经复制了<code>file_r</code>的内容</li>
</ul>
<h2 id="文件-目录的常用管理操作"><a href="#文件-目录的常用管理操作" class="headerlink" title="文件/目录的常用管理操作"></a>文件/目录的常用管理操作</h2><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>rename</td>
<td>重命名文件</td>
<td>os.rename(“源文件名”, “目标文件名”)</td>
</tr>
<tr>
<td>remove</td>
<td>删除文件</td>
<td>os.remove(“文件名”)</td>
</tr>
</tbody></table>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入os模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>listdir</td>
<td>目录列表</td>
<td>os.listdir(“目录名”)</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
<td>os.mkdir(“目录名”)</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除目录</td>
<td>os.rmdir(“目录名”)</td>
</tr>
<tr>
<td>getcwd</td>
<td>获取当前目录</td>
<td>os.getcwd()</td>
</tr>
<tr>
<td>chdir</td>
<td>修改工作目录</td>
<td>os.chdir(“目标目录”)</td>
</tr>
<tr>
<td>path.isdir</td>
<td>判断是否为目录</td>
<td>os.path.isdir(“文件路径”)</td>
</tr>
</tbody></table>
<h3 id="python编码"><a href="#python编码" class="headerlink" title="python编码"></a>python编码</h3><blockquote>
<ul>
<li>python2默认使用ascii编码，不支持中文</li>
<li>python3默认使用utf-8编码，支持中文</li>
</ul>
</blockquote>
<ul>
<li>改变python2的编码格式，使支持中文，将下句代码写在文件开头<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *-* coding:utf-8 *-*</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>或者</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>另外，使用python2输出中文时，会出现乱码，这是因为解释器会一个字节一个字节的输出，而中文一般是三个字节</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># *-* coding: utf-8 *-*</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">"hello, 你好"</span></span><br><span class="line">print(my_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> my_str:</span><br><span class="line">    print(letter)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hello, 你好</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">,</span><br><span class="line"></span><br><span class="line">�</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">�</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出乱码</p>
</blockquote>
<ul>
<li><p>解决方法：定义字符串时，前面加上字母<code>u</code>，说明这是utf-8格式的字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">u"hello, 你好"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次运行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello, 你好</span><br><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">,</span><br><span class="line"></span><br><span class="line">你</span><br><span class="line">好</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>不再乱码</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>python的模块和包</title>
    <url>/2019/09/06/python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>每一个以<code>py</code>结尾的python源代码文件都是一个模块</p>
<a id="more"></a>

<h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><h3 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a>import导入</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li><p>不推荐格式：将几个模块放在一行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推荐:每个模块单独占一行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>导入之后可以通过<code>模块名.</code>的方式使用模块提供的工具：<strong>全局变量，类，函数</strong></p>
</li>
</ul>
<h4 id="使用as指定模块别名"><a href="#使用as指定模块别名" class="headerlink" title="使用as指定模块别名"></a>使用as指定模块别名</h4><ul>
<li>如果模块名字太长就可以使用<code>as</code>来指定别名，方便实用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 模块别名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>模块别名应该符合<strong>大驼峰命名法</strong></p>
</blockquote>
<h3 id="from…import导入"><a href="#from…import导入" class="headerlink" title="from…import导入"></a>from…import导入</h3><ul>
<li>如果希望从某一个模块中，导入<strong>部分工具</strong>，就可以使用这种方式</li>
<li>语法格式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从模块导入某一个工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>导入之后不需要通过<code>模块名.</code>就可以直接使用模块的工具<br>如果两个模块存在<strong>同名的函数</strong>，那么后导入模块的函数，会<strong>覆盖掉先导入的函数</strong></p>
</blockquote>
<ul>
<li>可以通过<code>as</code>别名的方式调用前面导入的函数<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pkg1 <span class="keyword">import</span> test <span class="keyword">as</span> pkg1_test  <span class="comment">#给test()函数起别名</span></span><br><span class="line"><span class="keyword">from</span> pkg2 <span class="keyword">import</span> test   <span class="comment"># pkg1和pkg2中同时含有test()方法</span></span><br><span class="line"></span><br><span class="line">pkg1_test()     <span class="comment">#调用pkg1的test()</span></span><br><span class="line">test()      <span class="comment">#调用pkg2的test()</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="导入全部"><a href="#导入全部" class="headerlink" title="导入全部"></a>导入全部</h4><ul>
<li>语法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 模块 导入 所有工具</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>不推荐使用，因为函数重名不好排查</p>
</blockquote>
<h2 id="python导入模块的顺序"><a href="#python导入模块的顺序" class="headerlink" title="python导入模块的顺序"></a>python导入模块的顺序</h2><ol>
<li>搜索<strong>当前目录</strong>指定模块名的文件，如果有就直接导入</li>
<li>如果没有，再搜索系统目录<blockquote>
<p>在开发时创建文件，命名不要和系统模块文件重名，否则调用系统方法时会因为当前目录下存在该模块而不去搜索系统目录，使程序无法正确执行</p>
</blockquote>
</li>
</ol>
<ul>
<li>使用内置方法<code>__file__</code>可查看文件完整路径<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(模块名.__file__)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="关于模块导入"><a href="#关于模块导入" class="headerlink" title="关于模块导入"></a>关于模块导入</h2><ul>
<li>在导入模块时，文件中没有缩进的代码<strong>都会被执行一遍</strong><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是test1模块中的内容</span></span><br><span class="line">print(<span class="string">"这是模块一"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是test2模块中的内容</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(<span class="string">"这是模块二"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在模块test2中<code>run</code>，执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">这是模块一</span><br><span class="line">这是模块二</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而有时开发中开发者要做一些测试，写的一些代码只希望在本文件内执行而不想在被导入时执行</p>
<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a><code>__name__</code>属性</h3><blockquote>
<p><code>__name__</code>属性可以做到，测试模块的代码只在测试时执行，在被导入时不执行</p>
</blockquote>
<ul>
<li><code>__name__</code>属性是python的一个内置属性，记录着一个字符串</li>
<li>如果是被其他文件导入的，则记录的是<strong>模块名</strong></li>
<li>如果是当前执行的程序，<code>__name__</code>是<code>__main__</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test1中</span></span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test2中</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在test2中<code>run</code>，运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test1</span><br><span class="line">__main__</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以在测试时可以通过<code>__name__</code>来实现代码仅在测试时执行</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test1中</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"这是模块一"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test2中</span></span><br><span class="line"><span class="keyword">import</span> test1</span><br><span class="line">print(<span class="string">"这是模块二"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在模块test2中<code>run</code>，运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">这是模块二</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写代码格式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件末尾，编写本地测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><ul>
<li><strong>包</strong>是一个包含多个模块的<strong>特殊目录</strong></li>
<li>目录下有一个特殊的文件<strong><code>__init__.py</code></strong></li>
<li>包的命名和变量一致，使用<code>小写字母</code>和<code>_</code>，如<code>this_is_a_pkg</code></li>
<li>可以使用<code>import 包名</code>的方式，一次性导入包中所有的模块</li>
<li>在pycharm中鼠标停在工程名上点击鼠标右键<ul>
<li>选择new –&gt; Python Package可以建立包并自动创建<code>__init__.py</code>空文件</li>
<li>或选择new –&gt; Directory创建文件目录，再自行创建<code>__init__.py</code>文件</li>
</ul>
</li>
<li><code>__init__.py</code>文件<ul>
<li>包中可以对外界使用的模块，需要在<code>__init__.py</code>中写出列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 当前目录 导入 模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名称<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> 模块名称<span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="发布模块包的步骤"><a href="#发布模块包的步骤" class="headerlink" title="发布模块包的步骤"></a>发布模块包的步骤</h1><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><ul>
<li>创建<code>setup.py</code>文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">"pkg_name"</span>,  <span class="comment"># 包名</span></span><br><span class="line">      version=<span class="string">"1.0"</span>,  <span class="comment"># 版本</span></span><br><span class="line">      description=<span class="string">"some text"</span>,  <span class="comment"># 描述信息</span></span><br><span class="line">      long_description=<span class="string">"完整的发送和接收消息模块"</span>,  <span class="comment"># 完整描述信息</span></span><br><span class="line">      author=<span class="string">"itheima"</span>,  <span class="comment"># 作者</span></span><br><span class="line">      author_email=<span class="string">"abc.com"</span>,  <span class="comment"># 作者邮箱</span></span><br><span class="line">      url=<span class="string">"www.abc.com"</span>,  <span class="comment"># 主页</span></span><br><span class="line">      py_modules=[<span class="string">"包名.模块名1"</span>,  <span class="comment">#要分享的模块</span></span><br><span class="line">                  <span class="string">"包名.模块名2"</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关字典参数的详细信息，可以参阅<a href="https://docs.python.org/2/distutils/apiref.html" target="_blank" rel="noopener">官方网站</a> </p>
<ul>
<li><p>构建模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py build</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成发布压缩包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 setup.py sdist</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！</p>
</blockquote>
<h2 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h2><ul>
<li><p>安装模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf 压缩包名.tar.gz </span><br><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载模块<br>直接从安装目录下，把安装模块的目录删除就可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.7/dist-packages/</span><br><span class="line">sudo rm -r 包名*</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用pip安装第三方模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将第三方模块安装到python2.x环境</span></span><br><span class="line">sudo pip install 模块</span><br><span class="line">sudo pip uninstall 模块</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第三方模块安装到python3.x环境</span></span><br><span class="line">sudo pip3 install 模块</span><br><span class="line">sudo pip3 uninstall 模块</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的异常</title>
    <url>/2019/09/06/python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>程序开发时很难将所有特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件集中处理，从而保证程序的稳定性和健壮性</p>
<a id="more"></a>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="简单捕获"><a href="#简单捕获" class="headerlink" title="简单捕获"></a>简单捕获</h3><ul>
<li>格式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    尝试执行的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现错误的处理</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>执行后会继续执行下方的代码</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	print(<span class="string">"请输入正确的整数"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"继续执行了下方代码"</span>)</span><br></pre></td></tr></table></figure>

<p>执行程序：用户输入了aaa，无法转化为整数</p>
<blockquote>
<p>请输入一个整数:  aaa</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请输入正确的整数</span><br><span class="line">继续执行了下方代码</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="错误类型捕获"><a href="#错误类型捕获" class="headerlink" title="错误类型捕获"></a>错误类型捕获</h3><ul>
<li><p>针对不同类型的异常，作出不同的相应</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#尝试执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="comment">#针对类型1处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="comment">#针对类型2和3处理</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 捕获未知错误，可以改变result的名字</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取错误类型：出错时，控制台提示的最后一行就是错误类型，找到错误类型就可针对不同的错误进行不同的操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">result = <span class="number">10</span>/num</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>执行程序，用户输入0</p>
<blockquote>
<p>请输入一个整数:  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/duguosheng/PycharmProjects/190902/d2_excpt.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    result = <span class="number">10</span>/num</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>则<strong>ZeroDivisionError</strong>就是输入零时的错误类型，同理可得，输入字母时的错误类型是<strong>ValueError</strong></p>
</blockquote>
<ul>
<li><p>针对不同错误类型的处理</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">	result = <span class="number">10</span> / num</span><br><span class="line">	print(result)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">	print(<span class="string">"请不要输入0作为除数"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	print(<span class="string">"请输入数字"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获未知异常:假设未能预计到输入零的情况</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数:  "</span>))</span><br><span class="line">	result = <span class="number">10</span> / num</span><br><span class="line">	print(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">	print(<span class="string">"请输入数字"</span>)</span><br><span class="line"><span class="comment"># 捕获未知异常</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>用户输入0</p>
<blockquote>
<p>请输入一个整数:  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">未知错误 division by zero</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="异常捕获完整语法"><a href="#异常捕获完整语法" class="headerlink" title="异常捕获完整语法"></a>异常捕获完整语法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> (错误类型<span class="number">2</span>, 错误类型<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#没有异常才会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment">#无论是否有异常，都会执行的代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h2><ul>
<li>当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方</li>
<li>如果<strong>传递到主程序</strong>，仍然<strong>没有异常处理</strong>，程序才会终止<blockquote>
<p>开发中可以在主函数中增加异常捕获，这样就可以大大减少异常捕获代码，使代码整洁</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/int(input(<span class="string">"请输入一个整数：  "</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> test1()</span><br><span class="line"></span><br><span class="line"><span class="comment">#只在主函数中增加异常捕获</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	print(test2())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(<span class="string">"未知错误 %s"</span> % result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输入0</p>
<blockquote>
<p>请输入一个整数：  0</p>
</blockquote>
<ul>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">未知错误 division by zero</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功捕获异常并处理</p>
</li>
</ul>
<h2 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h2><blockquote>
<p>当前函数只负责某项功能，主动抛出异常后，让其他函数再处理</p>
</blockquote>
<ul>
<li><p>主动抛出异常的方法</p>
<ul>
<li>创建一个<code>Exception</code>对象</li>
<li>使用<code>raise</code>关键字抛出异常对象</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	num = int(input(<span class="string">"请输入一个整数：  "</span>))</span><br><span class="line">	<span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>/num</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#主动抛出异常</span></span><br><span class="line">	exception = Exception(<span class="string">"请不要输入0"</span>)</span><br><span class="line">	<span class="keyword">raise</span> exception</span><br><span class="line"></span><br><span class="line"><span class="comment">#只在主函数中增加异常捕获</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	print(test())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">	print(result)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输入0</p>
<blockquote>
<p>请输入一个整数：  0</p>
</blockquote>
<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">请不要输入<span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/09/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式是为了可重用代码，让代码易于理解，保证可靠性</p>
<a id="more"></a>

<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul>
<li>让类创建的对象，在系统中只有<strong>惟一的一个实例</strong></li>
<li>每一次执行<code>类名()</code>返回的对象，<strong>内存地址是相同的</strong></li>
</ul>
<h2 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__方法"></a><code>__new__</code>方法</h2><ul>
<li><p>创建对象时，首先会使用<code>__new__</code>方法为对象分配内存空间</p>
</li>
<li><p><code>__new__</code>方法：</p>
<ol>
<li>在内存中为对象分配空间</li>
<li>返回对象的引用</li>
</ol>
</li>
<li><p>python解释器获得对象的引用之后，将引用作为<strong>第一个参数</strong>，传递给<code>__init__</code>方法</p>
</li>
<li><p><strong><em>重写<code>__new__</code>方法的代码非常固定</em></strong></p>
</li>
<li><p><code>__new__</code>是一个静态方法，调用时需要主动传递<code>cls</code>参数</p>
</li>
<li><p>重写<code>__new__</code><strong>一定要`return super().<strong>new</strong>(cls)</strong></p>
<ul>
<li>否则解释器得不到分配了空间的对象引用，就<strong>不会调用<code>__init__</code></strong>方法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="string">"分配空间"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"创建对象"</span>)</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">print(a1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">分配空间</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见自动执行了<code>__new__</code>而没有执行<code>__init__</code>，且<code>a1</code>没有内存空间</p>
</blockquote>
<h2 id="python中的单例"><a href="#python中的单例" class="headerlink" title="python中的单例"></a>python中的单例</h2><ol>
<li>定义一个<strong>类属性</strong>，初始值是<code>None</code>，用于记录单例对象的引用</li>
<li>重写<code>__new__</code>方法</li>
<li>如果属性<code>is None</code>，调用父类的方法分配空间，并在类属性中记录结果</li>
<li>返回类属性中记录的对象引用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="comment"># 创建类属性记录对象引用</span></span><br><span class="line">	instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 重写__new__</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="comment">#判断是否为空对象</span></span><br><span class="line">		<span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># is None则分配空间</span></span><br><span class="line">			cls.instance = super().__new__(cls)</span><br><span class="line">		<span class="comment">#返回对象引用</span></span><br><span class="line">		<span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line">print(a1)</span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;__main__.A object at <span class="number">0x7f701d71e690</span>&gt;</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f701d71e690</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见a1与a2地址是相同的，是同一个对象</p>
</blockquote>
<h2 id="只执行一次初始化"><a href="#只执行一次初始化" class="headerlink" title="只执行一次初始化"></a>只执行一次初始化</h2><ul>
<li><p>上例中每创建一个对象就会调用一次<code>__init__</code></p>
</li>
<li><p>设立类属性标志位，在<code>__init__</code>中判断</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="comment"># 创建类属性记录对象引用</span></span><br><span class="line">	instance = <span class="literal">None</span></span><br><span class="line">	init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 重写__new__,静态方法需要传入cls以访问类属性</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">		<span class="comment">#判断是否为空对象</span></span><br><span class="line">		<span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">			<span class="comment"># is None则分配空间</span></span><br><span class="line">			cls.instance = super().__new__(cls)</span><br><span class="line">		<span class="comment">#返回类属性</span></span><br><span class="line">		<span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="comment"># 使用类名.的方式访问类属性</span></span><br><span class="line">		<span class="keyword">if</span> A.init_flag:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		A.init_flag = <span class="literal">True</span></span><br><span class="line">		print(<span class="string">"初始化"</span>)</span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a2 = A()</span><br><span class="line">print(a1)</span><br><span class="line">print(a2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f1aa35baa50</span>&gt;</span><br><span class="line">&lt;__main__.A object at <span class="number">0x7f1aa35baa50</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>只被初始化了一次</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>类属性，类方法，静态方法</title>
    <url>/2019/09/05/%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h1><a id="more"></a>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol>
<li>创建出来的对象叫<strong>实例</strong></li>
<li>创建对象的动作叫<strong>实例化</strong></li>
<li>对象的属性叫做<strong>实例属性</strong></li>
<li>对象调用的方法叫<strong>实例方法</strong></li>
</ol>
<ul>
<li>每一个对象都有自己独立的内存空间，保存各自不同的属性</li>
<li>多个对象的方法，在内存中只有一份，调用方法时，需要把<strong>对象的引用</strong>传递到方法内部</li>
</ul>
<h4 id="类是特殊的对象"><a href="#类是特殊的对象" class="headerlink" title="类是特殊的对象"></a>类是特殊的对象</h4><ul>
<li>python中一切皆对象<ul>
<li><code>class A</code>定义的类属于<strong>类对象</strong></li>
<li><code>aa = A()</code>属于实例对象</li>
</ul>
</li>
<li>在程序运行时，类也会被<strong>加载到内存</strong><ul>
<li>类对象在内存中<strong>只有一份</strong>，使用一个类可以创建出很多对象实例</li>
<li>除了实例的属性和方法外，类对象还可以拥有自己的属性和方法<ul>
<li>类属性</li>
<li>类方法</li>
<li>通过<code>类名.</code>的方式可以访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>类属性旧式给<strong>类对象</strong>定义的属性，通常用它来记录与这个类相关的特征</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">print(A.count)</span><br><span class="line">a2 = A()</span><br><span class="line">print(A.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="属性获取机制"><a href="#属性获取机制" class="headerlink" title="属性获取机制"></a>属性获取机制</h3><ul>
<li>访问属性有两种方式<ul>
<li>类名.类属性</li>
<li>对象.类属性（不推荐）</li>
</ul>
</li>
<li>在python中使用<code>对象.属性</code>时<ul>
<li>先从对象内部查找对象属性，如果没有就会向上寻找类属性<blockquote>
<p>上例中也可写作</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"a1.count"</span>)</span><br><span class="line">print(<span class="string">"a2.count"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="不要使用对象访问类属性"><a href="#不要使用对象访问类属性" class="headerlink" title="不要使用对象访问类属性"></a>不要使用对象访问类属性</h4><ul>
<li><p>使用<code>对象.类属性</code>的方式给类属性赋值时，会给<strong>添加一个属性</strong>，<strong>不会影响到类属性</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		A.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a1 = A()</span><br><span class="line">a1.count = <span class="number">5</span></span><br><span class="line">print(A.count)</span><br><span class="line">print(a1.count)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul>
<li><p>定义类方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>cls.</code>访问类的属性和方法</p>
</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><blockquote>
<p>在开发时<strong>既不需要访问实例属性和实例方法，也不需要访问类方法和类属性</strong>，就可定义为静态方法</p>
</blockquote>
<ul>
<li><p>语法如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法名后面直接跟<code>()</code>，不需要加<code>self</code>或<code>cls</code></p>
</li>
<li><p>通过<code>类名.静态方法</code>调用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">"hello"</span>)</span><br><span class="line">A.test()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_多态</title>
    <url>/2019/09/05/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<ul>
<li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码灵活度</li>
</ul>
<a id="more"></a>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"跑跑跳跳"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xtq</span><span class="params">(Dog)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span>     <span class="comment">#重写父类方法</span></span><br><span class="line">		print(<span class="string">"飞到天上"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">play_with_dog</span><span class="params">(self, dog)</span>:</span></span><br><span class="line">		print(<span class="string">"快乐玩耍"</span>)</span><br><span class="line">		dog.play()</span><br><span class="line"></span><br><span class="line">wangcai = Dog() <span class="comment">#普通狗旺财</span></span><br><span class="line">xiaotian = Xtq() <span class="comment">#哮天犬</span></span><br><span class="line">xiaoming = Person()</span><br><span class="line">xiaoming.play_with_dog(wangcai)	</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">30</span>)</span><br><span class="line">xiaoming.play_with_dog(xiaotian)	<span class="comment">#使用方法不变，传入另一个对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">快乐玩耍</span><br><span class="line">跑跑跳跳</span><br><span class="line">******************************</span><br><span class="line">快乐玩耍</span><br><span class="line">飞到天上</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_继承</title>
    <url>/2019/09/05/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<ul>
<li>继承：实现<strong>代码的重用</strong>，相同的代码不需要重复编写</li>
</ul>
<a id="more"></a>

<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类<span class="params">(父类)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>继承的传递性：A继承自B，B继承自C，则A也拥有C的属性和方法</li>
<li>子类不能访问父类的私有属性或方法，但可以在父类方法中访问自身私有内容，子类调用该方法来间接访问</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul>
<li><p>语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类<span class="params">(父类<span class="number">1</span>, 父类<span class="number">2</span>)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：如果多继承中，不同的父类方法重名，则会优先使用继承顺序靠前的父类方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"A--test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"A--demo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"B--test"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"B--demo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, A)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"继承顺序是先A后B"</span>)</span><br><span class="line">cc = C()</span><br><span class="line">cc.test()</span><br><span class="line">cc.demo()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"继承顺序是先B后A"</span>)</span><br><span class="line">dd = D()</span><br><span class="line">dd.test()</span><br><span class="line">dd.demo()</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">继承顺序是先A后B</span><br><span class="line">A--test</span><br><span class="line">A--demo</span><br><span class="line">继承顺序是先B后A</span><br><span class="line">B--test</span><br><span class="line">B--demo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>尽管不会报错，但不利于程序的阅读和理解，所以尽量不要使用多继承，使用时，也尽量保证属性方法不重名</p>
</blockquote>
<h3 id="mro"><a href="#mro" class="headerlink" title="__mro__"></a><code>__mro__</code></h3><ul>
<li><p>用于查看方法搜索顺序<code>类名.__mro__</code> </p>
</li>
<li><p>如在上例中使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(C.__mro__)</span><br><span class="line">print(D.__mro__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重写方法override"><a href="#重写方法override" class="headerlink" title="重写方法override"></a>重写方法override</h2><ul>
<li><p>在子类中直接编写与父类中同名的方法即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"叫"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"吃"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"喵喵喵"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">tom.eat()</span><br><span class="line">tom.voice()</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">吃</span><br><span class="line">喵喵喵</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对父类方法进行扩展"><a href="#对父类方法进行扩展" class="headerlink" title="对父类方法进行扩展"></a>对父类方法进行扩展</h2><ul>
<li><p>调用父类方法</p>
<ol>
<li><code>super().方法名</code></li>
<li><code>父类名.方法(self)</code>  不推荐使用，因为当父类名改变时，语句也要改变<blockquote>
<p>将上例中<code>Cat</code> 类中voice方法改成</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(self)</span>:</span></span><br><span class="line">		super().voice() <span class="comment">#第一种方法调用父类方法</span></span><br><span class="line">        Animal.voice(self)  <span class="comment">#第二种方法</span></span><br><span class="line">		print(<span class="string">"喵喵喵"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">吃</span><br><span class="line">叫</span><br><span class="line">叫</span><br><span class="line">喵喵喵</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h2><ul>
<li>新式类：以<code>object</code> 为基类的类，推荐使用</li>
<li>旧式类：不以<code>object</code> 为基类的类，不推荐使用</li>
<li>python3中默认使用object类作为基类，即python3中定义的类全部是<strong>新式类</strong> </li>
<li>python2中如果没有指定父类，不会使用object类作为基类<blockquote>
<p>新旧类会影响方法搜索顺序<br>保证python2与python3的统一，可以写作</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><ul>
<li>旧式类：父类名称.<strong>init</strong>(self,参数1，参数2，…)</li>
<li>新式类：super(子类，self).<strong>init</strong>(参数1，参数2，….)</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment">#调用父类初始化方法</span></span><br><span class="line">		super(B, self).__init__(name)</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bb = B(<span class="string">"das"</span>, <span class="number">17</span>)</span><br><span class="line">print(bb.name)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python--面向对象_封装</title>
    <url>/2019/09/04/python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<ul>
<li>封装：根据职责，将<strong>方法</strong> 和<strong>属性</strong> 封装到一个类中</li>
</ul>
<a id="more"></a>

<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h2><ul>
<li><p>使用dir()可以查看一个对象所有的可用方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""this is a example"""</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    </span><br><span class="line">print(dir(test))    <span class="comment">#查看可用方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="string">'__bool__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用这些方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(test.__doc__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">this <span class="keyword">is</span> a example</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>返回了函数注释信息</p>
</blockquote>
<h2 id="定义简单类-只包含方法"><a href="#定义简单类-只包含方法" class="headerlink" title="定义简单类-只包含方法"></a>定义简单类-只包含方法</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span></span></span><br><span class="line"><span class="function">        <span class="title">pass</span></span></span><br><span class="line"><span class="function">    <span class="title">def</span> 方法2<span class="params">(self, 参数列表)</span></span></span><br><span class="line"><span class="function">        <span class="title">pass</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>类名使用<strong>大驼峰命名法</strong> 命名，首字母大写</li>
<li>类中的方法第一个参数必须是<code>self</code>，没有参数也要写<code>self</code> </li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">对象变量 = 类名()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先给创建出的对象开辟内存空间，再使<code>对象变量</code> 指向该地址</p>
</blockquote>
<blockquote>
<p>多次创建会开辟不同的内存空间</p>
</blockquote>
<ul>
<li><p>使用print()可以查看：对象的类和内存地址</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"i love fish"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&lt;__main__.Cat object at <span class="number">0x7f9c62f67290</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="给对象增加属性"><a href="#给对象增加属性" class="headerlink" title="给对象增加属性"></a>给对象增加属性</h2><ul>
<li>可以直接使用赋值语句，继续使用上个例子中创建的<code>tom</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tom.name = <span class="string">"汤姆"</span>   <span class="comment">#这样tom就获得了一个name的属性</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>这种方式不推荐使用，应当把属性封装在类中</p>
</blockquote>
<h3 id="关于self"><a href="#关于self" class="headerlink" title="关于self"></a>关于<code>self</code></h3><ul>
<li><p>哪一个对象调用的方法，<code>self</code>就是哪一个对象的引用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s 爱吃鱼"</span> % self.name)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br><span class="line">jf = Cat()</span><br><span class="line">tom.name = <span class="string">"汤姆"</span></span><br><span class="line">jf.name = <span class="string">"加菲"</span></span><br><span class="line">tom.eat()</span><br><span class="line">jf.eat()</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">汤姆 爱吃鱼</span><br><span class="line">加菲 爱吃鱼</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见<code>self.name</code> 返回的是各自的属性</p>
</blockquote>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ul>
<li><p>当使用类名创建对象时，自动执行</p>
<ol>
<li>创建对象：在内存中分配空间</li>
<li>初始化：执行<code>__init__</code>方法，<code>__init__</code>是专门用来定义一个类具有那些属性的方法</li>
</ol>
</li>
<li><p>自动执行<code>__init__</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"自动执行了__init__方法"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat()</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">自动执行了__init__方法</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="在初始化内部定义属性"><a href="#在初始化内部定义属性" class="headerlink" title="在初始化内部定义属性"></a>在初始化内部定义属性</h3><ul>
<li><p>在<code>__init__</code> 内部使用<code>self.属性名 = 属性初始值</code> 就可以定义属性</p>
</li>
<li><p>定义属性后，使用类名创建的对象都将拥有该属性</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"tom"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样创建的对象<code>name</code> 属性是相同的，若想创建的同时给对象指定不同的属性，可以给<code>__init</code> <strong>加入参数</strong> </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="内置方法和属性"><a href="#内置方法和属性" class="headerlink" title="内置方法和属性"></a>内置方法和属性</h2><h3 id="init"><a href="#init" class="headerlink" title="__init__"></a><code>__init__</code></h3><ul>
<li>初始化时自动调用</li>
</ul>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><ul>
<li><p>当对象被从内存中销毁前，会自动调用<code>__del__</code> 方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		print(<span class="string">"%s被创建了"</span> % name)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"对象被销毁了"</span>)</span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line">print(<span class="string">"*"</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TOM被创建了</span><br><span class="line">******************************</span><br><span class="line">对象被销毁了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用del-关键字可以删除对象"><a href="#使用del-关键字可以删除对象" class="headerlink" title="使用del 关键字可以删除对象"></a>使用<code>del</code> 关键字可以删除对象</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line"><span class="keyword">del</span> tom</span><br><span class="line">print(<span class="string">"*"</span> * <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">TOM被创建了</span><br><span class="line">对象被销毁了</span><br><span class="line">******************************</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可以使用<code>del</code> 关键字可以调用<code>__del__</code> 方法</p>
</blockquote>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><ul>
<li><p>python中使用<code>print()</code> 输出对象，默认返回类和地址</p>
</li>
<li><p>可以使用<code>__str__</code> 自定义返回内容</p>
</li>
<li><p><code>__str</code> 必须返回一个字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"i am %s"</span> % self.name</span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"TOM"</span>)</span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">i am TOM</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="一个对象的属性可以是另一个类创建的对象"><a href="#一个对象的属性可以是另一个类创建的对象" class="headerlink" title="一个对象的属性可以是另一个类创建的对象"></a>一个对象的属性可以是另一个类创建的对象</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, mouse)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.mouse = mouse</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">catch</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s抓住了%s"</span> % (self.name, self.mouse.name))</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line"></span><br><span class="line">jerry = Mouse(<span class="string">"Jerry"</span>)</span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>, jerry)</span><br><span class="line">tom.catch()</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tom抓住了Jerry</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="None-关键字"><a href="#None-关键字" class="headerlink" title="None 关键字"></a><code>None</code> 关键字</h2><ul>
<li>当不知道给参数什么初值时，可以使用<code>None</code>，他表示一个没有方法和属性的空对象，是一个特殊的常量</li>
<li>可以给任意一个变量赋<code>None</code><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line">self.name = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="身份运算符is-与is-not"><a href="#身份运算符is-与is-not" class="headerlink" title="身份运算符is 与is not"></a>身份运算符<code>is</code> 与<code>is not</code></h2><ul>
<li><p>身份运算符用于比较两个对象的<strong>内存地址</strong>是否一致–是否是对于同一个对象的引用</p>
</li>
<li><p>在python中使用<code>None</code> 比较时，建议使用<code>is</code> 和<code>is not</code> </p>
</li>
<li><p><code>is</code> 与<code>==</code> 的区别</p>
<ul>
<li><code>is</code> 判断是否为同一个对象</li>
<li><code>==</code> 判断值是否相等<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(a == b)</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h2><ul>
<li><p>定义方法：在定义属性或方法时，在名字前增加<strong>两个下划线</strong><code>__</code> </p>
</li>
<li><p>私有属性：在对象的方法内部可以访问，在外界不能直接访问</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, mouse)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__mouse = mouse</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.__mouse:	<span class="comment"># 在对象内部方法可以访问私有属性</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">"yes"</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>, <span class="literal">True</span>)</span><br><span class="line">print(tom.name)</span><br><span class="line"><span class="comment"># print(tom.__mouse) 访问不到私有属性__mouse</span></span><br><span class="line">print(tom)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Tom</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="伪私有属性和方法"><a href="#伪私有属性和方法" class="headerlink" title="伪私有属性和方法"></a>伪私有属性和方法</h3><ul>
<li><p>在python中，实际上没有完全的私有，对于私有属性和方法，在外部可以通过在属性或方法名前加<code>_类名</code>(下划线加类名)的方法访问，但尽量不要使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.__age = <span class="number">18</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"%s 年龄是%d"</span> % (self.name, self.__age))</span><br><span class="line"></span><br><span class="line">mary = Women(<span class="string">"玛丽"</span>)</span><br><span class="line">print(mary._Women__age)</span><br><span class="line">mary._Women__secret()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">18</span></span><br><span class="line">玛丽 年龄是<span class="number">18</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/2019/09/03/python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><a id="more"></a>

<ul>
<li><p>利用元组返回多个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    str = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">return</span> (num, str)</span><br><span class="line">    </span><br><span class="line">temp = test()         <span class="comment">#则temp是一个元组类型，对于不同的内容要使用对应索引调用，容易出错</span></span><br><span class="line">temp1, temp2 = test() <span class="comment">#或使用多个变量接收返回值，方便管理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同理，可利用元组交换数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = (b, a)</span><br><span class="line">a, b = b, a     <span class="comment"># =右边是省略括号的元组</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><h5 id="在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用"><a href="#在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用" class="headerlink" title="在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用"></a>在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(num, my_list)</span>:</span></span><br><span class="line">    print(<span class="string">"函数内部："</span>)</span><br><span class="line">    <span class="comment">#赋值</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    my_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(num)</span><br><span class="line">    print(my_list)</span><br><span class="line">    </span><br><span class="line">g_num = <span class="number">5</span></span><br><span class="line">g_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test(g_num, g_list)</span><br><span class="line">print(<span class="string">"执行完成后"</span>)</span><br><span class="line">print(g_num)</span><br><span class="line">print(g_list)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">函数内部：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">执行完成后</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>实参未改变，其原因是变量与数据是分开存储的，<code>g_num</code> 指向数据<code>5</code> 的地址，当将<code>g_num</code>传入test函数是，实则是传入了数据<code>5</code> 的地址，而当使用赋值语句时，局部变量<code>num</code>指向新的数据<code>10</code> ，但<code>g_num</code>仍然指向<code>5</code> </p>
</blockquote>
<h5 id="如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据"><a href="#如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据" class="headerlink" title="如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据"></a>如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(my_list)</span>:</span></span><br><span class="line">	print(<span class="string">"函数内部："</span>)</span><br><span class="line">	my_list.append(<span class="number">9</span>)</span><br><span class="line">	print(my_list)</span><br><span class="line"></span><br><span class="line">g_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test1(g_list)</span><br><span class="line">print(<span class="string">"程序结束：%s"</span> % g_list)</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">函数内部：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">程序结束：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见外部参数也被修改，其原因是使用数据的自身方法不会创建新的数据，而是在原有数据上的修改，外部变量和局部变量同时指向该地址，因而在函数内部使用方法修改后会影响外部参数</p>
</blockquote>
<h5 id="对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend-方法"><a href="#对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend-方法" class="headerlink" title="+=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法"></a>+=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(num, my_list)</span>:</span></span><br><span class="line">	num += <span class="number">10</span></span><br><span class="line">	print(<span class="string">"不可变类型函数内部+=结果%d"</span> % num)</span><br><span class="line">	my_list += [<span class="number">8</span>]</span><br><span class="line">	print(<span class="string">"可变类型函数内部+=结果%s"</span> % my_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_number = <span class="number">5</span></span><br><span class="line">g_l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">test2(g_num,g_l1)</span><br><span class="line">print(<span class="string">"不可变类型外部结果%d"</span> % g_number)</span><br><span class="line">print(<span class="string">"可变类型外部结果%s"</span> % g_l1)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">不可变类型函数内部+=结果<span class="number">15</span></span><br><span class="line">可变类型函数内部+=结果[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br><span class="line">不可变类型外部结果<span class="number">5</span></span><br><span class="line">可变类型外部结果[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见前者外部未改变，后者外部改变</p>
</blockquote>
<hr>
<h2 id="给函数添加缺省值"><a href="#给函数添加缺省值" class="headerlink" title="给函数添加缺省值"></a>给函数添加缺省值</h2><ul>
<li><p>在函数定义时可在参数后面加<code>=</code> 并添加缺省值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(name, gender=True)</span>:</span>   <span class="comment">#True是gender的缺省值</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	输入姓名和性别</span></span><br><span class="line"><span class="string">	:param name: 姓名</span></span><br><span class="line"><span class="string">	:param gender: 性别 True男生 False女生</span></span><br><span class="line"><span class="string">	:return: null</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	gender_text = <span class="string">"男生"</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">		gender_text = <span class="string">"女生"</span></span><br><span class="line">	print(name+<span class="string">"是"</span>+gender_text)</span><br><span class="line"></span><br><span class="line">test3(<span class="string">"小明"</span>)           <span class="comment">#gender未输入，则使用缺省值</span></span><br><span class="line">test3(<span class="string">"小美"</span>, <span class="literal">False</span>)    <span class="comment">#指定gender</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">小明是男生</span><br><span class="line">小美是女生</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：带有缺省值的参数必须放在参数列表的末尾</p>
</li>
<li><p>当有多个缺省参数而需要指定特定的某个参数值时，需要同时输入参数名</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">(name, gender=True, grade=<span class="string">"大一"</span>)</span>:</span></span><br><span class="line">    <span class="comment">#代码块</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果指定gender</span></span><br><span class="line">test4(<span class="string">"小美"</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果指定grade</span></span><br><span class="line">test4(<span class="string">"小明"</span>, grade=<span class="string">"大二"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="多值参数"><a href="#多值参数" class="headerlink" title="多值参数"></a>多值参数</h2><ul>
<li>有时一个函数传入的参数个数是不确定的，这个时候就可以使用<strong>多值参数</strong> </li>
<li>python中有两种多值参数<ul>
<li>参数名前加<strong>一个</strong> <code>*</code>可以接收<strong>元组</strong> </li>
<li>参数名前加<strong>两个</strong> <code>*</code> 可以接收<code>字典</code> </li>
</ul>
</li>
<li>一般给多值参数命名时，习惯使用以下名字<ul>
<li><code>*args</code> – 存放元组  arguments(变量)</li>
<li><code>**kwargs</code> –存放字典  kw是keyword<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">(num, *args, **kwargs)</span>:</span></span><br><span class="line">	print(num)</span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">demo1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, name=<span class="string">"小明"</span>, age=<span class="number">18</span>)   <span class="comment">#这种写法无须拆包</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>键不需要加分号，并用=连接</p>
</blockquote>
<ul>
<li>输出结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="元组和字典的拆包"><a href="#元组和字典的拆包" class="headerlink" title="元组和字典的拆包"></a>元组和字典的拆包</h2><ul>
<li>在调用有多致参数的函数时，如果希望<ul>
<li>将元组直接传给<code>args</code> </li>
<li>将字典直接传给<code>kwargs</code></li>
</ul>
</li>
<li>就可以使用拆包<ul>
<li>在元组变量前加<strong>一个</strong><code>*</code></li>
<li>在字典变量前加<strong>两个</strong> <code>*</code></li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo2</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line"></span><br><span class="line">g_nums = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">g_dict = &#123;<span class="string">"姓名"</span>:<span class="string">"小明"</span>, <span class="string">"age"</span>:<span class="number">18</span>&#125;</span><br><span class="line">demo2(g_nums, g_dict)</span><br><span class="line">demo2(g_nums, **g_dict)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), &#123;<span class="string">'姓名'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line">((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),)</span><br><span class="line">&#123;<span class="string">'姓名'</span>: <span class="string">'小明'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>可见前者字典也被传给了<code>args</code>，与期望不符，而后者加了<code>**</code> 实现预期</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python中关于全局变量</title>
    <url>/2019/09/03/python%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="python中不允许直接修改全局变量的值"><a href="#python中不允许直接修改全局变量的值" class="headerlink" title="python中不允许直接修改全局变量的值"></a>python中不允许直接修改全局变量的值</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span>     <span class="comment">#定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<ul>
<li>按照其他语言的逻辑，全局变量在test1()中被修改为2，则在test2()中也输出2，而最终的输出结果是</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>并未如所想，其原因是python不允许直接修改全局变量的值，如果使用赋值语句，会在函数内部创建一个同名局部变量，而此局部变量在函数执行完成后就会被系统回收</p>
</blockquote>
<h2 id="全局变量的修改"><a href="#全局变量的修改" class="headerlink" title="全局变量的修改"></a>全局变量的修改</h2><ul>
<li>使用<code>global</code> 声明变量即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span>     <span class="comment">#定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(num)</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="什么时候使用global"><a href="#什么时候使用global" class="headerlink" title="什么时候使用global"></a>什么时候使用global</h3><ul>
<li>当对全局变量的指向进行修改的时候，需要使用<code>global</code>修饰，如果指向没有改变，则不需要，如：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">num_list1 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">num_list2 = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">global</span> num_list2</span><br><span class="line">    num = <span class="number">20</span>  <span class="comment"># 改变指向，需要声明</span></span><br><span class="line">    num_list1.append(<span class="number">33</span>)  <span class="comment"># 不改变指向，不需声明</span></span><br><span class="line">    num_list2 += [<span class="number">33</span>, <span class="number">44</span>]  <span class="comment"># 执行+=必须要声明global，因为这也是需要改变指向的操作，如果未声明程序就会崩溃</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list1)</span><br><span class="line">    print(num_list2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]  <span class="comment"># 使用append()方法没有改变指向，成功达到预期执行结果</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br></pre></td></tr></table></figure>

<h2 id="全局变量的命名"><a href="#全局变量的命名" class="headerlink" title="全局变量的命名"></a>全局变量的命名</h2><ul>
<li>可以在全局变量前加<code>g_</code> 或<code>gl_</code> 的前缀</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python的高级数据类型</title>
    <url>/2019/09/03/python%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="获取元素类型"><a href="#获取元素类型" class="headerlink" title="获取元素类型"></a>获取元素类型</h2><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用type()获取数据类型</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(type(my_list))</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li>类似于其他数据类型中的<strong>数组</strong></li>
<li>列表使用<code>[]</code>括起来</li>
<li>列表中可以存储不同类型的数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>]</span><br><span class="line">print(my_list[<span class="number">0</span>])   <span class="comment">#取值</span></span><br><span class="line">print(my_list.index(<span class="string">"aaa"</span>)) <span class="comment">#取索引</span></span><br><span class="line"></span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">"ddd"</span>  <span class="comment">#修改</span></span><br><span class="line"></span><br><span class="line">my_list.append(<span class="string">"eee"</span>)   <span class="comment">#增加数据</span></span><br><span class="line">my_list.insert(<span class="number">1</span>,<span class="string">"fff"</span>) <span class="comment">#插入数据在my_list[1]，后面的数据后移</span></span><br><span class="line">temp_list = [<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">my_list.extend(temp_list)   <span class="comment">#将另一个列表扩展进来</span></span><br><span class="line"></span><br><span class="line">my_list.remove(<span class="string">"bbb"</span>)   <span class="comment"># 删除指定元素,如果出现多次，删除第一个</span></span><br><span class="line">my_list.pop()       <span class="comment">#默认删除最后一个元素（出栈）</span></span><br><span class="line">my_list.pop(<span class="number">3</span>)      <span class="comment">#删除my_list[3]</span></span><br><span class="line">my_list.clear       <span class="comment">#清空列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]      <span class="comment">#利用del删除（直接从内存中删除，后续代码不可使用该变量）</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line">length = len(my_list)   <span class="comment">#读取列表大小</span></span><br><span class="line">time = my_list.count(<span class="string">"aaa"</span>)     <span class="comment">#读取aaa出现的次数</span></span><br><span class="line"></span><br><span class="line">my_list.sort()      <span class="comment">#升序排序</span></span><br><span class="line">my_list.sort(reverse=<span class="literal">True</span>)  <span class="comment">#降序排序</span></span><br><span class="line">my_list.reverse()   <span class="comment">#逆序反转</span></span><br></pre></td></tr></table></figure>

<ul>
<li>迭代遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> temp_name <span class="keyword">in</span> my_list:</span><br><span class="line">    print(<span class="string">"the name is %s"</span> % temp_name)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="创建列表的方式"><a href="#创建列表的方式" class="headerlink" title="创建列表的方式"></a>创建列表的方式</h3><ul>
<li><p>基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>list()</code>创建</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list1 = list(<span class="string">"abcde"</span>)</span><br><span class="line">my_list2 = list(range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">print(my_list1)</span><br><span class="line">print(my_list2)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用<code>range()</code>可以快速创建整数列表，其格式为<code>range([start,] end [,step])</code>，它返回的是一个range对象</p>
<blockquote>
<p><code>start</code>：起始数字，默认0<br><code>end</code>：结尾数字，必须指定<br><code>step</code>：步长，默认1</p>
</blockquote>
</blockquote>
<ul>
<li>推导式生成列表<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list3 = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">my_list4 = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>) <span class="keyword">if</span> x%<span class="number">5</span>==<span class="number">0</span>]</span><br><span class="line">my_list5 = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">if</span> y%<span class="number">3</span>==<span class="number">0</span>]</span><br><span class="line">my_list6 = [a <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"hello"</span>]</span><br><span class="line">print(my_list3)</span><br><span class="line">print(my_list4)</span><br><span class="line">print(my_list5)</span><br><span class="line">print(my_list6)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">225</span>, <span class="number">400</span>, <span class="number">625</span>, <span class="number">900</span>, <span class="number">1225</span>, <span class="number">1600</span>, <span class="number">2025</span>]</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">0</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li><p>元组与列表相似，不同之处在于元组的元素<strong>不能修改</strong> </p>
</li>
<li><p>使用<code>()</code> 定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义空元组</span></span><br><span class="line">empty_tuple = ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义单元素元组</span></span><br><span class="line">single_tuple = (<span class="number">5</span>)   <span class="comment">#这样定义得到的single_tuple是int类型</span></span><br><span class="line">single_tuple = (<span class="number">5</span>,)  <span class="comment">#正确</span></span><br><span class="line"></span><br><span class="line">my_tuple(<span class="number">1</span>)     <span class="comment"># 取值</span></span><br><span class="line">my_tuple.index(<span class="string">"aaa"</span>)   <span class="comment">#取索引</span></span><br><span class="line">my_tuple.count(<span class="string">"aaa"</span>)   <span class="comment">#统计aaa出现次数</span></span><br><span class="line">len(my_tuple)       <span class="comment">#统计长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> temp_info <span class="keyword">in</span> my_tuple:</span><br><span class="line">    执行代码</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="元组的应用"><a href="#元组的应用" class="headerlink" title="元组的应用"></a>元组的应用</h3><ul>
<li><p>拼接字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">175.5</span>)</span><br><span class="line">print(<span class="string">"%s的年龄是%d,身高是%f"</span> % my_tuple)</span><br><span class="line"></span><br><span class="line">my_str = <span class="string">"%s的年龄是%d,身高是%f"</span> % my_tuple</span><br><span class="line">print(my_str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>保护列表安全</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_tuple1 = tuple(my_list)      <span class="comment">#使用tuple()将list转换成tuple</span></span><br><span class="line">my_list2 = list(my_tuple1)      <span class="comment">#使用list()将tuple转换成list</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用元组返回多个值(同理也可使用列表，字典，集合)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    str = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">return</span> (num, str)</span><br><span class="line">    </span><br><span class="line">temp = test()       <span class="comment">#则temp是一个元组类型</span></span><br><span class="line">temp1, temp2 = test() <span class="comment">#多个变量接收返回值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交换数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = (b, a)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="生成器推导式生成元组"><a href="#生成器推导式生成元组" class="headerlink" title="生成器推导式生成元组"></a>生成器推导式生成元组</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_tp1 = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line">my_tp2 = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">50</span>) <span class="keyword">if</span> x%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 打印生成器</span></span><br><span class="line">print(my_tp1)</span><br><span class="line">print(my_tp2)</span><br><span class="line"><span class="comment"># 打印生成的元组，注意只能调用一次tuple()</span></span><br><span class="line">print(tuple(my_tp1))</span><br><span class="line">print(tuple(my_tp2))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc850&gt;</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc8d0&gt;</span><br><span class="line">(0, 2, 4, 6, 8)</span><br><span class="line">(0, 25, 100, 225, 400, 625, 900, 1225, 1600, 2025)</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul>
<li>使用<code>{}</code>定义</li>
<li>列表是有序的数据集合</li>
<li>字典是无序的数据集合</li>
<li>使用<code>键值对</code>存储数据<ul>
<li><strong>键</strong> <em>(key)</em> 是索引，必须<strong>唯一</strong> ，只能是<strong>字符串，数字，或者元组</strong> </li>
<li><strong>值</strong> <em>(value)</em> 是数据，可以是任意数据类型</li>
<li><em>key</em> 和<em>value</em> 之间使用<code>:</code> 分隔</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于字典无序，通常使用print()打印的结果与定义的顺序不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义</span></span><br><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>, </span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>, </span><br><span class="line">            <span class="string">"height"</span>: <span class="number">175</span>&#125;</span><br><span class="line">            </span><br><span class="line">xiaoming[<span class="string">"name"</span>]        <span class="comment">#取值</span></span><br><span class="line">xiaoming[<span class="string">"weight"</span>] = <span class="number">70</span> <span class="comment">#不存在则增加</span></span><br><span class="line">xiaoming[<span class="string">"age"</span>] = <span class="number">19</span>    <span class="comment">#若存在则修改</span></span><br><span class="line"></span><br><span class="line">xiaoming.pop(<span class="string">"weight"</span>)  <span class="comment">#删除</span></span><br><span class="line"></span><br><span class="line">len(xiaoming)           <span class="comment">#统计键值对数目</span></span><br><span class="line"></span><br><span class="line">temp_dict = &#123;<span class="string">"gender"</span>: boy, </span><br><span class="line">             <span class="string">"age"</span>: <span class="number">20</span>&#125;</span><br><span class="line">xiaoming.update(temp_dict)  <span class="comment">#若新增key不存在，则增加;若key重复，则会替换掉之前的value</span></span><br><span class="line"></span><br><span class="line">xiaoming.clear()        <span class="comment">#清空</span></span><br><span class="line">xiaoming.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">"name"</span>: <span class="string">"zhangsan"</span>, </span><br><span class="line">           <span class="string">"age"</span>: <span class="string">"18"</span>&#125;</span><br><span class="line">           </span><br><span class="line"><span class="comment"># 变量temp是my_dict中的key</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> my_dict:</span><br><span class="line">    print(<span class="string">"%s - %s"</span> % (temp,my_dict[temp]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>应用<br>先用字典存储复杂数据，再将多个字典放在一个列表中管理</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">card_list = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"zhangsan"</span>, </span><br><span class="line">     <span class="string">"qq"</span>: <span class="string">"12345"</span>&#125;</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"lisi"</span>, </span><br><span class="line">     <span class="string">"qq"</span>: <span class="string">"12412"</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> card_list:</span><br><span class="line">    print(info)</span><br></pre></td></tr></table></figure>

<h3 id="创建字典的几种方式"><a href="#创建字典的几种方式" class="headerlink" title="创建字典的几种方式"></a>创建字典的几种方式</h3><ul>
<li><p>使用{}基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict1 = &#123;<span class="string">"name"</span>:<span class="string">"张三"</span>, <span class="string">"age"</span>:<span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>dict()</code>方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict2 = dict(name=<span class="string">"张三"</span>, age=<span class="number">18</span>)</span><br><span class="line">my_dict3 = dict((<span class="string">"name"</span>, <span class="string">"张三"</span>), (<span class="string">"age"</span>, <span class="number">18</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>zip()</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_key = [<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>]</span><br><span class="line">my_value = [<span class="string">"张三"</span>, <span class="number">18</span>, <span class="string">"teacher"</span>]</span><br><span class="line">my_dict4 = dict(zip(my_key, my_value))</span><br><span class="line">print(my_dict4)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>运行结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;job&apos;: &apos;teacher&apos;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>fromkeys</code>创建值为空的字典<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_dict5 = dict.fromkeys([<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"job"</span>])</span><br><span class="line">print(my_dict5)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;name&apos;: None, &apos;age&apos;: None, &apos;job&apos;: None&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典推导式<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用推导式统计字符出现次数</span></span><br><span class="line">my_text = <span class="string">"hello, world"</span></span><br><span class="line">my_dict6 = &#123;my_char:my_text.count(my_char) <span class="keyword">for</span> my_char <span class="keyword">in</span> my_text&#125;</span><br><span class="line">print(my_dict6)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'l'</span>: <span class="number">3</span>, <span class="string">'o'</span>: <span class="number">2</span>, <span class="string">','</span>: <span class="number">1</span>, <span class="string">' '</span>: <span class="number">1</span>, <span class="string">'w'</span>: <span class="number">1</span>, <span class="string">'r'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote>
<p>集合无序可变，<strong>元素不能重复</strong>，集合底层是字典实现，集合中的元素都是字典中的<code>键对象</code>，因此不可重复</p>
</blockquote>
<ul>
<li><p>使用{}创建集合对象，并使用<code>add()</code>添加元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">a.add(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>set()</code>可以将列表，元组等可迭代对象转化为集合，如果数据重复，只保存一个</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>]</span><br><span class="line">b = set(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>remove()</code>删除指定元素，<code>clear()</code>清空集合</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a.remove(<span class="string">"a"</span>)</span><br><span class="line">a.clear()</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合相关操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">2</span>, <span class="string">"a"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">print(a|b)</span><br><span class="line">print(a.union(b))</span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">print(a&amp;b)</span><br><span class="line">print(a.intersection(b))</span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">print(a-b)</span><br><span class="line">print(a.difference(b))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>结果</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串定义：使用''或""括起来的内容</span></span><br><span class="line">str1 = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="string">'world'</span>  <span class="comment">#为了和其他语言统一，尽量不使用单引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当需要字符串中包含引号时</span></span><br><span class="line">str3 = <span class="string">"my name is "</span>dgs<span class="string">""</span>   <span class="comment">#错误</span></span><br><span class="line">str4 = <span class="string">'my name is "dgs"'</span>   <span class="comment">#正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#取值</span></span><br><span class="line">str = <span class="string">"abcdefabcbac"</span></span><br><span class="line">str[<span class="number">2</span>]  <span class="comment">#第三个字符</span></span><br><span class="line">str[<span class="number">-1</span>] <span class="comment">#倒数第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代遍历</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> str:</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line">len(str)        <span class="comment">#统计长度</span></span><br><span class="line">str.index(”e“)    <span class="comment">#获取索引</span></span><br><span class="line">str.count(”a“)    <span class="comment">#统计a出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串切片  字符串[开始索引:结束索引:步长]，不包含结尾处索引的内容</span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">6</span>]    <span class="comment">#截取第二个到第六个</span></span><br><span class="line">str[<span class="number">2</span>:]     <span class="comment">#从第二个到末尾</span></span><br><span class="line">str[<span class="number">2</span>:<span class="number">-1</span>]   <span class="comment">#从第二个到倒数第一个</span></span><br><span class="line">str[:<span class="number">6</span>]     <span class="comment">#从开头到第六个</span></span><br><span class="line">str[::<span class="number">2</span>]    <span class="comment">#每隔一个截取一个</span></span><br><span class="line">str[<span class="number">-1</span>::<span class="number">-1</span>] <span class="comment">#获得字符串倒序</span></span><br></pre></td></tr></table></figure>

<h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>len(item)</td>
<td>计算容器中元素个数</td>
<td></td>
</tr>
<tr>
<td>del(item)</td>
<td>删除变量</td>
<td><code>del</code> 有两种方式<code>del(temp[1])</code> /<code>del(temp)</code></td>
</tr>
<tr>
<td>max(item)</td>
<td>返回容器元素最大值</td>
<td>字典只比较key</td>
</tr>
<tr>
<td>min(item)</td>
<td>返回容器元素最小值</td>
<td>字典只比较key</td>
</tr>
<tr>
<td>cmp(item1, item2)</td>
<td>比较两个值，<code>-1</code> 小于，<code>0</code> 等于，<code>1</code> 大于</td>
<td>python3取消了cmp</td>
</tr>
</tbody></table>
<ul>
<li>字符串比较遵循：<code>0</code> &lt;<code>A</code> &lt;<code>a</code> </li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][::<span class="number">2</span>]</span><br><span class="line">t1 = (<span class="string">"s"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">5</span>)[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 字典不能切片</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>演示</th>
<th>结果</th>
<th>描述</th>
<th>支持类型</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>[1, 2]+[3, 4]</td>
<td>[1, 2, 3, 4]</td>
<td>合并</td>
<td>字符串，列表，元组</td>
</tr>
<tr>
<td>*</td>
<td>(“hi”)*3</td>
<td>(“hi”,”hi”,”hi”)</td>
<td>重复</td>
<td>同上</td>
</tr>
<tr>
<td>in</td>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>是否存在，字典判断key</td>
<td>字符串，列表，元组，字典</td>
</tr>
<tr>
<td>not in</td>
<td>4 not in (1, 2, 3)</td>
<td>True</td>
<td>是否不存在，字典判断key</td>
<td>同上</td>
</tr>
<tr>
<td><code>&lt;</code> <code>&gt;</code> 等</td>
<td>(1, 2, 3)&lt;(2, 3, 4)</td>
<td>True</td>
<td>比较</td>
<td>字符串，列表，元组</td>
</tr>
</tbody></table>
<blockquote>
<p><code>+</code> 与<code>entend()</code> 方法的区别：前者生成一个新的变量，后者追加到调用该方法的变量</p>
</blockquote>
<ul>
<li><p>append()与extend()区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2.append(<span class="number">4</span>)</span><br><span class="line">print(l2)</span><br><span class="line"><span class="comment"># 不能l2.extend(5)，extend()只能传入容器</span></span><br><span class="line">l2.append([<span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">print(l2)</span><br><span class="line">l2.extend([<span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>]]        <span class="comment"># 将append([6, 7])当成了一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>], <span class="number">8</span>, <span class="number">9</span>]  <span class="comment"># 将extend([8, 9])追加</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="完整的for循环"><a href="#完整的for循环" class="headerlink" title="完整的for循环"></a>完整的for循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过<span class="keyword">break</span>退出循环，遍历结束后就会执行</span><br></pre></td></tr></table></figure>

<ul>
<li>应用<br>遍历完成后，如果没有查询的就提示</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>对变量使用自身的方法进行增删改不会改变id，而重新赋值会改变，这时它的指针指向了另一个地址</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python的一些基础知识</title>
    <url>/2019/09/03/python%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="python的运算符"><a href="#python的运算符" class="headerlink" title="python的运算符"></a>python的运算符</h2><a id="more"></a>

<blockquote>
<p>与C,java等不同</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加</td>
<td>10 + 20 = 30</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
<td>10 - 20 = -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
<td>10 * 20 = 200</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除</td>
<td>10 / 20 = 0.5</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">取整除</td>
<td>返回除法的整数部分（商） 9 // 2 输出结果 4</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余数</td>
<td>返回除法的余数 9 % 2 = 1</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">幂</td>
<td>又称次方、乘方，2 ** 3 = 8</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">与</td>
<td>a &gt;= 1 and a &lt;= 4</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">或</td>
<td>a &gt; 1 or a &lt; 10</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">非</td>
<td>not a &lt; 1</td>
</tr>
<tr>
<td align="center"><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code></td>
<td align="center">赋值运算</td>
<td>a+=1等同于a=a+1</td>
</tr>
</tbody></table>
<h2 id="查看关键字"><a href="#查看关键字" class="headerlink" title="查看关键字"></a>查看关键字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a==<span class="number">1</span>:</span><br><span class="line">    print(<span class="string">"aaa"</span>)</span><br><span class="line"><span class="keyword">elif</span> a==<span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"bbb"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"ccc"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>if</code>后面可以接<strong>布尔运算，数字，字符串，列表，元组，字典等</strong>，为真的条件是这些元素<strong>为True，非0，非None</strong></p>
</blockquote>
<ul>
<li>条件分行<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用()将条件括起来，在布尔运算符前可分行</span></span><br><span class="line"><span class="keyword">if</span>((a == <span class="number">1</span> <span class="keyword">and</span> b == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">or</span> (a ==<span class="number">2</span> <span class="keyword">and</span> b ==<span class="number">3</span>)):</span><br><span class="line">    print(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    执行代码</span><br></pre></td></tr></table></figure>

<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义的函数要在使用前声明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">(param1,param2)</span>:</span></span><br><span class="line">    封装代码</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数下方缩进后使用连续的三个'或“可以给函数编辑注释</span></span><br><span class="line"><span class="comment"># 如果此时直接按回车会生成带参数描述的文档注释</span></span><br><span class="line"><span class="comment"># 并且之后调用时可以使用Ctrl+Q快速查看</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''this is a test example'''</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># TODO(作者/邮件) 这是TODO注释，提醒接下来要做的工作，可以在pycharm左下角找到所有TODO项</span></span><br></pre></td></tr></table></figure>

<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><ul>
<li><p>数字和字符串输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line">print(<span class="string">"you are %d"</span> % age)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个数字和字符串输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br><span class="line">num3 = <span class="number">10.5</span></span><br><span class="line">print(<span class="string">"the number is %d , %d and %f"</span> % (num1,num2,num3))    <span class="comment">#实际上这是元组的应用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>%d是以十进制输出，可用%x以十六进制输出</p>
</blockquote>
<ul>
<li><p>使print不换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print()方法默认是在尾部添加了换行符，而如果不想换行可以加,end=""</span></span><br><span class="line">print(<span class="string">"hello"</span>,end=<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他使用</span></span><br><span class="line">print(<span class="string">"hellp"</span>,end=<span class="string">"***"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连续输出相同内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"*"</span> * <span class="number">50</span>)  <span class="comment">#连续输出50个*</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input(<span class="string">"请输入："</span>)</span><br></pre></td></tr></table></figure>

<p>控制台输入的内容是字符串，如果需要用于判断，则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = int(input(<span class="string">"请输入"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randint(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">#生成10-20间的随机整数</span></span><br></pre></td></tr></table></figure>

<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><ul>
<li>使用<code>import</code>关键字导入模块，所有以<code>.py</code>结尾的文件都可以看作一个模块</li>
<li>模块不能使用<strong>数字</strong>开头</li>
</ul>
<h3 id="pyc文件"><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h3><ul>
<li>当使用import导入模块并编译后，会在编译文件夹中生成<code>.pyc</code>文件，这是使用<code>cpython</code>编译出的二进制文件，使得每次使用模块不需要反复解释，以提高执行性能</li>
</ul>
<h2 id="跳过"><a href="#跳过" class="headerlink" title="跳过"></a>跳过</h2><ul>
<li>如果写了判断或其他情况暂时不写某些代码时，可以使用<code>pass</code> 充当占位符，使编译器不报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]</span><br><span class="line">num = input(<span class="string">"please input:"</span>)</span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="shebang符号"><a href="#shebang符号" class="headerlink" title="shebang符号"></a>shebang符号</h2><ul>
<li><code>#!</code> 是shebang符号，他后面加上解释器的路径即可在终端下通过输入文件地址而直接运行，且不影响在pycharm中运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /usr/bin/python3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><ul>
<li>id(变量/数据)   查看其内存地址</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年--在武大智能车</title>
    <url>/2019/09/01/%E8%BF%99%E4%B8%80%E5%B9%B4-%E5%9C%A8%E6%AD%A6%E5%A4%A7%E6%99%BA%E8%83%BD%E8%BD%A6/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><h2 id="此刻"><a href="#此刻" class="headerlink" title="此刻"></a>此刻</h2></blockquote>

<a id="more"></a>

<p>  坐在电脑前，也许应该点燃<strong>一支烟</strong>，吸一口，神清气爽，<strong>念天地之悠悠</strong>，吐一口，烟云缭绕，<strong>独怆然而涕下</strong>。于烟云之端，闭上双眼，追古溯今，回味这身于其中恨其长，蓦然回首已惘然的一年。</p>
<p>  可是，我不会抽烟。</p>
<p>  所以，我不能在烟云中幻想，只能在现实中回望。</p>
<p>  回忆起来，尽管最终结果平平，但它仍旧不同以往，给大学生活添上了不寻常的一笔。</p>
<blockquote class="blockquote-center"><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2></blockquote> 

<p>  冬天的枝叶败落后，又在春天绿意盎然，如是想想，我也应该走出决赛失利的阴霾中，好好记录下这一年的高兴与惆怅，开怀与彷徨。</p>
<p>  从大一的那个暑假走来，转眼一年多过去了，校内赛前能装实验室汗流夹背的景象回想起来，仿佛就在昨天，那个时候想必是这一年最难熬的吧。周围都是陌生的面孔，大家都为了入队而不断学习。两个月的时间里，很多人坚持不下去走了，但更多的坚持了下来，走过11月的校内赛，成功进入智能车这个大家庭。</p>
<p>  那段时间应当感谢与我同行的两个同学，<strong>赵富强</strong>和<strong>雷飞</strong>，不如就合称<strong>赵雷</strong>吧，哈哈，感谢“赵雷“的陪伴，和赵雷的歌曲，陪我一步一步迈过那两个月的时光。</p>
<blockquote class="blockquote-center"><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2></blockquote> 

<p>  校内赛后，我选择了节能组，并负责软件部分，但由于组别的特殊性，我们组所有人都负责结构设计，华南赛前我花在结构设计上的时间甚至多于调试程序的时间。</p>
<p>  也许那个时候方向真是错了，也因此，每次开会，我们组都是被点名的那个。</p>
<p>  前后花了几个月，多方咨询，多次改稿，最终还真的设计出了一款机械能的车模。</p>
<p><img src="car3.png" alt="机械能车模"> </p>
<p>  然而，由于零件难以找到合适的，且直观感觉它并不会节省能量，最终在四月份刚拼起来就被舍弃，前功尽弃–想想有些可惜。</p>
<p>  这样，我们开始专心搭纯电履带车，我专心负责程序编写。</p>
<p>  之前只是大概写了个框架，没有几个月就要比赛了，那时候我有些慌了，尤其是在圆环的处理上，由于车身晃动太大和程序鲁棒性太差，总是出现各种问题，要不识别不到，要不识别过早，或者进去出不来，总之，问题百出。</p>
<p>  即使是华南赛就要来临，即使我们天天熬夜，但成功率仍旧不高，那个时候甚至一度怀疑是否能挺过华南赛，是不是拿个华二就结束了…</p>
<p>  然而，我也不敢大改程序，怕这一改便成仁了…</p>
<blockquote class="blockquote-center"><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2></blockquote> 

<p>  七月，空气中弥漫着潮湿的味道，智能车队整装出发。我们组内调侃：去旅个游就放假啦，好开心。</p>
<p>  不过我心里其实还存有一丝侥幸，10多分钟，总能成功的吧。</p>
<p>  试车：路障过不去，有些慌了</p>
<p>  预赛：电感坏了，心想凉了，还好临时修好，一次成功</p>
<p>  决赛：一次成功</p>
<p>  结果如我所愿，成功狗过华南赛，还拿了个第二名的成绩，但可以看出来，不论结构和程序都很不稳定。</p>
<ul>
<li><p>华南赛后合照<br><img src="car6.jpg" alt="合照">  <img src="car1.jpg" alt="合照"> </p>
<p>那几天的长沙天气不错，我们三五成群，晚上就出去逛街，喝过了网红饮品<strong>茶颜悦色</strong>，吃过了毛主席都爱吃的<strong>长沙臭豆腐</strong>，也算不虚此行。</p>
</li>
<li><p>和帅哥<em>茶颜悦色</em>打卡<br><img src="car11.jpg" alt="打卡"> </p>
<p>哦，对了，张老师摔得那下有点惨0.0当时都吓到我们了</p>
</li>
</ul>
<blockquote class="blockquote-center"><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2></blockquote> 

<p>  华南赛回来后，我决定重写程序，花了差不多十天左右的时间写完，调试。改完之后感觉良好，比之前的稳定很多，速度也从1.5提高到了1.68左右，用电池跑的时候，经常可以一次性跑五六圈都没有问题。</p>
<p>  但是不知道为什么，每辆车刚搭出来表现不错，越跑就越变的不尽如人意了，只能降低速度，但我想这不应该是程序的问题，试了试其他样式的履带，结果一般，最终没有改动车体结构，也没有去深究这个问题。</p>
<p>  剩下的二十天我调车的时间就下降了，和队里大部分人一样开始了<strong>养老生活</strong>。</p>
<p>  转眼间，就从珞珈山下踏到了渤海之边。</p>
<blockquote class="blockquote-center"><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2></blockquote> 

<p>  我们走过了沙滩，趟过了海浪，挖过了拖鞋，埋过了雷飞…然而我只想问：海边为什么都是中年油腻大爷大妈，和我想象的不太一样啊…</p>
<ul>
<li>我们在海滩</li>
</ul>
<p><img src="car8.jpeg" alt="沙滩"><br><img src="car9.jpeg" alt="沙滩"> </p>
<blockquote>
<p>快乐的玩耍</p>
</blockquote>
<p><img src="car10.jpeg" alt="快乐"></p>
<p>  比赛时，唉不想说了，一上场就发现和在实验室的差异了，实验室赛道较光滑，而威海的赛道摩擦力太大，以至于每次转弯车都要跳两下，出环岛时也不像在实验室那样顺滑，我在旁边胆战心惊。</p>
<p>  而预赛的下午场和决赛，又出现了莫名其妙的问题，好几次在直道弯道处就撞上路障夭折了…这种情况在实验室从未出现过，还有一次刚到路障直接停车了，不明所以，事后我们组觉得可能是车硬件有问题，但那块板子自从按上以后我每天只是稍微跑跑，所以没有暴露出来，而当在国赛时显露出来，也来不及补救了。</p>
<p>  于是最终拖了十四届的后腿，成为了唯一一个二等奖项。</p>
<p>  <strong>嘤嘤嘤</strong> …</p>
<blockquote class="blockquote-center"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></blockquote> 

<p>  这一年无论结果如何，也伴着专老师的点拨，张老师的关怀，杨老师的鸡汤和整个车队的陪伴走过去了。这一年终将永久存留于每位十四届智能车队员的心中，并在未来珍藏，回味，历久弥新…</p>
<p><img src="car2.jpg" alt="合影"> </p>
<p>  最后，盛年不重来，我们<strong>J</strong><del>in</del><strong>M</strong><del>a</del><strong>M</strong><del>en</del>见吧！(滑稽)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2019/08/30/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><a id="more"></a>

<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">...</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<ul>
<li>n#+文字 n级标题</li>
</ul>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">*斜体*</span><br><span class="line">==高亮==</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br><span class="line">^上标^</span><br><span class="line">~下标~</span><br></pre></td></tr></table></figure>

<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序标题"><a href="#无序标题" class="headerlink" title="无序标题"></a>无序标题</h3><ul>
<li>使用”*”或者”+”后面跟空格，按一下回车会自动加标题，按两下会消失<blockquote>
<p>eg：</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- 一二三四五</span><br><span class="line">- 上山打老虎</span><br><span class="line">  - 下一级为空心圆</span><br><span class="line">    - 再下一级是实心方块</span><br><span class="line">      - 之后都是实心方块</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ul>
<li>一二三四五</li>
<li>上山打老虎<ul>
<li>下一级为空心圆<ul>
<li>再下一级是实心方块<ul>
<li>之后都是实心方块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序标题"><a href="#有序标题" class="headerlink" title="有序标题"></a>有序标题</h3><p>与word类似</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 一级</span><br><span class="line"><span class="number">2.</span> 二级</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ol>
<li>一级</li>
<li>二级</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>第二行要有连字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">| 姓名 | 学号 | 专业 | 班级 |</span><br><span class="line">|------|------|------|------|</span><br><span class="line">| 张三 | <span class="number">037</span>  | 机械 | 四班 |</span><br></pre></td></tr></table></figure>

<p>效果</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>专业</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>037</td>
<td>机械</td>
<td>四班</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; 大于号加引用内容</span><br><span class="line">&gt;&gt; 二级引用，可多级</span><br></pre></td></tr></table></figure>

<p>效果</p>
<blockquote>
<p>大于号加引用内容</p>
<blockquote>
<p>二级引用，可多级</p>
</blockquote>
</blockquote>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用连字符，上一行不能有字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  上文</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">  下文</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>  上文</p>
<hr>
<p>  下文</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><p>使用``将代码括起来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`print(<span class="string">"hello"</span>) `</span><br></pre></td></tr></table></figure>

<h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;http://www.baidu.com&gt;</span><br><span class="line">2. [百度](http://www.baidu.com)</span><br><span class="line">3. 我经常用[百度][1]搜索，很少用[必应][2]</span><br><span class="line"></span><br><span class="line">[1]:http://www.baidu.com/ &quot;Baidu&quot;</span><br><span class="line">[2]:http://www.bing.com/ &quot;Bing&quot;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<ol>
<li><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></li>
<li><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></li>
<li>我经常用<a href="http://www.baidu.com/" title="Baidu" target="_blank" rel="noopener">百度</a>搜索，很少用<a href="http://www.bing.com/" title="Bing" target="_blank" rel="noopener">必应</a></li>
</ol>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![狮子](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&amp;fm=26&amp;gp=0.jpg &quot;this is a lion&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&fm=26&gp=0.jpg" alt="狮子" title="this is a lion"></p>
<h2 id="百度地图"><a href="#百度地图" class="headerlink" title="百度地图"></a>百度地图</h2><blockquote>
<p>网址<a href="http://api.map.baidu.com/lbsapi/creatmap/index.html" target="_blank" rel="noopener">http://api.map.baidu.com/lbsapi/creatmap/index.html</a></p>
</blockquote>
<p>注意要在html文件中加<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>限定编码格式，否则<strong>可能乱码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;~/Markdown/map.html&quot; width=&quot;600&quot; height=&quot;300&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta name="generator" content="Hexo 3.9.0">
<meta charset="UTF-8">
<!--<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta name="keywords" content="百度地图,百度地图API，百度地图自定义工具，百度地图所见即所得工具" />
<meta name="description" content="百度地图API自定义地图，帮助用户在可视化操作下生成百度地图" />
<title>百度地图API自定义地图</title>-->
<!--引用百度地图API-->
<style type="text/css">
    html,body{margin:0;padding:0;}
    .iw_poi_title {color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap}
    .iw_poi_content {font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word}
</style>
<script type="text/javascript" src="http://api.map.baidu.com/api?key=&v=1.1&services=true"></script>
</head>

<body>
  <!--百度地图容器-->
  <div style="width:697px;height:550px;border:#ccc solid 1px;" id="dituContent"></div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":175,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
<script type="text/javascript">
    //创建和初始化地图函数：
    function initMap(){
        createMap();//创建地图
        setMapEvent();//设置地图事件
        addMapControl();//向地图添加控件
        addMarker();//向地图中添加marker
        addPolyline();//向地图中添加线
        addRemark();//向地图中添加文字标注
    }
    
    //创建地图函数：
    function createMap(){
        var map = new BMap.Map("dituContent");//在百度地图容器中创建一个地图
        var point = new BMap.Point(114.368076,30.543335);//定义一个中心点坐标
        map.centerAndZoom(point,17);//设定地图的中心点和坐标并将地图显示在地图容器中
        window.map = map;//将map变量存储在全局
    }
    
    //地图事件设置函数：
    function setMapEvent(){
        map.enableDragging();//启用地图拖拽事件，默认启用(可不写)
        map.enableScrollWheelZoom();//启用地图滚轮放大缩小
        map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写)
        map.enableKeyboard();//启用键盘上下左右键移动地图
    }
    
    //地图控件添加函数：
    function addMapControl(){
        //向地图中添加缩放控件
	var ctrl_nav = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE});
	map.addControl(ctrl_nav);
        //向地图中添加缩略图控件
	var ctrl_ove = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1});
	map.addControl(ctrl_ove);
        //向地图中添加比例尺控件
	var ctrl_sca = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT});
	map.addControl(ctrl_sca);
    }
    
    //标注点数组
    var markerArr = [{title:"终点",content:"come",point:"114.371444|30.545357",isOpen:1,icon:{w:21,h:21,l:46,t:46,x:1,lb:10}}
		 ];
    //创建marker
    function addMarker(){
        for(var i=0;i<markerArr.length;i++){
            var json = markerArr[i];
            var p0 = json.point.split("|")[0];
            var p1 = json.point.split("|")[1];
            var point = new BMap.Point(p0,p1);
			var iconImg = createIcon(json.icon);
            var marker = new BMap.Marker(point,{icon:iconImg});
			var iw = createInfoWindow(i);
			var label = new BMap.Label(json.title,{"offset":new BMap.Size(json.icon.lb-json.icon.x+10,-20)});
			marker.setLabel(label);
            map.addOverlay(marker);
            label.setStyle({
                        borderColor:"#808080",
                        color:"#333",
                        cursor:"pointer"
            });
			
			(function(){
				var index = i;
				var _iw = createInfoWindow(i);
				var _marker = marker;
				_marker.addEventListener("click",function(){
				    this.openInfoWindow(_iw);
			    });
			    _iw.addEventListener("open",function(){
				    _marker.getLabel().hide();
			    })
			    _iw.addEventListener("close",function(){
				    _marker.getLabel().show();
			    })
				label.addEventListener("click",function(){
				    _marker.openInfoWindow(_iw);
			    })
				if(!!json.isOpen){
					label.hide();
					_marker.openInfoWindow(_iw);
				}
			})()
        }
    }
    //创建InfoWindow
    function createInfoWindow(i){
        var json = markerArr[i];
        var iw = new BMap.InfoWindow("<b class='iw_poi_title' title='" + json.title + "'>" + json.title + "</b><div class='iw_poi_content'>"+json.content+"</div>");
        return iw;
    }
    //创建一个Icon
    function createIcon(json){
        var icon = new BMap.Icon("http://app.baidu.com/map/images/us_mk_icon.png", new BMap.Size(json.w,json.h),{imageOffset: new BMap.Size(-json.l,-json.t),infoWindowOffset:new BMap.Size(json.lb+5,1),offset:new BMap.Size(json.x,json.h)})
        return icon;
    }
//标注线数组
    var plPoints = [{style:"solid",weight:4,color:"#f00",opacity:0.6,points:["114.365318|30.5401","114.366755|30.542324","114.367797|30.543568","114.369648|30.544564","114.371426|30.545326"]}
		 ];
    //向地图中添加线函数
    function addPolyline(){
		for(var i=0;i<plPoints.length;i++){
			var json = plPoints[i];
			var points = [];
			for(var j=0;j<json.points.length;j++){
				var p1 = json.points[j].split("|")[0];
				var p2 = json.points[j].split("|")[1];
				points.push(new BMap.Point(p1,p2));
			}
			var line = new BMap.Polyline(points,{strokeStyle:json.style,strokeWeight:json.weight,strokeColor:json.color,strokeOpacity:json.opacity});
			map.addOverlay(line);
		}
	}
//文字标注数组
    var lbPoints = [{point:"114.365031|30.540007",content:"起点"}
		 ];
    //向地图中添加文字标注函数
    function addRemark(){
        for(var i=0;i<lbPoints.length;i++){
            var json = lbPoints[i];
            var p1 = json.point.split("|")[0];
            var p2 = json.point.split("|")[1];
            var label = new BMap.Label("<div style='padding:2px;'>"+json.content+"</div>",{point:new BMap.Point(p1,p2),offset:new BMap.Size(3,-6)});
            map.addOverlay(label);
            label.setStyle({borderColor:"#999"});
        }
    }
    
    initMap();//创建和初始化地图
</script>
</html>

]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2019/08/30/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git版本创建"><a href="#git版本创建" class="headerlink" title="git版本创建"></a>git版本创建</h2><a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git init        <span class="comment">//初始化git仓库</span></span><br><span class="line">git add .       <span class="comment">//添加全部修改</span></span><br><span class="line">git add 文件名  <span class="comment">//添加指定文件的修改</span></span><br><span class="line">git commit -m <span class="string">"说明信息"</span>    <span class="comment">//提交并添加备注</span></span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>     <span class="comment">//查看版本信息</span></span><br></pre></td></tr></table></figure>

<p><img src="git_log.png" alt="git log"> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git status  <span class="comment">//查看修改信息</span></span><br></pre></td></tr></table></figure>

<p><img src="git_status.png" alt="gitstatus"> </p>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li><code>HEAD</code>指针会指向最新的版本</li>
<li><code>HEAD^</code>指向上一个版本</li>
<li><code>HEAD^^</code>指向上上个版本…</li>
<li>或者使用<code>HEAD~n</code>代表前n个版本</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^      <span class="comment">//回退到上一个版本</span></span><br><span class="line">git reset --hard HEAD~<span class="number">3</span>     <span class="comment">//回退到之前3个版本</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>git快速入门</title>
    <url>/2019/08/29/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li><code>git init</code><blockquote>
<p>将当前文件下变为git仓库</p>
</blockquote>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><code>git status</code></p>
<blockquote>
<p>查看git仓库的状态</p>
</blockquote>
</li>
<li><p><code>git add</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git add 文件  <span class="comment">#添加指定文件的修改</span></span><br><span class="line">git add .     <span class="comment">#添加所有文件的修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git diff</code> </p>
<blockquote>
<p>显示文件修改信息</p>
</blockquote>
</li>
<li><p><code>git reset</code></p>
<blockquote>
<p>退回追踪</p>
</blockquote>
</li>
<li><p><code>git config</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"zhangsan"</span>            <span class="comment">#配置用户名</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"example@qq.com"</span>     <span class="comment">#配置邮箱</span></span><br><span class="line">git config --<span class="keyword">global</span> core.editor vim                 <span class="comment">#配置默认编辑器</span></span><br><span class="line">git config credential.helper store                  <span class="comment">#在执行`push`前输入这段命令，会使git记住用户名和密码，之后就不用再输入</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git commit</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git commit                 <span class="comment">#会打开编辑器，可输入描述信息</span></span><br><span class="line">git commit -m <span class="string">"some text"</span>  <span class="comment">#提交更改并添加描述信息</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>让git忽略管理某些文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vim .gitignore   <span class="comment">#创建此文件，并在其中编辑要忽略的文件名即可</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>在该列表中添加的文件必须是从未被追踪过的，否则git将继续追踪该文件</p>
</blockquote>
<ul>
<li><p><code>git rm</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git rm --cached 文件    <span class="comment">#让git停止追踪该文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git branch          <span class="comment">#显示分支列表</span></span><br><span class="line">git branch test     <span class="comment">#创建一个名为test的分支</span></span><br><span class="line">git checkout test   <span class="comment">#切换到test分支</span></span><br><span class="line">git merge test      <span class="comment">#将test分支添加到master</span></span><br><span class="line">git branch -d test  <span class="comment">#删除test分支，未添加的分支不可删除</span></span><br><span class="line">git branch -D test  <span class="comment">#强制删除test分支</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推到github</p>
<blockquote>
<p>首先去github创建一个新的仓库，并复制链接，假设为<code>https://.../abc.git</code> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git remote add origin https://.../abc.git       <span class="comment">#告诉git你在网上的仓库位置</span></span><br><span class="line">git push --set-upstream origin master           <span class="comment">#将master提交到github（需要输入用户名和密码）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发送合作邀请</p>
<blockquote>
<p>在github的仓库中<code>setting</code>–&gt;<code>Collaborators</code>–&gt;搜索用户–&gt;点击发送邀请至邮箱</p>
</blockquote>
</li>
<li><p>复制文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://.../abc.git   <span class="comment">#复制仓库至本地，`.gitignore`中的文件不会被下载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git pull<br>将github上更改过的文件下载到本地</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>终端指令</title>
    <url>/2019/08/29/%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="some-tips"><a href="#some-tips" class="headerlink" title="some tips"></a>some tips</h2><ul>
<li><code>Tab</code> can auto compelete command</li>
<li><code>Ctrl+c</code> can stop the command or clear your input(终止命令或清空刚才的输入–命令较长时backspace太慢)</li>
</ul>
<a id="more"></a>

<h2 id="the-command-format"><a href="#the-command-format" class="headerlink" title="the command format"></a>the command format</h2><p><code>command [-options] [parameter]</code></p>
<h3 id="instructions"><a href="#instructions" class="headerlink" title="instructions"></a>instructions</h3><ul>
<li>command: command name</li>
<li>[-options]: control the command, it can be omited</li>
<li>[parameter]: maybe only one, or two, or three…</li>
<li>[]: means optional</li>
</ul>
<h2 id="basic-command"><a href="#basic-command" class="headerlink" title="basic command"></a>basic command</h2><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>list</td>
<td>view the contents of the current folder</td>
</tr>
<tr>
<td>pwd</td>
<td>print work directory</td>
<td>view current position</td>
</tr>
<tr>
<td>cd [directory]</td>
<td>change directory</td>
<td>move to the specified directory</td>
</tr>
<tr>
<td>touch [file name]</td>
<td>touch</td>
<td>create new file(s)</td>
</tr>
<tr>
<td>mkdir [directory]</td>
<td>make directory</td>
<td>create new directory</td>
</tr>
<tr>
<td>rm [file name]</td>
<td>remove</td>
<td>remove empty file(s)</td>
</tr>
<tr>
<td>clear</td>
<td>clear</td>
<td>clean the screen</td>
</tr>
</tbody></table>
<h2 id="view-help-information"><a href="#view-help-information" class="headerlink" title="view help information"></a>view help information</h2><ul>
<li><code>command --help</code></li>
<li><code>man command</code>(means manual)</li>
</ul>
<h2 id="files-and-directory-commands"><a href="#files-and-directory-commands" class="headerlink" title="files and directory commands"></a>files and directory commands</h2><ul>
<li>hidden files<blockquote>
<p>if the file begin with a dot <code>.</code> it is a hidden file</p>
</blockquote>
</li>
<li><code>.</code> and<code>..</code> <blockquote>
<p><code>.</code> means this level directory<br><code>..</code> means upper level directory</p>
</blockquote>
</li>
</ul>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><table>
<thead>
<tr>
<th>options</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>all</td>
<td>display all files(including hidden files)</td>
</tr>
<tr>
<td>-l</td>
<td>list</td>
<td>list display files (first letter is<code>d</code>:dir; <code>-</code>: file)</td>
</tr>
<tr>
<td>-h</td>
<td></td>
<td>display file size(Kb), it must be used with <code>-l</code> (ls -lh)</td>
</tr>
</tbody></table>
<ul>
<li><p>wildcard character(通配符)</p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>represents any number of characters(任意个数字符)</td>
</tr>
<tr>
<td>？</td>
<td>represents one character</td>
</tr>
<tr>
<td>[]</td>
<td>give some choices</td>
</tr>
</tbody></table>
</li>
<li><p>examples</p>
</li>
<li><ul>
<li><code>*</code> <blockquote>
<p><code>ls a*</code> display files begin with <code>a</code><br><code>ls *a.txt</code> display files end with <code>a.txt</code><br><code>ls *a*</code> display files contains <code>a</code> </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>** <code>?</code> </p>
<blockquote>
<p><code>ls ?a?.txt</code> display files like <code>1a1.txt</code> </p>
</blockquote>
<p>** <code>[]</code> </p>
<blockquote>
<p><code>ls [abcde]ab.txt</code> display files like <code>aab.txt</code> or<code>bab.txt</code> and so on<br><code>ls [a-f]ab.txt</code> display files begin with <code>abcdef</code> like <code>eab.txt</code></p>
</blockquote>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><ul>
<li><p>absolute path</p>
<blockquote>
<p>specific path from the root directory or home directory(从根目录或家目录开始的具体路径)<br>example:<code>/home/duguosheng/Desktop/</code> </p>
</blockquote>
</li>
<li><p>relative path</p>
<blockquote>
<p>the path from current directory</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>examples:<code>../Desktop/</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>go back to the current user home directory</td>
</tr>
<tr>
<td>cd ~</td>
<td>just like<code>cd</code></td>
</tr>
<tr>
<td>cd .</td>
<td>keep in the current directory</td>
</tr>
<tr>
<td>cd ..</td>
<td>go to the parent directory</td>
</tr>
<tr>
<td>cd -</td>
<td>switch back and forth between the last two directory</td>
</tr>
</tbody></table>
<h3 id="touch-file"><a href="#touch-file" class="headerlink" title="touch (file)"></a>touch (file)</h3><p>if the file doesn’t exist, the file will be created<br>otherwise, the last modification time of the file will be modified(否则会更改文件的末次修改时间)</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>create a new file</p>
<ul>
<li><code>mkdir -p a/b/c/d</code> <strong>recursively</strong> create directories(递归创建目录)<blockquote>
<p>the directory name can’t be same as <strong>existing file or directory</strong> </p>
</blockquote>
</li>
</ul>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul>
<li>delete file or directory (can not be restore)(不可恢复)</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>recursively delete directory(递归删除目录)</td>
</tr>
<tr>
<td>-f</td>
<td>forced deletion(强制删除)</td>
</tr>
</tbody></table>
<h2 id="copy-and-move-files-or-directories"><a href="#copy-and-move-files-or-directories" class="headerlink" title="copy and move files or directories"></a>copy and move files or directories</h2><h3 id="tree-directory"><a href="#tree-directory" class="headerlink" title="tree [directory]"></a>tree [directory]</h3><p>display directories and files in a tree view </p>
<ul>
<li><code>tree ~</code> display files form home directory</li>
<li><code>tree -d</code> only display directories</li>
</ul>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><ul>
<li><code>cp src dest</code> copy file<blockquote>
<p>example: <code>cp ~/Documents/test.txt .</code> copy test.txt to current directory,if you want to change file name, you can write<code>cp ~/a.txt ./b.txt</code> </p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>promat before overwritting files(覆盖文件前提示)</td>
</tr>
<tr>
<td>-r</td>
<td>copy directory</td>
</tr>
</tbody></table>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>move file or directory</p>
<p><strong>format</strong>: <code>mv src dest</code> </p>
<blockquote>
<p>example:<code>mv test ~/Documents/</code> move <em>test</em> to <em>Documents/</em> </p>
</blockquote>
<p><strong>change file or directory name</strong></p>
<blockquote>
<p>if <em>src</em> and <em>dest</em> are under the same directory, then it can be renamed</p>
</blockquote>
<p><strong>overwrite file</strong> </p>
<blockquote>
<p>if<code>test1.txt</code>and<code>test2</code>have been existed, then input <code>cp test1.txt test2.txt</code>, after that, <code>test1.txt</code> will be renamed as<code>test2.txt</code> and original file<code>test2.txt</code> will be deleted, <strong>this operation is unsafe</strong> </p>
</blockquote>
<p><code>cp -i src dest</code></p>
<blockquote>
<p>prompt before overwriting files</p>
</blockquote>
<h2 id="view-file-content"><a href="#view-file-content" class="headerlink" title="view file content"></a>view file content</h2><h3 id="cat-concatenate连接合并"><a href="#cat-concatenate连接合并" class="headerlink" title="cat(concatenate连接合并)"></a>cat(concatenate连接合并)</h3><p><strong>format</strong>: <code>cat (file)</code> </p>
<blockquote>
<p>view all content of the file </p>
</blockquote>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>show line number(except blank lines)</td>
</tr>
<tr>
<td>-n</td>
<td>show line number(including blank lines)</td>
</tr>
</tbody></table>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p><strong>format</strong>: <code>more (file)</code> </p>
<blockquote>
<p>view the beginning of the file</p>
</blockquote>
<table>
<thead>
<tr>
<th>operation</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td><space></space></td>
<td>display next page</td>
</tr>
<tr>
<td><enter></enter></td>
<td>display next row</td>
</tr>
<tr>
<td>b</td>
<td>go back</td>
</tr>
<tr>
<td>f</td>
<td>go forward</td>
</tr>
<tr>
<td>q</td>
<td>quit</td>
</tr>
</tbody></table>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>a text search tool(文本搜索工具)</p>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>show line number(行号)</td>
</tr>
<tr>
<td>-v</td>
<td>show lines which don’t match(不匹配的所有行)</td>
</tr>
<tr>
<td>-i</td>
<td>ignore case(忽略大小写)</td>
</tr>
</tbody></table>
<ul>
<li>example:<blockquote>
<p><code>grep as test.txt</code> look for the letter <strong>as</strong> in the <code>test.txt</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>grep -n as test.txt</code> look for the letter <strong>as</strong> in the <code>test.txt</code> and show the line number</p>
</blockquote>
<blockquote>
<p><code>grep -v as test.txt</code> look for lines that don’t contain the letter <strong>as</strong> in the <code>test.txt</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>param</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>^a</td>
<td>look for lines start with the letter <strong>a</strong></td>
</tr>
<tr>
<td>ke$</td>
<td>looke for lines end with <strong>ke</strong></td>
</tr>
</tbody></table>
<h2 id="other-command"><a href="#other-command" class="headerlink" title="other command"></a>other command</h2><h3 id="echo-some-words"><a href="#echo-some-words" class="headerlink" title="echo (some words)"></a>echo (some words)</h3><ul>
<li>the words will show in the terminal, it is always used with <strong>redirect command</strong></li>
<li><code>echo hello &gt; a</code> if <code>a</code> doesn’t exist, <code>a</code> will be created, and write <em>hello</em> inside file.(创建文件并指定内容)</li>
</ul>
<h3 id="redirect-gt-and-gt-gt"><a href="#redirect-gt-and-gt-gt" class="headerlink" title="redirect &gt;and&gt;&gt;"></a>redirect <code>&gt;</code>and<code>&gt;&gt;</code></h3><ul>
<li><p>linux allows to <strong>redirect command execution results to a file</strong>(linux允许将命令执行结果重定向到一个文件)</p>
</li>
<li><p><strong>output/append</strong> the content that should be displayed on the terminal to the specified file(将本应显示在终端的内容<strong>输出/追加</strong>到文件中)</p>
</li>
<li><p><code>&gt;</code>: output, overwrite the file</p>
</li>
<li><p><code>&gt;&gt;</code>: append, append content to the file</p>
</li>
<li><p>examples:</p>
<ul>
<li><code>echo helloworld &gt; a.txt</code></li>
<li><code>echo ls -lh &gt; a.txt</code> write the file list and their information to <code>a.txt</code> </li>
<li><code>echo goodbye &gt;&gt; a.txt</code></li>
</ul>
</li>
</ul>
<h3 id="pipe-管道"><a href="#pipe-管道" class="headerlink" title="pipe | (管道)"></a>pipe <code>|</code> (管道)</h3><ul>
<li><p>the output of a command can be input to another with pipe(一个命令的输出可以通过管道作为另一个命令的输入)</p>
</li>
<li><p><code>|</code> divides commands into left and right, left to write, right to read</p>
</li>
<li><p>common commands</p>
<ul>
<li><code>more</code>: spilt screen display content</li>
<li><code>grep</code>: search for the specified content in the command execution result(在命令执行结果中搜索指定内容)</li>
</ul>
</li>
<li><p>example:</p>
<ul>
<li><code>ls -lha ~ | more</code> spilt screen view files and directories</li>
<li><code>ls -lha ~ | grep aa</code> display files with letter <em>aa</em> in its name</li>
</ul>
</li>
</ul>
<hr>
<h2 id="shutdown-restart"><a href="#shutdown-restart" class="headerlink" title="shutdown/restart"></a>shutdown/restart</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><ul>
<li><code>shutdown</code> command can safely shut down or restart the system</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>restart</td>
</tr>
</tbody></table>
<blockquote>
<p>if the command has no options and parameters, it will turn off after 1 minute by default(默认一分钟后关机)<br>when remotely maintaining the serve, you’d better restart rather than shut down.</p>
</blockquote>
<ul>
<li>examples:<ul>
<li><code>shutdown -r now</code> –&gt;restart now</li>
<li><code>shut down now</code> –&gt;shut down now</li>
<li><code>shutdown 20:30</code> –&gt;shut down at 8:30pm</li>
<li><code>shutdown +10</code> –&gt;shut down 10 minutes later</li>
<li><code>shutdown -c</code> –&gt;cancel last command with shutdown</li>
</ul>
</li>
</ul>
<h2 id="view-and-configure-network-card-information-查看和配置网卡信息"><a href="#view-and-configure-network-card-information-查看和配置网卡信息" class="headerlink" title="view and configure network card information(查看和配置网卡信息)"></a>view and configure network card information(查看和配置网卡信息)</h2><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>configure a network interface</td>
<td>view/configure the network card information</td>
</tr>
<tr>
<td>ping (ip address)</td>
<td>ping</td>
<td>check the connection with target IP address is normal or not</td>
</tr>
</tbody></table>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul>
<li>in <strong>manjaro</strong>, use command <code>ip addr</code> instead of <code>ifconfig</code> </li>
<li>a computer may have <strong>a physical network card</strong> and <strong>multiple virtual network cards</strong> (一台计算机中可能有一个物理网卡和多个虚拟网卡)</li>
<li>view ip address: <code>ifconfig | grep inet</code> (<code>ip addr | grep inet</code> in mangaro )</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul>
<li><code>ping (IP)</code> ‘s working principle just like sonar(声纳), it sends out a packet, and the target IP addr returns a packet, the shorter the time, the faster the network speed(指令发出数据包，目标IP收到后返回一个数据包，这段时间越短，则网速越快)</li>
<li><code>ping (IP)</code> can check the target computer is open or not</li>
</ul>
<h2 id="Romote-login-and-copy-files-远程登录和复制文件"><a href="#Romote-login-and-copy-files-远程登录和复制文件" class="headerlink" title="Romote login and copy files(远程登录和复制文件)"></a>Romote login and copy files(远程登录和复制文件)</h2><h3 id="Basics-of-SSH"><a href="#Basics-of-SSH" class="headerlink" title="Basics of SSH"></a>Basics of <strong><em>SSH</em></strong></h3><ul>
<li>Based on the <strong>SSH Client</strong> and <strong>SSH Serve</strong> </li>
<li><strong>SSH Client</strong> is a software program connected to a remote computer with protocol <code>Secure Shell(SSH)</code> (SSH客户端是一种使用SSH协议连接到远程计算机的软件程序)</li>
<li>Transmitted data is<ul>
<li><strong>Encrypted(加密)</strong> –Prevent information from being leaked</li>
<li><strong>Compressed(压缩)</strong> –Increase transmission speed</li>
</ul>
</li>
</ul>
<h3 id="Port-number-端口号-and-Domain-name-域名"><a href="#Port-number-端口号-and-Domain-name-域名" class="headerlink" title="Port number(端口号) and Domain name(域名)"></a>Port number(端口号) and Domain name(域名)</h3><ul>
<li>Port number:<ul>
<li>IP address: just like <code>172.168.12.13</code> use it can <strong>find computer</strong> on internet</li>
<li>Port number: can <strong>find application</strong> running on the computer<ul>
<li><strong>SSH Client</strong> default port number is <code>22</code>, if it’s default port number, you can omit the port number when connecting(默认端口号连接时可以省略)</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>services</th>
<th>port number</th>
</tr>
</thead>
<tbody><tr>
<td>SSH Serve</td>
<td>22</td>
</tr>
<tr>
<td>Web Serve</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>FTP Serve</td>
<td>21</td>
</tr>
</tbody></table>
<ul>
<li>Domain name: just like <strong><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> , it use aliases for easy memory(使用别名，方便记忆)</li>
</ul>
<center>
<img src="portNum1.png" height="100" width="800" alt="notFound" title="command ping">
</center>

<blockquote>
<p>As shown in figure, <code>www.baidu.com</code> is <code>180.97.33.107</code> aliases, if you type <code>180.97.33.107</code> in the browser, also can visit <code>Baidu</code> </p>
</blockquote>
<blockquote>
<p>Also, you can input <code>180.97.33.107:80</code> to visit <code>Baidu</code>, IP addr<code>180.97.33.107</code> to find the computer, and port number <code>80</code> to find its application program (web serve)</p>
</blockquote>
<h3 id="SSH-Serve"><a href="#SSH-Serve" class="headerlink" title="SSH Serve"></a>SSH Serve</h3><ul>
<li>format:<code>ssh [-p port] user@romote</code> <ul>
<li><code>user</code> default current user</li>
<li><code>romote</code> IP addr, Alias Or Domain name of remote computer</li>
<li><code>port</code> the port of <strong>SSH Serve</strong> to listen, default<code>22</code> </li>
</ul>
</li>
<li>exp: <code>ssh -p 22 duguosheng@172.16.140.138</code> </li>
</ul>
<blockquote>
<p>Tips:</p>
<ul>
<li><code>exit</code>: Log out of the current user(退出当前账户登录)</li>
<li>Linux and Mac can use SSH without doing anything, but in Windows, you have to install some software for free<ul>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">Putty</a></li>
<li><a href="http://xshellcn.com" target="_blank" rel="noopener">XShell</a></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li><p><code>scp</code> is <code>secure copy</code>, it be used to <strong>remote copy file</strong> </p>
</li>
<li><p>example:</p>
<ul>
<li><p>If the path after<code>:</code> isn’t an absolute path, the user’s home directory is used as the reference path(<code>:</code> 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径)</p>
<blockquote>
<p>copy <code>01.py</code> from your local current directory to<code>Desktop/01.py</code> in your remote home directory(把本地当前目录下的 01.py 文件复制到远程家目录下的 Desktop/01.py)</p>
<blockquote>
<p><code>scp -P port 01.py user@remote:Desktop/01.py</code> <strong>P is capital(大写)</strong> </p>
<blockquote>
<p><code>scp -P 22 01.py duguosheng@172.16.139.122:Desktop/</code> &lt;++&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>copy <code>Desktop/01.py</code> from remote home directory to <code>01.py</code> in local current directory</p>
<blockquote>
<p><code>scp -P port user@remote:Desktop/01.py 01.py</code> </p>
</blockquote>
</blockquote>
</li>
<li><p>use <code>-r</code> can copy directory</p>
<blockquote>
<p><code>demo</code> under current local dir <strong>–&gt;</strong> remote <code>Desktop/</code></p>
<blockquote>
<p><code>scp -r demo user@remote:Desktop</code> </p>
<blockquote>
<p><code>scp -P 22 -r demo duguosheng@212.134.23.123:Desktop/</code> </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p><code>Desktop</code> under remote home dir <strong>–&gt;</strong> <code>demo/</code> in local current dir</p>
<blockquote>
<p><code>scp -r user user@remote:Desktop demo</code> </p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p>Attention:</p>
<ul>
<li><code>scp</code> only can use in <code>linux</code> or <code>unix</code> </li>
<li>in <code>Windows</code>, you can install <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener">Putty</a>, use <code>pscp</code> <strong>OR</strong> install <a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">FileZilla</a>, use <code>FTP</code> <ul>
<li><code>FTP</code> use <code>Ftp</code> instead of <code>Ssh</code>, so its port number is <code>21</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SSH-advanced"><a href="#SSH-advanced" class="headerlink" title="SSH advanced"></a>SSH advanced</h3><blockquote>
<p>All SSH ci=onfiguration information is stroed in the <code>/home/user/.ssh</code></p>
</blockquote>
<h4 id="Password-free-login-免密码登录"><a href="#Password-free-login-免密码登录" class="headerlink" title="Password free login(免密码登录)"></a>Password free login(免密码登录)</h4><ul>
<li><p>Steps:</p>
<ul>
<li><p>Configure the public key(配置公钥)</p>
<blockquote>
<p>Execute <code>ssh-keygen</code> to generate a public key(生成公钥), you can see <code>id_rsa</code>(private key) and <code>id_rsa.pub</code>(public key) under <code>~/.ssh/</code></p>
</blockquote>
</li>
<li><p>upload public key to Serve</p>
<blockquote>
<p>Execute <code>ssh-copy-id -p port user@remote</code> can let the Serve remember our pulic key, in fact, this command copy <code>id_rsa.pub</code> to Serve’s <code>~/.ssh/</code> </p>
</blockquote>
<p><img src="ssh1.png" alt="原理"></p>
</li>
</ul>
</li>
<li><p>Asymmetric encryption algorithm(非对称加密算法)</p>
<ul>
<li>Data encrypted using the public key needs to be decrypted using the private key(使用公钥加密的数据，需要使用私钥解密)</li>
<li>Data encrypted using the private key needs to be decrypted using the public key(使用私钥加密的数据，需要使用公钥解密)</li>
</ul>
</li>
</ul>
<h4 id="Configure-an-alias"><a href="#Configure-an-alias" class="headerlink" title="Configure an alias"></a>Configure an alias</h4><ul>
<li>Steps:<ul>
<li><code>cd ~/.ssh/</code> </li>
<li><code>touch config</code> </li>
<li><code>vi config</code> </li>
<li>edit <code>config</code> </li>
</ul>
</li>
<li>for example, <code>ssh -p 22 example@100.100.100.100</code> can be changed to <code>ssh exp</code> by edit <code>config</code> like this<br><img src="ssh3.png" alt="config"></li>
<li>Also, you can use <code>scp -r ~/Desktop exp:Desktop/demo</code> to copy a directory</li>
</ul>
<h2 id="Commands-about-User-Premissions-用户权限"><a href="#Commands-about-User-Premissions-用户权限" class="headerlink" title="Commands about User Premissions(用户权限)"></a>Commands about User Premissions(用户权限)</h2><h3 id="User-and-Premission"><a href="#User-and-Premission" class="headerlink" title="User and Premission"></a><strong><em>User</em></strong> and <strong><em>Premission</em></strong></h3><ul>
<li>In Linux, you can specify different permissions for different <strong>files or directories</strong> for each user</li>
<li>the permissions contains:</li>
</ul>
<table>
<thead>
<tr>
<th>permission</th>
<th>abbreviation</th>
<th>number</th>
</tr>
</thead>
<tbody><tr>
<td>read</td>
<td>r</td>
<td>4</td>
</tr>
<tr>
<td>write</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>executive</td>
<td>x</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="ls-l-extended"><a href="#ls-l-extended" class="headerlink" title="ls -l extended"></a><code>ls -l</code> extended</h3><ul>
<li>execute <code>ls -lh</code> get some infomation like this<br><img src="user1.png" alt="result"> </li>
</ul>
<table>
<thead>
<tr>
<th><code>d</code>or<code>-</code></th>
<th>rwx</th>
<th>r-x</th>
<th>r–</th>
<th>2</th>
<th>duguosheng</th>
<th>duguosheng</th>
<th>4.0K</th>
<th>Aug 2 23:04</th>
<th>桌面/</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code> directory <code>-</code> file</td>
<td>user permission</td>
<td>group permission</td>
<td>other people permission</td>
<td>Number of hard links</td>
<td>user name</td>
<td>group name</td>
<td>size</td>
<td>last version time</td>
<td>file or directory name</td>
</tr>
</tbody></table>
<ul>
<li>Number of hard links(硬链接数)<blockquote>
<p>how many ways to access the current directory/file</p>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>if it is a file, the number is 1, through the path</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>if it is a directory without subdirectories(没有子目录), the number is 2, through the path or<code>cd .</code> </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>if it is a directory with n subdirectories(有n个子目录), the number is 2+n, through the path, <code>cd .</code> or <code>cd ..</code> </p>
</blockquote>
</blockquote>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul>
<li><code>chmod</code> can change permission of user/group</li>
<li>format: <code>chmod +/- rwx fileName/dirName</code> this usage will permission of both change user and group</li>
</ul>
<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><ul>
<li><code>su</code> is <code>substitute user</code>, default is <code>root</code> </li>
</ul>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><ul>
<li>To facilitate user management, you can group users and then assign permissions to groups(分组，为组分配权限)</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>groupadd (name)</td>
<td>add a group</td>
</tr>
<tr>
<td>groupdel (name)</td>
<td>delete a group</td>
</tr>
<tr>
<td>cat /etc/group</td>
<td>view group</td>
</tr>
<tr>
<td>chgrp -R (group_name) (dir)</td>
<td>change the group to which the dir belongs</td>
</tr>
</tbody></table>
<h3 id="User-management"><a href="#User-management" class="headerlink" title="User management"></a>User management</h3><h4 id="create-delete-user-And-change-password"><a href="#create-delete-user-And-change-password" class="headerlink" title="create/delete user And change password"></a>create/delete user And change password</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>tips</th>
</tr>
</thead>
<tbody><tr>
<td>useraddd -m -g (groupName) (userName)</td>
<td>add a user</td>
<td><code>-m</code> auto create home directory, <code>-g</code> specify user’s group, otherwise a group with the same name as the user will be created</td>
</tr>
<tr>
<td>passwd (user)</td>
<td>set user’s password</td>
<td>normal user can set set password by <code>passwd</code></td>
</tr>
<tr>
<td>userdel -r (user)</td>
<td>delete user</td>
<td><code>-r</code> will delete user’s home dir</td>
</tr>
</tbody></table>
<ul>
<li>if you foget to add <code>-m</code>, you can delete user and recreate it</li>
<li>the user information is stored in the <code>/etc/passwd</code> </li>
</ul>
<h4 id="view-user-information"><a href="#view-user-information" class="headerlink" title="view user information"></a>view user information</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>id (user)</td>
<td>view uid and gid</td>
</tr>
<tr>
<td>who</td>
<td>View a list of all currently logged in users(查看当前所有登录的用户列表)</td>
</tr>
<tr>
<td>whoami</td>
<td>view current user</td>
</tr>
</tbody></table>
<ul>
<li><code>id duguosheng</code> </li>
<li><code>cat -n /etc/passwd</code><br><img src="user2.png" alt="id"> </li>
<li><code>cat -n /etc/group</code> </li>
</ul>
<table>
<thead>
<tr>
<th>duguosheng</th>
<th>x</th>
<th>1000</th>
<th>1000</th>
<th>duguosheng</th>
<th>/home/duguosheng</th>
<th>/usr/bin/fish</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>encrypted password</td>
<td>user id</td>
<td>group id</td>
<td>group</td>
<td>home dir</td>
<td>shell</td>
</tr>
</tbody></table>
<h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><ul>
<li><code>usermod</code> can be used to set the user’s primary/additional group and login shell(设置主组/附加组，和登录shell)</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>usermod -g (group) (user)</td>
<td>change user’s primary group</td>
</tr>
<tr>
<td>usermod -G (group) (user)</td>
<td>change user’s additional group</td>
</tr>
<tr>
<td>usermod -s /bin/bash (user)</td>
<td>change user’s shell</td>
</tr>
</tbody></table>
<ul>
<li>Users added by default with <code>useradd</code> do not have permission to use <strong>sudo</strong> to execute commands as <strong>root</strong>. Users can be added to sudo additional groups by using the following commands(默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中)<br><code>usermod -G sudo (user)</code> </li>
</ul>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p><code>which (command)</code> see the path of command</p>
<ul>
<li><code>which ls</code> <blockquote>
<p>result: <code>/bin/ls</code></p>
</blockquote>
</li>
<li><code>bin</code> and <code>sbin</code> </li>
</ul>
<p><img src="user4.png" alt="command_dir"> </p>
<h4 id="change-user"><a href="#change-user" class="headerlink" title="change user"></a>change user</h4><table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>su</td>
<td>change to root(not safe)</td>
</tr>
<tr>
<td>su (user)</td>
<td>change user</td>
</tr>
<tr>
<td>su - (user)</td>
<td>change user and go his home dir</td>
</tr>
<tr>
<td>exit</td>
<td>log out</td>
</tr>
</tbody></table>
<ul>
<li><p>Modify File Permissions(修改文件权限)</p>
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>chown (user) (file/dir)</td>
<td>change ower</td>
</tr>
<tr>
<td>chgrp -R (user) (file/dir)</td>
<td>change group</td>
</tr>
<tr>
<td>chmod -R 755 (file/dir)</td>
<td>change permission</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="user5.png" alt="permission"> </p>
<h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>view system time</td>
</tr>
<tr>
<td>cal</td>
<td>view calendar</td>
</tr>
<tr>
<td>cal -y</td>
<td>view calendar of a year</td>
</tr>
</tbody></table>
<h3 id="disk-information-磁盘信息"><a href="#disk-information-磁盘信息" class="headerlink" title="disk information(磁盘信息)"></a>disk information(磁盘信息)</h3><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>df -h</td>
<td>disk free</td>
<td>show free space of disk(剩余空间)</td>
</tr>
<tr>
<td>du -h [dir]</td>
<td>disk usage</td>
<td>display the file size in the dir(目录下的文件大小)</td>
</tr>
</tbody></table>
<h3 id="process-information-进程信息"><a href="#process-information-进程信息" class="headerlink" title="process information(进程信息)"></a>process information(进程信息)</h3><table>
<thead>
<tr>
<th>command</th>
<th>word</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>ps (aux)</td>
<td>process status</td>
<td>view process</td>
</tr>
<tr>
<td>top</td>
<td></td>
<td>Display running processes dynamically and sort them(动态显示运行中的进程并且排序)</td>
</tr>
<tr>
<td>kill [-9] (process)</td>
<td></td>
<td><code>process</code> can be a name or its pid, stop the process, <code>-9</code> :force to stop</td>
</tr>
</tbody></table>
<ul>
<li>option of <code>ps</code> <ul>
<li><code>a</code> :Display all processes on the terminal, including those of other users(显示终端上的所有进程，包括其他用户的进程)</li>
<li><code>u</code> :display details of process</li>
<li><code>x</code> :Display processes without control terminals(显示没有控制终端的进程)</li>
</ul>
</li>
</ul>
<h2 id="Other-command"><a href="#Other-command" class="headerlink" title="Other command"></a>Other command</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li>format: <code>find [path] -name &quot;*.png&quot;</code> <blockquote>
<p>if no path, default in current directory</p>
</blockquote>
</li>
</ul>
<h3 id="Softlink-软链接"><a href="#Softlink-软链接" class="headerlink" title="Softlink(软链接)"></a>Softlink(软链接)</h3><ul>
<li>format: <code>ln -s src destfile</code> use absolute path, don’t use relative path</li>
</ul>
<h3 id="Hardlink-硬链接"><a href="#Hardlink-硬链接" class="headerlink" title="Hardlink(硬链接)"></a>Hardlink(硬链接)</h3><ul>
<li>format: <code>ln src destfile</code><br><img src="user6.png" alt="hardlink"> </li>
</ul>
<h3 id="Packing-and-Compression-打包压缩"><a href="#Packing-and-Compression-打包压缩" class="headerlink" title="Packing and Compression(打包压缩)"></a>Packing and Compression(打包压缩)</h3><h4 id="Pack-unpack-打包-解包"><a href="#Pack-unpack-打包-解包" class="headerlink" title="Pack/unpack(打包/解包)"></a>Pack/unpack(打包/解包)</h4><ul>
<li><p>different OS has different mode of pack and compression</p>
<ul>
<li><code>windows</code> : <code>rar</code> </li>
<li><code>mac</code> : <code>zip</code> </li>
<li><code>linux</code> : <code>tar</code>  </li>
</ul>
</li>
<li><p><code>tar</code> can pack a series of files into a large file or restore a packaged large file into a series of files(此命令可以把一系列文件打包到 一个大文件中，也可以把一个打包的大文件恢复成一系列文件)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>tar -cvf 打包文件.tar 被打包文件/路径…</td>
<td>pack</td>
</tr>
<tr>
<td>tar -xvf 打包文件.tar</td>
<td>unpack</td>
</tr>
</tbody></table>
<ul>
<li>options of tar</li>
</ul>
<table>
<thead>
<tr>
<th>option</th>
<th>func</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>生成档案文件，创建打包文件</td>
</tr>
<tr>
<td>x</td>
<td>解开档案文件</td>
</tr>
<tr>
<td>v</td>
<td>列出详细过程，显示进度</td>
</tr>
<tr>
<td>f</td>
<td>指定档案文件，f后面一定是.tar文件，所以必须放选项最后</td>
</tr>
</tbody></table>
<blockquote>
<p>attention: </p>
<blockquote>
<p><code>f</code> 必须放在选项最后，其他随意<br><code>tar</code> 只负责打包，不负责压缩</p>
</blockquote>
</blockquote>
<h4 id="compression-decompression-压缩-解压"><a href="#compression-decompression-压缩-解压" class="headerlink" title="compression/decompression(压缩/解压)"></a>compression/decompression(压缩/解压)</h4><h5 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h5><ul>
<li><code>tar</code> 与<code>gzip</code> 结合可实现打包压缩</li>
<li>用<code>gzip</code> 压缩<code>tar</code> 打包后的文件，扩展名一般用<code>xxx.tar.gz</code> </li>
<li>在<code>tar</code> 命令中，有一个<code>-z</code> 选项可以调用<code>gzip</code> </li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径,该指定路径必须已存在</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 指定路径</span><br></pre></td></tr></table></figure>

<h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><ul>
<li><code>tar</code> 与<code>bzip2</code> 结合可实现打包压缩</li>
<li>用<code>bzip2</code> 压缩<code>tar</code> 打包后的文件，扩展名一般用<code>xxx.tar.bz2</code> </li>
<li>在<code>tar</code> 命令中，有一个<code>-j</code> 选项可以调用<code>bzip2</code> </li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径,该指定路径必须已存在</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2 -C 指定路径</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>archlinux包管理工具pacman</title>
    <url>/2019/08/29/archlinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pacman/</url>
    <content><![CDATA[<p>pacman的基本命令分为三大类S,R,Q</p>
<a id="more"></a>

<h4 id="command-with-S-means-synchronized-lt-同步的-gt"><a href="#command-with-S-means-synchronized-lt-同步的-gt" class="headerlink" title="command with S (means synchronized&lt;同步的&gt;)"></a>command with <strong><code>S</code></strong> (means synchronized&lt;同步的&gt;)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -S (some apps)</td>
<td>install software</td>
<td>sudo pacman -S vlc</td>
</tr>
<tr>
<td>sudo pacman -Sy</td>
<td>only synchronize source(仅同步源)</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syy</td>
<td>force to refresh for updates(强制刷新一遍更新信息)</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Su</td>
<td>update the system</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syu</td>
<td>synchronize source and update</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Syyu</td>
<td>force to refresh imformation for updates and update system</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Ss (some apps)</td>
<td>search for the software from internet</td>
<td>sudo pacman -Ss vim</td>
</tr>
<tr>
<td>sudo pacman -Sc</td>
<td>delete software installation packages</td>
<td></td>
</tr>
</tbody></table>
<h4 id="command-with-R-means-remove"><a href="#command-with-R-means-remove" class="headerlink" title="command with R (means remove)"></a>command with <code>R</code> (means remove)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -R (app)</td>
<td>delete the software</td>
<td>sudo pacman -R vim</td>
</tr>
<tr>
<td>sudo pacman -Rs (app)</td>
<td>delete the software and the packages it rely on(删除软件及其依赖的包)</td>
<td>sudo pacman -Rs vim</td>
</tr>
<tr>
<td>*sudo pacman -Rns (app)</td>
<td>delete software, packages, and global profile</td>
<td>sudo pacman -Rns vim</td>
</tr>
</tbody></table>
<h4 id="command-with-Q-means-query-lt-查询-gt"><a href="#command-with-Q-means-query-lt-查询-gt" class="headerlink" title="command with Q (means query&lt;查询&gt;)"></a>command with <strong><code>Q</code></strong> (means query&lt;查询&gt;)</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -Q</td>
<td>list all softwares be installed</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qe</td>
<td>list the software have been installed by user</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Q &#124; wc -l</td>
<td>show total number of softwares</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qe &#124; wc -l</td>
<td>show number of personal softwares</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qeq</td>
<td>list pesonal softwares without version</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qs (app)</td>
<td>query the softwares which contains letters</td>
<td>sudo pacman -Qs vim</td>
</tr>
<tr>
<td>sudo pacman -Qdt</td>
<td>query unrequired packages</td>
<td></td>
</tr>
<tr>
<td>sudo pacman -Qdtq</td>
<td>query unrequired packages(不需要的包)</td>
<td></td>
</tr>
</tbody></table>
<h4 id="combination-commands"><a href="#combination-commands" class="headerlink" title="combination commands"></a>combination commands</h4><table>
<thead>
<tr>
<th>command</th>
<th>function</th>
<th>example</th>
</tr>
</thead>
<tbody><tr>
<td>sudo pacman -R $(pacman -Qdtq)</td>
<td>delete unrequired packages</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pacman</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>终端下文件管理器Ranger使用</title>
    <url>/2019/08/28/%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8Ranger%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="选择-打开文件"><a href="#选择-打开文件" class="headerlink" title="选择/打开文件"></a>选择/打开文件</h2><a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code>或<code>h</code></td>
<td>上一级</td>
</tr>
<tr>
<td><code>right</code>或<code>l</code></td>
<td>下一级/打开文件</td>
</tr>
<tr>
<td><code>up</code>或<code>k</code></td>
<td>上一个</td>
</tr>
<tr>
<td><code>down</code>或<code>j</code></td>
<td>下一个</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>最上方</td>
</tr>
<tr>
<td><code>G</code></td>
<td>最下方</td>
</tr>
<tr>
<td><code>r</code></td>
<td>选择打开方式</td>
</tr>
<tr>
<td><code>[</code></td>
<td>移动至上一个父文件夹</td>
</tr>
<tr>
<td><code>]</code></td>
<td>移动至下一个父文件夹</td>
</tr>
<tr>
<td><code>H</code></td>
<td>退回上一个位置</td>
</tr>
<tr>
<td><code>L</code></td>
<td>撤销退回</td>
</tr>
<tr>
<td><code>&lt;Space&gt;</code></td>
<td>选择该文件，可多选</td>
</tr>
<tr>
<td><code>v</code></td>
<td>反转选择</td>
</tr>
<tr>
<td><code>V</code></td>
<td>进入可视模式，结合移动键进行选择</td>
</tr>
</tbody></table>
<ul>
<li><p>打开文件默认使用<code>nano</code>或者<code>gedit</code>，如果想要修改，</p>
</li>
<li><p>查看默认编辑器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $EDITOR</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认编辑器(如改为vim)</p>
<blockquote>
<p>如果使用<code>bash</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export EDITOR="/usr/bin/vim"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用<code>fish</code> </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set -g -x EDITOR "/usr/bin/vim"</span><br></pre></td></tr></table></figure>

<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>y</code></td>
<td>按照提示选择复制的内容，如文件，文件路径等</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>复制一个文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>按照提示招贴</td>
</tr>
<tr>
<td><code>pp</code></td>
<td>复制刚才粘贴的，不覆盖</td>
</tr>
<tr>
<td><code>po</code></td>
<td>复制并覆盖重名文件</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>剪切</td>
</tr>
<tr>
<td><code>dD</code></td>
<td>删除</td>
</tr>
<tr>
<td><code>dU</code></td>
<td>查看文件大小</td>
</tr>
</tbody></table>
<ul>
<li>复制一个很大的文件进行粘贴时，可使用<code>w</code>进入<strong>进度管理</strong></li>
<li>在<strong>进度管理</strong>中，<code>dd</code>取消当前任务</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>/搜索内容</code></td>
<td>查找文件,<code>n</code>下一个,<code>N</code>上一个</td>
</tr>
<tr>
<td><code>f 搜索内容</code></td>
<td>查找文件，并直接指向该文件</td>
</tr>
<tr>
<td><code>zh</code> / <code>&lt;BackSpace&gt;</code> / <code>&lt;C-h&gt;</code></td>
<td>显示/隐藏隐藏文件</td>
</tr>
<tr>
<td><code>cw</code> / <code>a</code> / <code>i</code> / <code>A</code> / <code>I</code></td>
<td>重命名文件</td>
</tr>
<tr>
<td><code>o</code></td>
<td>按照提示选择排序方式</td>
</tr>
</tbody></table>
<h2 id="生成Ranger配置文件"><a href="#生成Ranger配置文件" class="headerlink" title="生成Ranger配置文件"></a>生成Ranger配置文件</h2><ul>
<li>在终端下执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ranger --copy-config=all</span><br></pre></td></tr></table></figure>

<p>就会在<code>.config/ranger/</code>下看到相关配置文件，更多配置信息可以去<a href="https://github.com/ranger/ranger/wiki" target="_blank" rel="noopener">ranger的github下的wiki栏目</a>下查看</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
</search>
