<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迭代器与生成器]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器 迭代是访问集合元素的一种方式，迭代器是一种可以记住遍历的位置的对象，从集合的第一个元素开始访问知道所有的元素访问完结束 查看是否可以迭代 可迭代的对象可以使用isinstance验证与Iterable的关系，返回True则可以迭代 迭代器可以使用isinstance验证与Iterator的关系，返回True则可以迭代12from collections import Iterableprint(isinstance([11, 22], Iterable)) 定义可以迭代的类 如果想让创建的对象可以迭代，必须实现__iter__()方法，且需要返回一个迭代器 返回的迭代器也是一个对象，这个对象要包含__iter__()方法和__next__()，方法，其中__next__()方法的返回值就是迭代的内容 可以重新写一个迭代器的类，用于返回值可以直接返回self，并在本类中实现__next__() 两个类实现迭代 123456789101112131415161718192021222324252627282930313233343536class my_iter(): def __init__(self): self.names = list() def my_iterator(self, name): self.names.append(name) def __iter__(self): # 返回一个迭代器对象 return my_itor(self)class my_itor(): def __init__(self, obj): self.obj = obj self.current_num = 0 def __iter__(self): pass def __next__(self): if self.current_num &lt; len(self.obj.names): ret = self.obj.names[self.current_num] self.current_num += 1 return ret else: # 超过容量抛出StopIteration来终止迭代 raise StopIterationmy_iterator = my_iter()my_iterator.my_iterator("张三")my_iterator.my_iterator("李四")my_iterator.my_iterator("王五")for temp in my_iterator: print(temp) 运行结果 123张三李四王五 实现了迭代功能 一个类实现迭代12345678910111213141516171819202122232425262728class my_iter(): def __init__(self): self.names = list() self.current_num = 0 def my_iterator(self, name): self.names.append(name) def __iter__(self): # 返回自身,会自动调用__next__()方法 return self def __next__(self): if self.current_num &lt; len(self.names): ret = self.names[self.current_num] self.current_num += 1 return ret else: # 超过容量抛出StopIteration来终止迭代 raise StopIterationmy_iterator = my_iter()my_iterator.my_iterator("张三")my_iterator.my_iterator("李四")my_iterator.my_iterator("王五")for temp in my_iterator: print(temp) 运行结果 123张三李四王五 也实现了迭代功能]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多任务——协程]]></title>
    <url>%2F2019%2F09%2F23%2Fpython%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordPress文章版本]]></title>
    <url>%2F2019%2F09%2F22%2FwordPress%E6%96%87%E7%AB%A0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[修改站点的wp-config.php文件，在其中添加如下代码 12define('WP_POST_REVISIONS', 0); //不启用修订版本define('WP_POST_REVISIONS', 3); //共保存3个版本]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>文章版本</tag>
        <tag>wordPress配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordPress的文章和页面]]></title>
    <url>%2F2019%2F09%2F22%2FwordPress-1%2F</url>
    <content type="text"><![CDATA[文章和页面 文章：是网站的主要内容页面：是网站的其他一些信息 以哔哩哔哩网为例 它的主要内容是视频，所以打开它的网站可以看到许多视频推送，这就是它的文章 而下拉到末尾，可以看到其他一些次要信息，这些就是页面 由于文章内容繁杂，所以可以创建分类便于管理和用户查询，而页面没有分类功能]]></content>
      <categories>
        <category>wordPress</category>
      </categories>
      <tags>
        <tag>wordpress一些基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时域分析]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%97%B6%E5%9F%9F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一阶动态性能指标]]></content>
      <categories>
        <category>自动控制原理</category>
      </categories>
      <tags>
        <tag>时域分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多任务——进程]]></title>
    <url>%2F2019%2F09%2F20%2Fpython%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程及其状态进程 程序：例如xxx.py这是程序，是静态的 进程：程序运行起来后，代码+用到的资源称为进程 进程的状态任务数往往大于CPU核数，因而一定有一些任务正在进行，另一些任务等待，这样就导致了进程有不同的状态 就绪态：运行条件都满足，等待CPU调度 执行态：CPU正在执行 等待态：等待某些条件满足，例如一个程序sleep中 创建进程使用multiprocessing模块123456789101112131415161718192021# 导入模块import multiprocessingimport timedef testProcess(): for i in range(5): print("process------") time.sleep(1)def main(): # 创建进程 my_pro = multiprocessing.Process(target=testProcess) # 启动进程 my_pro.start() time.sleep(10)if __name__ == "__main__": main() 进程间通信 线程间资源共享进程间资源不共享，是独立的 举例说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import multiprocessingimport threadingimport timeg_num = 0def test1(): global g_num for i in range(10): g_num += 1 print("test1-----%d" % g_num)def test2(): global g_num for i in range(10): g_num += 1 print("test2-----%d" % g_num)def test_pro(): print("测试进程") p1 = multiprocessing.Process(target=test1) p2 = multiprocessing.Process(target=test2) p1.start() time.sleep(0.01) p2.start()def test_thr(): print("测试线程") t1 = threading.Thread(target=test1) t2 = threading.Thread(target=test2) t1.start() time.sleep(0.01) t2.start()def main(): # test_pro() test_thr()if __name__ == "__main__": main() 结果 123测试线程test1-----10test2-----20 改变main()函数123def main(): test_pro() # test_thr() 再次执行 123测试进程test1-----10test2-----10 实现进程间通信：Queue Queue是队列的意思，遵循先进先出的原则一个进程向Queue中写入数据，另一个进程从Queue中取出，就可实现通信这是一种比较低端的方式，还可使用socket，redis等实现 代码1234567891011121314151617181920212223242526272829303132333435363738394041import multiprocessingimport timedef download_from_web(queue): """模拟从网上下载数据""" data = [11, 22, 33, 44] # 向对列中写入数据 for temp in data: queue.put(temp) print("已全部存入队列")def analysis_data(queue): """数据处理""" d_data = list() # 获取数据 while not queue.empty(): data = queue.get() d_data.append(data) print("接收完成--%s" % d_data)def main(): # 创建一个队列 queue = multiprocessing.Queue() # 创建多个进程，将队列的引用当作实参传递到里面 p1 = multiprocessing.Process(target=download_from_web, args=(queue, )) p2 = multiprocessing.Process(target=analysis_data, args=(queue, )) p1.start() time.sleep(0.01) p2.start()if __name__ == "__main__": main() 运行结果 12已全部存入队列接收完成--[11, 22, 33, 44] 成功实现了进程间的通讯 进程池 进程不多时可以直接使用Process动态生成多个进程，但如果所需进程过多，手动创建进程工作量太大，且不利于cpu的运行，因而可以使用进程池Pool进程池是资源进程、管理进程组成的技术的应用(引自百度百科) 资源进程：预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。管理进程：管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。这样进程使有进有出，有序管理 代码 1234567891011121314# 导包from multiprocessing import Pool# 定义进程池po = Pool(3) # 3指最多同时执行3个进程# 添加进程队列，target指进程地址，args是进程函数的参数，是一个元组po.apply_asyns(target, args)# 关闭进程池po.close()# 等待po中所有子进程完成，必须在close()语句之后，没有这句代码，可以使主进程先结束，子进程也无法继续进行po.join() 案例123456789101112131415161718192021222324252627from multiprocessing import Poolimport osimport timeimport randomdef worker(msg): t_start = time.time() print("&#123;0&#125;开始执行，进程号&#123;1&#125;".format(msg, os.getpid())) time.sleep(random.random()) t_stop = time.time() print(msg, "执行完毕，耗时%f" % (t_stop-t_start))def main(): po = Pool(3) for i in range(10): po.apply_async(worker, (i+1, )) print("---start---") po.close() po.join() print("----end----")if __name__ == "__main__": main() 运行结果 12345678910111213141516171819202122---start---1开始执行，进程号220442开始执行，进程号220453开始执行，进程号220461 执行完毕，耗时0.1752324开始执行，进程号220443 执行完毕，耗时0.2172865开始执行，进程号220465 执行完毕，耗时0.1872886开始执行，进程号220464 执行完毕，耗时0.6135127开始执行，进程号220442 执行完毕，耗时0.8605068开始执行，进程号220457 执行完毕，耗时0.4708759开始执行，进程号220446 执行完毕，耗时0.96947610开始执行，进程号220469 执行完毕，耗时0.3128298 执行完毕，耗时0.90982510 执行完毕，耗时0.897377----end---- 可以从进程号看出一直在重复利用22044, 22045, 22046三个pid从输出来看，可以看出来同一时间最多只有三个进程执行 注意：在进程池间使用队列通信，不能使用multiprocessing.Queue()，而要使用multiprocessing.Manager().Queue() 综合案例 实现文件复制功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osimport multiprocessingdef copy_file(queue, file_name, src_dir, dest_dir): src_file = open(src_dir+"/"+file_name, "rb") # print("正在复制%s" % src_file) content = src_file.read() dest_file = open(dest_dir+"/"+file_name, "wb") dest_file.write(content) # 如果拷贝完了文件，就向队列写入数据，表示下载完成 queue.put(file_name)def main(): # 获取用户需要copy的文件名 src_dir = input("请输入要复制的文件夹：") # 创建一个新的文件夹 try: dest_dir = src_dir+"_copy" os.mkdir(dest_dir) except: print("该文件夹已存在") # 获取文件夹中所有的待copy的文件名字listdir() file_names = os.listdir(src_dir) total_num = len(file_names) current_num = 0 # 创建进程池 po = multiprocessing.Pool(5) # 创建一个队列 queue = multiprocessing.Manager().Queue() # 向进程池添加复制任务 for file_name in file_names: po.apply_async(copy_file, (queue, file_name, src_dir, dest_dir)) po.close() # po.join() # 显示执行进度 while True: file_name = queue.get() current_num += 1 now_step = current_num/total_num print("\r已拷贝%s-------进度%.2f %% " % (file_name, 100*now_step), end="") if now_step == 1: break print()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多任务——线程]]></title>
    <url>%2F2019%2F09%2F19%2Fpython%E5%A4%9A%E4%BB%BB%E5%8A%A1%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Thread创建线程使用Threading模块 语法格式 1234567# 导入threading模块import threading# 创建线程my_thread = threading.Thread(target=函数名)# 开启线程my_thread.start() 代码示例 1234567891011121314151617import threadingimport timedef testThread(): while True: print("hello") time.sleep(1)def main(): thrd = threading.Thread(target=testThread) thrd.start()if __name__ == "__main__": main() 运行结果： 每隔一秒打印一次hello 继承Thread类创建线程 步骤 创建类，继承Thread类 在这个类中重写run()方法 示例123456789101112131415161718192021import timefrom threading import *class MyThread(Thread): """继承Thread类""" def run(self): """重写run()方法""" for i in range(3): time.sleep(1) print("hello")def main(): mythread = MyThread() # 调用start()方法后会自动调用run()方法 mythread.start()if __name__ == "__main__": main() 执行结果：每隔一秒打印一次hello 查看线程数量 使用Threading模块中的enumerate()方法 1print(threading.enumerate()) 示例 1234567891011121314151617181920212223242526272829import threadingimport timedef testThread1(): for i in range(3): print("thread---1") time.sleep(0.1)def testThread2(): for i in range(3): print("thread---2") time.sleep(0.1)def main(): thrd1 = threading.Thread(target=testThread1) thrd2 = threading.Thread(target=testThread2) thrd1.start() thrd2.start() print(threading.enumerate()) time.sleep(1) print(threading.enumerate())if __name__ == "__main__": main() 运行结果 123456789thread---1thread---2[&lt;_MainThread(MainThread, started 140351833364096)&gt;, &lt;Thread(Thread-1, started 140351824549632)&gt;, &lt;Thread(Thread-2, started 140351746602752)&gt;]thread---1thread---2thread---1thread---2[&lt;_MainThread(MainThread, started 140351833364096)&gt;] 注意： 只有调用了start()方法时才会创建线程并开始执行，而使用Thread(target=)只是创建一个对象，所以只有放在start()后和线程结束前才可以使用enumerate()查看 由运行结果可见，当一个线程结束后，不会再打印它的信息，即列表中不再存在，由此可以判断其他线程是否都结束123# 当只有主线程的时候if len(threading.enumerate()) == 1: break 线程中传递参数args 线程中传递的参数使用args指定，必须是一个元组123456789101112131415161718192021222324252627282930313233import threadingimport timeg_list1 = [11, 22]g_list2 = [11, 22]def test1(list1): list1.append(33) print("在test1中，list1=%s" % list1)def test2(list1, list2): list1.append(44) list2.append(33) print("在test2中，list1=%s" % list1) print("在test2中，list2=%s" % list2)def main(): # target指定函数地址 # args指定参数，必须是一个元组 t1 = threading.Thread(target=test1, args=(g_list1, )) # 当参数只有一个时，使用args=(temp, )的方式 t2 = threading.Thread(target=test2, args=(g_list1, g_list2)) t1.start() time.sleep(0.1) t2.start() time.sleep(0.1)if __name__ == "__main__": main() 运行结果 123在test1中，list1=[11, 22, 33]在test2中，list1=[11, 22, 33, 44]在test2中，list2=[11, 22, 33] 互斥锁解决资源竞争资源竞争 由于多线程共用资源，会产生资源竞争的问题，如下面的代码，让两个线程同时对全局变量执行加一的操作，若不存在资源竞争，应当结果为二者循环次数之和，而结果往往小于此 这是因为当一个线程拿到数据加一后，可能还未存放结果，这个数据就被另一个线程调用，这样就会使数值低于预期12345678910111213141516171819202122232425262728293031323334import timeimport threadingg_num = 0def add_1(times): global g_num for i in range(times): g_num += 1 print("thread2-----%d" % g_num)def add_2(times): global g_num for i in range(times): g_num += 1 print("thread2-----%d" % g_num)def main(): t1 = threading.Thread(target=add_1, args=(1000000, )) t2 = threading.Thread(target=add_2, args=(1000000, )) t1.start() t2.start() while True: # 确保执行完毕,每隔1s判断一次 time.sleep(1) if len(threading.enumerate()) == 1: print("main-----%d" % g_num) breakif __name__ == "__main__": main() 运行结果 123thread2-----1197292thread2-----1253537main-----1253537 # 这个结果不一定，但往往小于预期的2000000 互斥锁 当对象被线程调用时给对象上锁，只有使用完成后才释放，保证同一资源只有一个线程在调用 12345678# 创建锁，默认未锁定mutex = threading.Lock()# 锁定mutex.acquire()# 释放mutex.release() 以上例中的add_1()为例 12345678910111213# 创建互斥锁mutex = threading.Lock()def add_1(times): global g_num mutex.acquire() for i in range(times): g_num += 1 mutex.release() print("thread1-----%d" % g_num)# add_2()改变的格式同add_1() 执行结果 123thread1-----1000000thread2-----2000000main-----2000000 上面的改动中将锁放在了循环之外，因而当一个线程抢到资源后后全部执行结束后才释放，在实际开发中，应当尽量减小锁的范围，本例中可将锁置于循环之中1234567def add_1(times): global g_num for i in range(times): mutex.acquire() g_num += 1 mutex.release() print("thread1-----%d" % g_num) 执行结果 123thread1-----1971999 # 两个线程交替拿到资源thread2-----2000000main-----2000000 死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，如123456789101112131415mutexA = threading.Lock()mutexB = threading.Lock()def test1(): mutexA.acquire() time.sleep(1) mutexB.acquire() mutexA.release()def test2(): mutexB.acquire() time.sleep(1) mutexA.acquire() mutexB.release() 上例中，test1()先将mutexA上锁，test2()先将mutexB上锁当休眠结束后，test1()要给mutexB上锁，之后才能释放mutexA，而mutexB已经被test2()上锁占用，因而要等待test2()释放mutexB而test2()要释放mutexB，又要等待test1()释放mutexA，这样两者都不会进行到下一步，从而产生了死锁 避免： 程序设计中避免 添加超时算法等]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python多任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用tcp下载文件]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%88%A9%E7%94%A8tcp%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[客户端 即要接收文件的一方12345678910111213141516171819202122232425262728293031323334from socket import *def main(): # 创建套接字 tcp_socket = socket(AF_INET, SOCK_STREAM) # 获取服务器的ip port dest_ip = input("请输入对方的ip：") dest_port = input("请输入对方的port：") # 连接服务器 tcp_socket.connect((dest_ip, int(dest_port))) # 获取下载的文件名称 download_file_name = input("请输入要下载的文件名：") # 将文件名字发送到服务器 tcp_socket.send(download_file_name.encode("utf-8")) # 接收文件数据 recv_data = tcp_socket.recv(1024*1024) # 1k*1024=1M # 保存接收到的数据到一个文件中，如果内容为空则不创建文件 if recv_data: with open ("[new]"+download_file_name, "wb") as d_file: d_file.write(recv_data) # 关闭套接字 tcp_socket.close()if __name__ == "__main__": main() 服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from socket import *def send_file_to_client(client_socket, client_addr): # 接收客户端要下载的文件名 file_name = client_socket.recv(1024).decode("utf-8") print("客户端&#123;0&#125;要下载的文件是&#123;1&#125;".format(client_addr, file_name)) # 打开文件读取数据 file_content = None try: dl_file = open(file_name, "rb") file_content = dl_file.read() dl_file.close() except Exception as e: print("没有该文件(%s)" % file_name) # 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close if file_content: # 回送数据 client_socket.send(file_content)def main(): # 创建套接字 tcp_serve_socket = socket(AF_INET, SOCK_STREAM) # 绑定本地信息 tcp_serve_socket.bind(("", 7788)) # 让默认套接字由主动变为被动,listen tcp_serve_socket.listen(128) while True: # 等待客户端的连接accept,未连接到客户端会进入堵塞 print("等待客户端连接...") client_socket, client_addr = tcp_serve_socket.accept() # 发送文件 send_file_to_client(client_socket, client_addr) # 关闭套接字 client_socket.close() print("已为客户服务完成") tcp_serve_socket.close()if __name__ == "__main__": main() 执行程序准备工作 首先先在当前目录下新建一个文件，以供调试使用，假设新建一个名为test.txt的文件，并在里面写下一些内容，如 12this is some text这是一写文本 查看自己的ip地址 1234# 一般使用ifconfig | grep inet# archlinux使用ip addr | grep inet 记住ip地址，假设为123.12.10.154 同时运行两端代码 客户端依次输入ip地址，端口号(程序中指定了7788，可更改为1024–65535之间的其他数字) 123请输入对方的ip：123.12.10.154请输入对方的port：7788请输入要下载的文件名：test.txt 服务器中自动打印出了如下信息 1234等待客户端连接...客户端(&apos;10.128.150.40&apos;, 34878)要下载的文件是test.txt已为客户服务完成等待客户端连接... 运行结果打开文件管理器，发现在当前目录下出现了一个名为[new]test.txt的文件，打开，查看内容，发现与test.txt中内容一致，说明代码执行成功]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>tcp</tag>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enumerate()函数和推导式生成列表]]></title>
    <url>%2F2019%2F09%2F17%2Fenumerate-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8E%A8%E5%AF%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[描述 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 语法 以下是 enumerate() 方法的语法:1enumerate(sequence, [start=0]) 参数 sequence – 一个序列、迭代器或其他支持迭代对象。start – 下标起始位置。返回值返回 enumerate(枚举) 对象。 示例123456letters = ["a", "b", "c", "d"]gnt = enumerate(letters, start=1)print(gnt)# 需要调用list方法my_enum = list(gnt)print(my_enum) 结果 12&lt;enumerate object at 0x7f67e867f2d0&gt;[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')] 实现给文件的每行增加行号 新建文本文件test.txt，里面写上 1234窗前明月光疑是地上霜举头望明月低头思故乡 在python文件写入以下代码 1234567with open(r"test.txt", "r", encoding="utf-8") as my_file: lines = my_file.readlines() lines = ["#"+str(index+1)+" "+line for index, line in list(enumerate(lines))] # 推导式生成推导式 # 也可写成lines = ["#"+str(index+1)+" "+line for index, line in enumerate(lines)]with open(r"test.txt", "w", encoding="utf-8") as my_file: my_file.writelines(lines) 打开test.txt查看执行结果 1234#1 窗前明月光#2 疑是地上霜#3 举头望明月#4 低头思故乡]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[close()关闭流]]></title>
    <url>%2F2019%2F09%2F17%2Fclose-%E5%85%B3%E9%97%AD%E6%B5%81%2F</url>
    <content type="text"><![CDATA[为了确保打开的文件对象正常关闭，一般结合异常机制的finally或者with关键字实现无论何种情况都能关闭打开的文件对象 使用finally12345678try: f = open(r"my_text.txt", "a") my_str = "hello" f.write(str)except BaseException as e: print(e)finally: f.close() 使用with with关键字(上下文管理器)可以自动管理上下文资源，不论什么原因跳出with块，都能确保文件正常的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场12with open(r"test.txt", "a") as my_file: my_file.write("hello") 执行完后，可以自动关闭文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数嵌套]]></title>
    <url>%2F2019%2F09%2F17%2Fpython%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[使用 封装——数据隐藏,外部无法访问嵌套函数 提高代码复用率 示例12345678910def f1(): print("f1") def f2(): print("f2") f2()f1()# f2() 不可在外部调用 nonlocal关键字 global声明全局变量 ninlocal声明外部变量 1234567891011def outer(): b = 10 def inner(): nonlocal b b = 20 inner() print(b)outer() 结果 120]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用zip()并行迭代]]></title>
    <url>%2F2019%2F09%2F17%2F%E4%BD%BF%E7%94%A8zip-%E5%B9%B6%E8%A1%8C%E8%BF%AD%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[实例 123456names = ("张三", "李四", "王五", "赵六")ages = (20, 30, 35, 28)jobs = ("老师", "工程师", "程序员")for name, age, job in zip(names, ages, jobs): print("&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format(name, age, job)) 结果 123张三-20-老师李四-30-工程师王五-35-程序员 当示例中一个元组job遍历结束后整个遍历就结束了，因而没有输出赵六的信息 不使用zip()实现上述功能的代码12for i in range(3) print("&#123;0&#125;-&#123;1&#125;-&#123;2&#125;".format(names[i], ages[i], jobs[i]))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__call__方法]]></title>
    <url>%2F2019%2F09%2F17%2Fcall-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python中，如果在创建类的时候写了__call__()方法， 那么该类实例化出实例后， 实例名()就是调用__call__()方法。 123456789101112class SalaryAccount: """工资计算类""" def __call__(self, salary): print("发工资") year_salary = salary*12 day_salary = salary//22.5 hour_salary = day_salary//8 return dict(year_salary=year_salary, month_salary=salary, day_salary=day_salary, hour_salary=hour_salary)s = SalaryAccount()print(s(3000)) 执行结果 12发工资&#123;'year_salary': 36000, 'month_salary': 3000, 'day_salary': 133.0, 'hour_salary': 16.0&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp网络编程]]></title>
    <url>%2F2019%2F09%2F16%2Ftcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP百度百科 简介 TCP通信需要经过创建链接，数据传送，终止连接三个步骤 通信双方都必须先建立连接才能进行通讯，双方都要为连接分配必要的系统内核资源，以管理连接的状态和传输 TCP的连接是一对一的，因此，基于广播的应用程序应使用UDP， TCP客户端 TCP严格区分服务器和客户端，服务器就是提供服务的一方，客户端就是需要服务的一方，而UDP不区分 TCP客户端构建流程 代码流程1234567891011121314151617181920212223from socket import *def main(): # 创建tcp的套接字 tcp_client_socket = socket(AF_INET, SOCK_STREAM) # 连接服务器 serve_ip = input("请输入服务器ip：") serve_port = input("请输入服务器port：") serve_addr = (serve_ip, int(serve_port)) tcp_client_socket.connect(serve_addr) # 发送/接收数据,使用send方法，不需要多次指定套接字 send_data = input("请输入要发送的数据：") tcp_client_socket.send(send_data.encode("gbk")) # 关闭套接字 tcp_client_socket.close()if __name__ == "__main__": main() TCP服务器12345678910111213141516171819202122232425262728293031323334353637383940414243444546from socket import *def main(): # 创建套接字 tcp_serve_socket = socket(AF_INET, SOCK_STREAM) # 绑定本地信息 tcp_serve_socket.bind(("", 7788)) # 让默认套接字由主动变为被动,listen # 使用socket创建的套接字默认的属性是主动的，使用listen可将其变为被动，这样就可以接收别人的连接了 tcp_serve_socket.listen(128) # 循环为多个客户端服务 while True: # 等待客户端的连接accept,未连接到客户端会进入堵塞 # 如果有新的客户端来连接服务器，那么就产生一个新的套接字专门为这个客户端服务 # client_socket用来为这个客户端服务 # tcp_serve_socket就可以省下来专门等待其他新的客户端的连接 print("等待客户端连接...") client_socket, client_addr = tcp_serve_socket.accept() print("新的客户端已连接：%s" % str(client_addr)) # 循环为同一个客户端服务 while True: # 接收客户端请求,会进入堵塞 recv_data = client_socket.recv(1024) print("客户端请求是：%s" % recv_data) # 如果recv解堵塞，有两种方式：1.客户端发送了数据，2.客户端调用了close if recv_data: # 回送数据 client_socket.send("hello".encode("gbk")) else: break # 关闭套接字 client_socket.close() print("已为客户服务完成") tcp_serve_socket.close()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[udp网络编程]]></title>
    <url>%2F2019%2F09%2F15%2Fudp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP百度百科 创建udp套接字123import socketudp_socket = socket.socket(socket.AF_INET, socket.DGRAM) 发送数据使用sendto()方法 123send_data = input("please input:")# 发送的数据(utf-8编码) (ip地址, 端口)udp_socket.sendto(send_data.encode("utf-8"), ("X.X.X.X", port)) # 如果发送方未绑定端口，系统会随机分配1024-65535 获取端口1234# 创建元组，ip地址和端口号local_addr = ("", 7788) # ip地址一般不用写，表示本机的任意一个ip# 绑定udp_socket.bind(local_addr) 程序实例123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketdef send_msg(udp_socket): """发送数据""" dest_ip = input("请输入对方的ip：") dest_port = input("请输入对方的port：") send_data = input("请输入发送的消息：") udp_socket.sendto(send_data.encode("utf-8"), (dest_ip, int(dest_port)))def recv_msg(udp_socket): """接收数据""" # 接收数据,1024是本次接收的最大字节数，如果未接收到会进入阻塞状态 recv_data = udp_socket.recvfrom(1024) # 会接收到数据和发送方的ip地址和端口 recv_msge = recv_data[0] send_addr = recv_data[1] # 打印接收到的数据, 需要指定解码，如果是windows发送，应当使用gbk解码 print("接收到的数据是：%s 来源于：%s" % (recv_msge.decode("utf-8"), str(send_addr)))def main(): # 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定信息 udp_socket.bind(("", 7788)) while True: print("0退出，1发送，2接收") option = input("请输入指令：") if option == "0": break elif option == "1": # 发送 send_msg(udp_socket) elif option == "2": # 接收并显示 recv_msg(udp_socket) else: print("输入错误，请重新输入")if __name__ == "__main__": main() socket套接字是全双工工作模式，即可以同时收发]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络的一些基本概念]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[ip地址的分类ipv4(百度百科) internet protocol version 4指互联网协议的第四种版本，ipv1，ipv2，ipv3是实验版本 特点： 由四组数字组成：如127.168.8.32，其中每组最大值是255ipv6 internet protocol version 6指第六种版本，ipv5是实验版本 表示方法：(引自百度百科) 冒分十六进制表示法 格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，以十六进制表示，例如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789这种表示法中，每个X的前导0是可以省略的，例如：2001:0DB8:0000:0023:0008:0800:200C:417A→ 2001:DB8:0:23:8:800:200C:417A 0位压缩表示法 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为::。但为保证地址解析的唯一性，地址中::只能出现一次，例如：FF01:0:0:0:0:0:0:1101 → FF01::1101，0:0:0:0:0:0:0:1 → ::1，0:0:0:0:0:0:0:0 → :: 内嵌IPv4地址表示法 为了实现IPv4-IPv6互通，IPv4地址会嵌入IPv6地址中，此时地址常表示为：X:X:X:X:X:X:d.d.d.d，前96b采用冒分十六进制表示，而最后32b地址则使用IPv4的点分十进制表示，例如::192.168.0.1与::FFFF:192.168.0.1就是两个典型的例子，注意在前96b中，压缩0位的方法依旧适用 端口 ip用来标识主机，端口(port)用来指定数据传输的主机程序 知名端口(Well Known Ports) 知名端口是众所周知的端口号，范围从0到1023，如： 80端口分配给HTTP服务 21端口分配给FTP服务动态端口(Dynamic Ports) 动态端口范围是1024-65535 之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配 动态分配：程序需要网络通信时，它向主机申请一个端口，主机从可用的端口中为它分配一个，当这个程序关闭时，同时也就释放了它所占用的端口 套接字(socket) 网络套接字是IP地址与端口的组合。套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信. 在python中使用socket 在python中使用socket模块即可12import socketsocket.socket(AddressFamily, Type) 参数说明 AddressFamily: 可以选择AF_INET(用于Internet进程间通讯)或者AF_UNIX(用于同一台机器进程间通讯)，实际工作中常用AF_INETType: 套接字类型，可以是SOCK_STREAM(流式套接字，主要用于TCP协议)，或者SOCK_DGRAM(数据报套接字，主要用于UDP协议) 创建一个tcp套接字12345678910import socket# 创建tcp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 使用套接字的功能... ...# 关闭套接字s.close() 可以发现，它的基本流程与文件的操作大致相同 创建一个udp套接字123456789101112131415161718import socket def main(): """测试udp发送数据""" # 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 接收要发送的数据 send_data = input("请输入发送的数据：") # 发送数据 使用utf-8编码，后接元组(ip地址，端口) udp_socket.sendto(send_data.encode("utf-8"), ("192.168.32.32", 8080)) # 关闭套接字 udp_socket.close()if __name__ == "__main__": main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@property装饰器]]></title>
    <url>%2F2019%2F09%2F11%2Fproperty%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[功能 @property装饰器可以让方法像属性一样进行调用 演示不使用@property装饰器1234567891011121314class Person(object): def __init__(self, age): self.__age = age def set_age(self, age): self.__age = age def get_age(self): return self.__agejack = Person(18)print(jack.get_age())jack.set_age(20)print(jack.get_age()) 运行结果121820 使用装饰器12345678910111213141516171819class Person: def __init__(self, age): self.__age = age @property def age(self): return self.__age # 注意这里是age.setter @age.setter def age(self, age): self.__age = agejack = Person(18)# 像属性一样调用方法print(jack.age)# 像属性一样调用方法jack.age = 20print(jack.age) 运行结果121820]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>property装饰器</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval()函数]]></title>
    <url>%2F2019%2F09%2F10%2Feval-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[功能描述123456789101112131415# 数学计算input: eval("1+1")output: 2# 字符串重复input: eval("'*' * 10")output: **********# 将字符串转化为列表input: type(eval("[1, 2, 3, 4]"))output: list# 将字符串转换为字典input: type(eval("&#123;'name': 'xiaoming', 'age': 18&#125;"))output: dict 演示案例：计算器1print(eval(input("请输入计算式: "))) 执行12请输入计算式: 5+2*5**255 不要滥用eval 使用eval()直接转换输入结果可能导致安全漏洞，如上例中用户输入__import__(&#39;os&#39;).system(&#39;ls&#39;) 等价于 12import osos.system("ls") 运行 1234请输入计算式: __import__('os').system('ls')test1.pytest2.py0 输出了当前目录下文件列表，同理也可执行其他增删改的终端命令，很不安全 执行成功，返回0 执行失败，返回错误信息]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>eval</tag>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的文件操作]]></title>
    <url>%2F2019%2F09%2F09%2Fpython%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件基本操作操作文件的函数/方法 函数/方法 功能 open 打开文件，并返回操作对象 read 将文件读取到内存 write 将指定内容写入文件 writeLines 将指定内容写入文件，不填加换行符 fiush 把缓冲区的内容写入文件，但不关闭文件 close 把缓冲区的内容写入文件，并关闭文件 read write close三者都要通过文件对象来进行调用 read方法 open()第一个参数是要打开的文件名(区分大小写) 打开后操作完成要使用close()关闭，否则会消耗系统资源，影响后续对文件的访问 通常先编写打开和关闭文件代码，在编写中间的读写操作 1234567# 打开file = open("文件名")# 读取text = file.read()print(text)# 关闭file.close() 关于文件指针 python中读取完内容后会将指针移动到读取内容的末尾，默认是文件末尾 连续两次读取文件，由于第一次读完指针已经在末尾，因而第二次读不到内容 打开文件的方式 open()默认以只读打开 1file = open("文件名", "访问方式") 访问方式 说明 r 只读，指针在文件开头，不存在会抛出异常 w 只写，若文件存在则覆盖，不存在则创建 a 追加，文件存在，指针就放在文件末尾，不存在，抛出异常 r+ 读写，文件指针在开头，若不存在，抛出异常 w+ 读写，文件存在则覆盖，不存在就创建 a+ 读写，文件存在则指针放在末尾，文件不存在，创建新文件 b 二进制模式，可与其他模式组合 使用读写方式打开，会影响文件读写效率，开发中更多的是以只读，只写的方式打开 对于二进制文件需要加b，如打开模式为wb，rb 按行读取 read()方法默认读取全部，读取大文件对于系统内存占用会非常严重 readLine方法 一次读取一行，方法执行后，指针向下移动一行 读取大文件123456789101112131415file = open("test")while True: # 读取一行 text = file.readLine() #判断是否读取到内容 if not text: break #每读到一行末尾已经有"\n" print(text, end="") # 关闭文件file.close() 复制文件1234567891011file_r = open("test")file_w = open("test_copy")while True: text = file_r.readLine() if not text: break file_w.write(text)file_r.close()file_w.close() 执行后打开file_w文件，发现已经复制了file_r的内容 文件/目录的常用管理操作文件操作 方法 说明 示例 rename 重命名文件 os.rename(“源文件名”, “目标文件名”) remove 删除文件 os.remove(“文件名”) 目录操作12# 导入os模块import os 方法 说明 示例 listdir 目录列表 os.listdir(“目录名”) mkdir 创建目录 os.mkdir(“目录名”) rmdir 删除目录 os.rmdir(“目录名”) getcwd 获取当前目录 os.getcwd() chdir 修改工作目录 os.chdir(“目标目录”) path.isdir 判断是否为目录 os.path.isdir(“文件路径”) python编码 python2默认使用ascii编码，不支持中文 python3默认使用utf-8编码，支持中文 改变python2的编码格式，使支持中文，将下句代码写在文件开头1# *-* coding:utf-8 *-* 或者 1# coding = utf-8 另外，使用python2输出中文时，会出现乱码，这是因为解释器会一个字节一个字节的输出，而中文一般是三个字节 12345678#!/usr/bin/python2# *-* coding: utf-8 *-*my_str = "hello, 你好"print(my_str)for letter in my_str: print(letter) 运行结果 12345678910111213hello, 你好hello,�� 输出乱码 解决方法：定义字符串时，前面加上字母u，说明这是utf-8格式的字符串 1my_str = u"hello, 你好" 再次运行 12345678910hello, 你好hello,你好 不再乱码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的模块和包]]></title>
    <url>%2F2019%2F09%2F06%2Fpython%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[模块每一个以py结尾的python源代码文件都是一个模块 模块导入import导入格式 不推荐格式：将几个模块放在一行 1import 模块名1, 模块名2 推荐:每个模块单独占一行 12import 模块名1import 模块名2 导入之后可以通过模块名.的方式使用模块提供的工具：全局变量，类，函数 使用as指定模块别名 如果模块名字太长就可以使用as来指定别名，方便实用1import 模块名 as 模块别名 模块别名应该符合大驼峰命名法 from…import导入 如果希望从某一个模块中，导入部分工具，就可以使用这种方式 语法格式12# 从模块导入某一个工具from 模块名 import 工具名 导入之后不需要通过模块名.就可以直接使用模块的工具如果两个模块存在同名的函数，那么后导入模块的函数，会覆盖掉先导入的函数 可以通过as别名的方式调用前面导入的函数12345from pkg1 import test as pkg1_test #给test()函数起别名from pkg2 import test # pkg1和pkg2中同时含有test()方法pkg1_test() #调用pkg1的test()test() #调用pkg2的test() 导入全部 语法12# 从 模块 导入 所有工具from 模块名 import * 不推荐使用，因为函数重名不好排查 python导入模块的顺序 搜索当前目录指定模块名的文件，如果有就直接导入 如果没有，再搜索系统目录 在开发时创建文件，命名不要和系统模块文件重名，否则调用系统方法时会因为当前目录下存在该模块而不去搜索系统目录，使程序无法正确执行 使用内置方法__file__可查看文件完整路径1print(模块名.__file__) 关于模块导入 在导入模块时，文件中没有缩进的代码都会被执行一遍12# 这是test1模块中的内容print("这是模块一") 123# 这是test2模块中的内容import test1print("这是模块二") 在模块test2中run，执行结果12这是模块一这是模块二 而有时开发中开发者要做一些测试，写的一些代码只希望在本文件内执行而不想在被导入时执行 __name__属性 __name__属性可以做到，测试模块的代码只在测试时执行，在被导入时不执行 __name__属性是python的一个内置属性，记录着一个字符串 如果是被其他文件导入的，则记录的是模块名 如果是当前执行的程序，__name__是__main__12# 模块test1中print(__name__) 123# 模块test2中import test1print(__name__) 在test2中run，运行结果 12test1__main__ 所以在测试时可以通过__name__来实现代码仅在测试时执行 123# 模块test1中if __name__ == "__main__": print("这是模块一") 123# 模块test2中import test1print("这是模块二") 在模块test2中run，运行结果 1这是模块二 编写代码格式 1234567891011.........# 文件末尾，编写本地测试代码def main(): ... pass if __name__ == "__main__": main() 包 包是一个包含多个模块的特殊目录 目录下有一个特殊的文件__init__.py 包的命名和变量一致，使用小写字母和_，如this_is_a_pkg 可以使用import 包名的方式，一次性导入包中所有的模块 在pycharm中鼠标停在工程名上点击鼠标右键 选择new –&gt; Python Package可以建立包并自动创建__init__.py空文件 或选择new –&gt; Directory创建文件目录，再自行创建__init__.py文件 __init__.py文件 包中可以对外界使用的模块，需要在__init__.py中写出列表123# 从 当前目录 导入 模块列表from . import 模块名称1from . import 模块名称2 发布模块包的步骤发布包 创建setup.py文件1234567891011from distutils.core import setupsetup(name="pkg_name", # 包名 version="1.0", # 版本 description="some text", # 描述信息 long_description="完整的发送和接收消息模块", # 完整描述信息 author="itheima", # 作者 author_email="abc.com", # 作者邮箱 url="www.abc.com", # 主页 py_modules=["包名.模块名1", #要分享的模块 "包名.模块名2"]) 有关字典参数的详细信息，可以参阅官方网站 构建模块 1python3 setup.py build 生成发布压缩包 1python3 setup.py sdist 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！ 下载包 安装模块 12tar -zxvf 压缩包名.tar.gz sudo python3 setup.py install 卸载模块直接从安装目录下，把安装模块的目录删除就可以 12cd /usr/local/lib/python3.7/dist-packages/sudo rm -r 包名* 可以使用pip安装第三方模块 1234567# 将第三方模块安装到python2.x环境sudo pip install 模块sudo pip uninstall 模块# 将第三方模块安装到python3.x环境sudo pip3 install 模块sudo pip3 uninstall 模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的异常]]></title>
    <url>%2F2019%2F09%2F06%2Fpython%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[程序开发时很难将所有特殊情况都处理的面面俱到，通过异常捕获可以针对突发事件集中处理，从而保证程序的稳定性和健壮性 捕获异常简单捕获 格式1234try: 尝试执行的代码except: 出现错误的处理 执行后会继续执行下方的代码 123456try: num = int(input("请输入一个整数: "))except: print("请输入正确的整数")print("继续执行了下方代码") 执行程序：用户输入了aaa，无法转化为整数 请输入一个整数: aaa 执行结果12请输入正确的整数继续执行了下方代码 错误类型捕获 针对不同类型的异常，作出不同的相应 123456789101112try: #尝试执行的代码 passexcept 错误类型1: #针对类型1处理 passexcept (错误类型2, 错误类型3): #针对类型2和3处理 pass# 捕获未知错误，可以改变result的名字except Exception as result: print("未知错误 %s" % result) 获取错误类型：出错时，控制台提示的最后一行就是错误类型，找到错误类型就可针对不同的错误进行不同的操作 123num = int(input("请输入一个整数: "))result = 10/numprint(result) 执行程序，用户输入0 请输入一个整数: 0 执行结果1234Traceback (most recent call last): File "/home/duguosheng/PycharmProjects/190902/d2_excpt.py", line 3, in &lt;module&gt; result = 10/numZeroDivisionError: division by zero 则ZeroDivisionError就是输入零时的错误类型，同理可得，输入字母时的错误类型是ValueError 针对不同错误类型的处理 12345678try: num = int(input("请输入一个整数: ")) result = 10 / num print(result)except ZeroDivisionError: print("请不要输入0作为除数")except ValueError: print("请输入数字") 捕获未知异常:假设未能预计到输入零的情况 123456789try: num = int(input("请输入一个整数: ")) result = 10 / num print(result)except ValueError: print("请输入数字")# 捕获未知异常except Exception as result: print("未知错误 %s" % result) 用户输入0 请输入一个整数: 0 执行结果1未知错误 division by zero 异常捕获完整语法1234567891011121314try: passexcept 错误类型1: passexcept (错误类型2, 错误类型3): passexcept Exception as result: print(result)else: #没有异常才会执行的代码 passfinally: #无论是否有异常，都会执行的代码 pass 异常的传递 当函数/方法执行出现异常，会将异常传递给函数/方法的调用一方 如果传递到主程序，仍然没有异常处理，程序才会终止 开发中可以在主函数中增加异常捕获，这样就可以大大减少异常捕获代码，使代码整洁 12345678910def test1(): return 10/int(input("请输入一个整数： "))def test2(): return test1()#只在主函数中增加异常捕获try: print(test2())except Exception as result: print("未知错误 %s" % result) 输入0 请输入一个整数： 0 执行结果 1未知错误 division by zero 成功捕获异常并处理 主动抛出异常 当前函数只负责某项功能，主动抛出异常后，让其他函数再处理 主动抛出异常的方法 创建一个Exception对象 使用raise关键字抛出异常对象 实例 1234567891011121314def test(): num = int(input("请输入一个整数： ")) if num &gt; 0: return 10/num #主动抛出异常 exception = Exception("请不要输入0") raise exception#只在主函数中增加异常捕获try: print(test())except Exception as result: print(result) 输入0 请输入一个整数： 0 执行结果1请不要输入0]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式是为了可重用代码，让代码易于理解，保证可靠性 目的 让类创建的对象，在系统中只有惟一的一个实例 每一次执行类名()返回的对象，内存地址是相同的 __new__方法 创建对象时，首先会使用__new__方法为对象分配内存空间 __new__方法： 在内存中为对象分配空间 返回对象的引用 python解释器获得对象的引用之后，将引用作为第一个参数，传递给__init__方法 重写__new__方法的代码非常固定 __new__是一个静态方法，调用时需要主动传递cls参数 重写__new__一定要`return super().new(cls) 否则解释器得不到分配了空间的对象引用，就不会调用__init__方法12345678class A(object): def __new__(cls, *args, **kwargs): print("分配空间") def __init__(self): print("创建对象")a1 = A()print(a1) 执行结果 12分配空间None 可见自动执行了__new__而没有执行__init__，且a1没有内存空间 python中的单例 定义一个类属性，初始值是None，用于记录单例对象的引用 重写__new__方法 如果属性is None，调用父类的方法分配空间，并在类属性中记录结果 返回类属性中记录的对象引用1234567891011121314151617class A(object): # 创建类属性记录对象引用 instance = None # 重写__new__ def __new__(cls, *args, **kwargs): #判断是否为空对象 if cls.instance is None: # is None则分配空间 cls.instance = super().__new__(cls) #返回对象引用 return cls.instancea1 = A()a2 = A()print(a1)print(a2) 运行结果12&lt;__main__.A object at 0x7f701d71e690&gt;&lt;__main__.A object at 0x7f701d71e690&gt; 可见a1与a2地址是相同的，是同一个对象 只执行一次初始化 上例中每创建一个对象就会调用一次__init__ 设立类属性标志位，在__init__中判断 12345678910111213141516171819202122232425class A(object): # 创建类属性记录对象引用 instance = None init_flag = False # 重写__new__,静态方法需要传入cls以访问类属性 def __new__(cls, *args, **kwargs): #判断是否为空对象 if cls.instance is None: # is None则分配空间 cls.instance = super().__new__(cls) #返回类属性 return cls.instance def __init__(self): # 使用类名.的方式访问类属性 if A.init_flag: return A.init_flag = True print("初始化")a1 = A()a2 = A()print(a1)print(a2) 运行结果 123初始化&lt;__main__.A object at 0x7f1aa35baa50&gt;&lt;__main__.A object at 0x7f1aa35baa50&gt; 只被初始化了一次]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类属性，类方法，静态方法]]></title>
    <url>%2F2019%2F09%2F05%2F%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[类的结构 实例 创建出来的对象叫实例 创建对象的动作叫实例化 对象的属性叫做实例属性 对象调用的方法叫实例方法 每一个对象都有自己独立的内存空间，保存各自不同的属性 多个对象的方法，在内存中只有一份，调用方法时，需要把对象的引用传递到方法内部 类是特殊的对象 python中一切皆对象 class A定义的类属于类对象 aa = A()属于实例对象 在程序运行时，类也会被加载到内存 类对象在内存中只有一份，使用一个类可以创建出很多对象实例 除了实例的属性和方法外，类对象还可以拥有自己的属性和方法 类属性 类方法 通过类名.的方式可以访问 类属性和实例属性使用 类属性旧式给类对象定义的属性，通常用它来记录与这个类相关的特征 123456789class A(object): count = 0 def __init__(self): A.count += 1a1 = A()print(A.count)a2 = A()print(A.count) 执行结果 1212 属性获取机制 访问属性有两种方式 类名.类属性 对象.类属性（不推荐） 在python中使用对象.属性时 先从对象内部查找对象属性，如果没有就会向上寻找类属性 上例中也可写作 12print("a1.count")print("a2.count") 不要使用对象访问类属性 使用对象.类属性的方式给类属性赋值时，会给添加一个属性，不会影响到类属性 123456789class A(object): count = 0 def __init__(self): A.count += 1a1 = A()a1.count = 5print(A.count)print(a1.count) 执行结果 1215 类方法 定义类方法 123@classmethoddef 类方法名(cls): pass 可以使用cls.访问类的属性和方法 静态方法 在开发时既不需要访问实例属性和实例方法，也不需要访问类方法和类属性，就可定义为静态方法 语法如下 123@staticmethoddef 静态方法名(): pass 方法名后面直接跟()，不需要加self或cls 通过类名.静态方法调用 12345class A(object): @staticmethod def test(): print("hello")A.test() 执行结果 1hello]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_多态]]></title>
    <url>%2F2019%2F09%2F05%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码灵活度 演示1234567891011121314151617class Dog(object): def play(self): print("跑跑跳跳")class Xtq(Dog): def play(self): #重写父类方法 print("飞到天上")class Person(object): def play_with_dog(self, dog): print("快乐玩耍") dog.play()wangcai = Dog() #普通狗旺财xiaotian = Xtq() #哮天犬xiaoming = Person()xiaoming.play_with_dog(wangcai) print("*"*30)xiaoming.play_with_dog(xiaotian) #使用方法不变，传入另一个对象 执行结果12345快乐玩耍跑跑跳跳******************************快乐玩耍飞到天上]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_继承]]></title>
    <url>%2F2019%2F09%2F05%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承：实现代码的重用，相同的代码不需要重复编写 继承语法12class 子类(父类): ... 继承的传递性：A继承自B，B继承自C，则A也拥有C的属性和方法 子类不能访问父类的私有属性或方法，但可以在父类方法中访问自身私有内容，子类调用该方法来间接访问 多继承 语法 12class 子类(父类1, 父类2): ... 注意：如果多继承中，不同的父类方法重名，则会优先使用继承顺序靠前的父类方法 123456789101112131415161718192021222324252627class A: def test(self): print("A--test") def demo(self): print("A--demo")class B: def test(self): print("B--test") def demo(self): print("B--demo")class C(A, B): passclass D(B, A): passprint("继承顺序是先A后B")cc = C()cc.test()cc.demo()print("继承顺序是先B后A")dd = D()dd.test()dd.demo() 运行结果 123456继承顺序是先A后BA--testA--demo继承顺序是先B后AB--testB--demo 尽管不会报错，但不利于程序的阅读和理解，所以尽量不要使用多继承，使用时，也尽量保证属性方法不重名 __mro__ 用于查看方法搜索顺序类名.__mro__ 如在上例中使用 12print(C.__mro__)print(D.__mro__) 输出结果 12(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class 'object'&gt;)(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;) 重写方法override 在子类中直接编写与父类中同名的方法即可 12345678910111213class Animal: def voice(self): print("叫") def eat(self): print("吃")class Cat(Animal): def voice(self): print("喵喵喵")tom = Cat()tom.eat()tom.voice() 运行结果 12吃喵喵喵 对父类方法进行扩展 调用父类方法 super().方法名 父类名.方法(self) 不推荐使用，因为当父类名改变时，语句也要改变 将上例中Cat 类中voice方法改成 12345class Cat(Animal): def voice(self): super().voice() #第一种方法调用父类方法 Animal.voice(self) #第二种方法 print("喵喵喵") 执行结果 1234吃叫叫喵喵喵 新式类和旧式类 新式类：以object 为基类的类，推荐使用 旧式类：不以object 为基类的类，不推荐使用 python3中默认使用object类作为基类，即python3中定义的类全部是新式类 python2中如果没有指定父类，不会使用object类作为基类 新旧类会影响方法搜索顺序保证python2与python3的统一，可以写作 12class 类名(object): ... 构造函数的继承 旧式类：父类名称.init(self,参数1，参数2，…) 新式类：super(子类，self).init(参数1，参数2，….) 123456789101112class A(object): def __init__(self, name): self.name = nameclass B(A): def __init__(self, name, age): #调用父类初始化方法 super(B, self).__init__(name) self.age = agebb = B("das", 17)print(bb.name)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python--面向对象_封装]]></title>
    <url>%2F2019%2F09%2F04%2Fpython-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[封装：根据职责，将方法 和属性 封装到一个类中 dir()函数 使用dir()可以查看一个对象所有的可用方法 12345def test(): """this is a example""" print("hello") print(dir(test)) #查看可用方法 运行结果 1['__bool__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] 使用这些方法 1print(test.__doc__) 运行结果 1this is a example 返回了函数注释信息 定义简单类-只包含方法定义类123456class 类名: def 方法1(self, 参数列表) pass def 方法2(self, 参数列表) pass 类名使用大驼峰命名法 命名，首字母大写 类中的方法第一个参数必须是self，没有参数也要写self 创建对象1对象变量 = 类名() 先给创建出的对象开辟内存空间，再使对象变量 指向该地址 多次创建会开辟不同的内存空间 使用print()可以查看：对象的类和内存地址 123456class Cat: def eat(self): print("i love fish")tom = Cat()print(tom) 输出结果 1&lt;__main__.Cat object at 0x7f9c62f67290&gt; 给对象增加属性 可以直接使用赋值语句，继续使用上个例子中创建的tom1tom.name = "汤姆" #这样tom就获得了一个name的属性 这种方式不推荐使用，应当把属性封装在类中 关于self 哪一个对象调用的方法，self就是哪一个对象的引用 12345678910class Cat: def eat(self): print("%s 爱吃鱼" % self.name)tom = Cat()jf = Cat()tom.name = "汤姆"jf.name = "加菲"tom.eat()jf.eat() 输出结果 12汤姆 爱吃鱼加菲 爱吃鱼 可见self.name 返回的是各自的属性 初始化方法 当使用类名创建对象时，自动执行 创建对象：在内存中分配空间 初始化：执行__init__方法，__init__是专门用来定义一个类具有那些属性的方法 自动执行__init__ 12345class Cat: def __init__(self): print("自动执行了__init__方法")tom = Cat() 输出结果 1自动执行了__init__方法 在初始化内部定义属性 在__init__ 内部使用self.属性名 = 属性初始值 就可以定义属性 定义属性后，使用类名创建的对象都将拥有该属性 123class Cat: def __init__(self): self.name = "tom" 这样创建的对象name 属性是相同的，若想创建的同时给对象指定不同的属性，可以给__init 加入参数 12345class Cat: def __init__(self, name): self.name = name tom = Cat("Tom") 内置方法和属性__init__ 初始化时自动调用 __del__ 当对象被从内存中销毁前，会自动调用__del__ 方法 123456789class Cat: def __init__(self, name): self.name = name print("%s被创建了" % name) def __del__(self): print("对象被销毁了")tom = Cat("TOM")print("*" * 30) 执行结果 123TOM被创建了******************************对象被销毁了 使用del 关键字可以删除对象123tom = Cat("TOM")del tomprint("*" * 30) 执行结果123TOM被创建了对象被销毁了****************************** 可以使用del 关键字可以调用__del__ 方法 __str__ python中使用print() 输出对象，默认返回类和地址 可以使用__str__ 自定义返回内容 __str 必须返回一个字符串 12345678class Cat: def __init__(self, name): self.name = name def __str__(self): return "i am %s" % self.nametom = Cat("TOM")print(tom) 执行结果 1i am TOM 一个对象的属性可以是另一个类创建的对象1234567891011121314class Cat: def __init__(self, name, mouse): self.name = name self.mouse = mouse def catch(self): print("%s抓住了%s" % (self.name, self.mouse.name)) class Mouse: def __init__(self, name): self.name = namejerry = Mouse("Jerry")tom = Cat("Tom", jerry)tom.catch() 执行结果1Tom抓住了Jerry None 关键字 当不知道给参数什么初值时，可以使用None，他表示一个没有方法和属性的空对象，是一个特殊的常量 可以给任意一个变量赋None12a = Noneself.name = None 身份运算符is 与is not 身份运算符用于比较两个对象的内存地址是否一致–是否是对于同一个对象的引用 在python中使用None 比较时，建议使用is 和is not is 与== 的区别 is 判断是否为同一个对象 == 判断值是否相等1234a = [1, 2, 3]b = [1, 2, 3]print(a == b)print(a is b) 运行结果 12TrueFalse 私有属性和私有方法 定义方法：在定义属性或方法时，在名字前增加两个下划线__ 私有属性：在对象的方法内部可以访问，在外界不能直接访问 12345678910111213141516class Cat: def __init__(self, name, mouse): self.name = name self.__mouse = mouse def __str__(self): if self.__mouse: # 在对象内部方法可以访问私有属性 return "yes" else: return "no"tom = Cat("Tom", True)print(tom.name)# print(tom.__mouse) 访问不到私有属性__mouseprint(tom) 执行结果 12Tomyes 伪私有属性和方法 在python中，实际上没有完全的私有，对于私有属性和方法，在外部可以通过在属性或方法名前加_类名(下划线加类名)的方法访问，但尽量不要使用 12345678910class Women: def __init__(self, name): self.name = name self.__age = 18 def __secret(self): print("%s 年龄是%d" % (self.name, self.__age))mary = Women("玛丽")print(mary._Women__age)mary._Women__secret() 执行结果 1218玛丽 年龄是18]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数的返回值 利用元组返回多个值 1234567def test(): num = 1 str = "hello" return (num, str) temp = test() #则temp是一个元组类型，对于不同的内容要使用对应索引调用，容易出错temp1, temp2 = test() #或使用多个变量接收返回值，方便管理 同理，可利用元组交换数据 12a, b = (b, a)a, b = b, a # =右边是省略括号的元组 形参与实参在函数内部对变量使用赋值语句，会在函数内部修改局部变量的引用，不会影响到外部变量的引用1234567891011121314def test(num, my_list): print("函数内部：") #赋值 num = 10 my_list = [4, 5, 6] print(num) print(my_list) g_num = 5g_list = [1, 2, 3]test(g_num, g_list)print("执行完成后")print(g_num)print(g_list) 执行结果123456函数内部：10[4, 5, 6]执行完成后5[1, 2, 3] 实参未改变，其原因是变量与数据是分开存储的，g_num 指向数据5 的地址，当将g_num传入test函数是，实则是传入了数据5 的地址，而当使用赋值语句时，局部变量num指向新的数据10 ，但g_num仍然指向5 如果传入的是可变类型，在函数内部使用方法修改了数据内容，会同时修改外部数据12345678def test1(my_list): print("函数内部：") my_list.append(9) print(my_list)g_list = [1, 2, 3]test1(g_list)print("程序结束：%s" % g_list) 输出结果123函数内部：[1, 2, 3, 9]程序结束：[1, 2, 3, 9] 可见外部参数也被修改，其原因是使用数据的自身方法不会创建新的数据，而是在原有数据上的修改，外部变量和局部变量同时指向该地址，因而在函数内部使用方法修改后会影响外部参数 +=对于不可便类型是先相加后赋值，对于可变类型实质上是调用extend()方法123456789101112def test2(num, my_list): num += 10 print("不可变类型函数内部+=结果%d" % num) my_list += [8] print("可变类型函数内部+=结果%s" % my_list)g_number = 5g_l1 = [1, 2, 3]test2(g_num,g_l1)print("不可变类型外部结果%d" % g_number)print("可变类型外部结果%s" % g_l1) 运行结果1234不可变类型函数内部+=结果15可变类型函数内部+=结果[1, 2, 3, 8]不可变类型外部结果5可变类型外部结果[1, 2, 3, 8] 可见前者外部未改变，后者外部改变 给函数添加缺省值 在函数定义时可在参数后面加= 并添加缺省值 1234567891011121314def test3(name, gender=True): #True是gender的缺省值 """ 输入姓名和性别 :param name: 姓名 :param gender: 性别 True男生 False女生 :return: null """ gender_text = "男生" if not gender: gender_text = "女生" print(name+"是"+gender_text)test3("小明") #gender未输入，则使用缺省值test3("小美", False) #指定gender 输出结果 12小明是男生小美是女生 注意：带有缺省值的参数必须放在参数列表的末尾 当有多个缺省参数而需要指定特定的某个参数值时，需要同时输入参数名 123456789def test4(name, gender=True, grade="大一"): #代码块 ...#如果指定gendertest4("小美", False)#如果指定gradetest4("小明", grade="大二") 多值参数 有时一个函数传入的参数个数是不确定的，这个时候就可以使用多值参数 python中有两种多值参数 参数名前加一个 *可以接收元组 参数名前加两个 * 可以接收字典 一般给多值参数命名时，习惯使用以下名字 *args – 存放元组 arguments(变量) **kwargs –存放字典 kw是keyword123456def demo1(num, *args, **kwargs): print(num) print(args) print(kwargs)demo1(1, 2, 3, 4, 5, name="小明", age=18) #这种写法无须拆包 键不需要加分号，并用=连接 输出结果1231(2, 3, 4, 5)&#123;'name': '小明', 'age': 18&#125; 元组和字典的拆包 在调用有多致参数的函数时，如果希望 将元组直接传给args 将字典直接传给kwargs 就可以使用拆包 在元组变量前加一个* 在字典变量前加两个 * 12345678def demo2(*args, **kwargs): print(args) print(kwargs)g_nums = (1, 2, 3)g_dict = &#123;"姓名":"小明", "age":18&#125;demo2(g_nums, g_dict)demo2(g_nums, **g_dict) 运行结果1234((1, 2, 3), &#123;'姓名': '小明', 'age': 18&#125;)&#123;&#125;((1, 2, 3),)&#123;'姓名': '小明', 'age': 18&#125; 可见前者字典也被传给了args，与期望不符，而后者加了** 实现预期]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中关于全局变量]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[python中不允许直接修改全局变量的值 1234567891011num = 1 #定义全局变量def test1(): num = 2 print(num)def test2(): print(num)test1()test2() 按照其他语言的逻辑，全局变量在test1()中被修改为2，则在test2()中也输出2，而最终的输出结果是 1221 并未如所想，其原因是python不允许直接修改全局变量的值，如果使用赋值语句，会在函数内部创建一个同名局部变量，而此局部变量在函数执行完成后就会被系统回收 全局变量的修改 使用global 声明变量即可 123456789101112num = 1 #定义全局变量def test1(): global num num = 2 print(num)def test2(): print(num)test1()test2() 输出结果 1222 什么时候使用global 当对全局变量的指向进行修改的时候，需要使用global修饰，如果指向没有改变，则不需要，如：123456789101112131415161718num = 10num_list1 = [11, 22]num_list2 = [11, 22]def main(): global num global num_list2 num = 20 # 改变指向，需要声明 num_list1.append(33) # 不改变指向，不需声明 num_list2 += [33, 44] # 执行+=必须要声明global，因为这也是需要改变指向的操作，如果未声明程序就会崩溃if __name__ == "__main__": main() print(num) print(num_list1) print(num_list2) 运行结果 12320[11, 22, 33] # 使用append()方法没有改变指向，成功达到预期执行结果[11, 22, 33, 44] 全局变量的命名 可以在全局变量前加g_ 或gl_ 的前缀]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的高级数据类型]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[获取元素类型 123# 使用type()获取数据类型my_list = [1, 2, 3]print(type(my_list)) 列表 类似于其他数据类型中的数组 列表使用[]括起来 列表中可以存储不同类型的数据类型 1234567891011121314151617181920212223242526my_list = ["aaa","bbb","ccc"]print(my_list[0]) #取值print(my_list.index("aaa")) #取索引my_list[0] = "ddd" #修改my_list.append("eee") #增加数据my_list.insert(1,"fff") #插入数据在my_list[1]，后面的数据后移temp_list = ["a","b"]my_list.extend(temp_list) #将另一个列表扩展进来my_list.remove("bbb") # 删除指定元素,如果出现多次，删除第一个my_list.pop() #默认删除最后一个元素（出栈）my_list.pop(3) #删除my_list[3]my_list.clear #清空列表del my_list[1] #利用del删除（直接从内存中删除，后续代码不可使用该变量）a = 10del alength = len(my_list) #读取列表大小time = my_list.count("aaa") #读取aaa出现的次数my_list.sort() #升序排序my_list.sort(reverse=True) #降序排序my_list.reverse() #逆序反转 迭代遍历12for temp_name in my_list: print("the name is %s" % temp_name) 创建列表的方式 基本语法 1my_list = [1, 2, "hello"] list()创建 1234my_list1 = list("abcde")my_list2 = list(range(1, 10, 2))print(my_list1)print(my_list2) 结果 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;][1, 3, 5, 7, 9] 利用range()可以快速创建整数列表，其格式为range([start,] end [,step])，它返回的是一个range对象 start：起始数字，默认0end：结尾数字，必须指定step：步长，默认1 推导式生成列表12345678my_list3 = [x*2 for x in range(5)]my_list4 = [x**2 for x in range(50) if x%5==0]my_list5 = [(x, y) for x in range(5) for y in range(5) if x%2==0 if y%3==0]my_list6 = [a for a in "hello"]print(my_list3)print(my_list4)print(my_list5)print(my_list6) 结果 1234[0, 2, 4, 6, 8][0, 25, 100, 225, 400, 625, 900, 1225, 1600, 2025][(0, 0), (0, 3), (2, 0), (2, 3), (4, 0), (4, 3)]['h', 'e', 'l', 'l', 'o'] 元组 元组与列表相似，不同之处在于元组的元素不能修改 使用() 定义 1234567891011# 定义空元组empty_tuple = ()# 定义单元素元组single_tuple = (5) #这样定义得到的single_tuple是int类型single_tuple = (5,) #正确my_tuple(1) # 取值my_tuple.index("aaa") #取索引my_tuple.count("aaa") #统计aaa出现次数len(my_tuple) #统计长度 遍历元组 123for temp_info in my_tuple: 执行代码 ... 元组的应用 拼接字符串 12345my_tuple = ("zhangsan", 18, 175.5)print("%s的年龄是%d,身高是%f" % my_tuple)my_str = "%s的年龄是%d,身高是%f" % my_tupleprint(my_str) 保护列表安全 123my_list = [1, 2, 3, 4]my_tuple1 = tuple(my_list) #使用tuple()将list转换成tuplemy_list2 = list(my_tuple1) #使用list()将tuple转换成list 利用元组返回多个值(同理也可使用列表，字典，集合) 1234567def test(): num = 1 str = "hello" return (num, str) temp = test() #则temp是一个元组类型temp1, temp2 = test() #多个变量接收返回值 交换数字 1a, b = (b, a) 生成器推导式生成元组12345678my_tp1 = (x*2 for x in range(5))my_tp2 = (x**2 for x in range(50) if x%5==0)# 打印生成器print(my_tp1)print(my_tp2)# 打印生成的元组，注意只能调用一次tuple()print(tuple(my_tp1))print(tuple(my_tp2)) 结果 1234&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc850&gt;&lt;generator object &lt;genexpr&gt; at 0x7fb5bd8cc8d0&gt;(0, 2, 4, 6, 8)(0, 25, 100, 225, 400, 625, 900, 1225, 1600, 2025) 字典 使用{}定义 列表是有序的数据集合 字典是无序的数据集合 使用键值对存储数据 键 (key) 是索引，必须唯一 ，只能是字符串，数字，或者元组 值 (value) 是数据，可以是任意数据类型 key 和value 之间使用: 分隔 123456789101112131415161718192021# 由于字典无序，通常使用print()打印的结果与定义的顺序不同#定义xiaoming = &#123;"name": "小明", "age": 18, "height": 175&#125; xiaoming["name"] #取值xiaoming["weight"] = 70 #不存在则增加xiaoming["age"] = 19 #若存在则修改xiaoming.pop("weight") #删除len(xiaoming) #统计键值对数目temp_dict = &#123;"gender": boy, "age": 20&#125;xiaoming.update(temp_dict) #若新增key不存在，则增加;若key重复，则会替换掉之前的valuexiaoming.clear() #清空xiaoming. 遍历字典 123456my_dict = &#123;"name": "zhangsan", "age": "18"&#125; # 变量temp是my_dict中的keyfor temp in my_dict: print("%s - %s" % (temp,my_dict[temp])) 应用先用字典存储复杂数据，再将多个字典放在一个列表中管理 123456789card_list = [ &#123;"name": "zhangsan", "qq": "12345"&#125; &#123;"name": "lisi", "qq": "12412"&#125;]for info in card_list: print(info) 创建字典的几种方式 使用{}基本语法 1my_dict1 = &#123;"name":"张三", "age":28&#125; 使用dict()方法 12my_dict2 = dict(name="张三", age=18)my_dict3 = dict(("name", "张三"), ("age", 18)) 使用zip() 1234my_key = ["name", "age", "job"]my_value = ["张三", 18, "teacher"]my_dict4 = dict(zip(my_key, my_value))print(my_dict4) 运行结果 1&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;job&apos;: &apos;teacher&apos;&#125; 通过fromkeys创建值为空的字典12my_dict5 = dict.fromkeys(["name", "age", "job"])print(my_dict5) 结果 1&#123;&apos;name&apos;: None, &apos;age&apos;: None, &apos;job&apos;: None&#125; 字典推导式1234# 利用推导式统计字符出现次数my_text = "hello, world"my_dict6 = &#123;my_char:my_text.count(my_char) for my_char in my_text&#125;print(my_dict6) 结果 1&#123;'h': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1&#125; 集合 集合无序可变，元素不能重复，集合底层是字典实现，集合中的元素都是字典中的键对象，因此不可重复 使用{}创建集合对象，并使用add()添加元素 12a = &#123;"name", "age", 3, 5&#125;a.add(9) 使用set()可以将列表，元组等可迭代对象转化为集合，如果数据重复，只保存一个 123a = ["a", "b", "c", "a"]b = set(a)print(b) 结果 1&#123;'a', 'c', 'b'&#125; remove()删除指定元素，clear()清空集合 12a.remove("a")a.clear() 集合相关操作 1234567891011a = &#123;1, 2, 3&#125;b = &#123;2, "a", "c"&#125;# 并集print(a|b)print(a.union(b))# 交集print(a&amp;b)print(a.intersection(b))# 差集print(a-b)print(a.difference(b)) 结果 123456&#123;1, 2, 3, 'a', 'c'&#125;&#123;1, 2, 3, 'a', 'c'&#125;&#123;2&#125;&#123;2&#125;&#123;1, 3&#125;&#123;1, 3&#125; 字符串12345678910111213141516171819202122232425262728# 字符串定义：使用''或""括起来的内容str1 = "hello"str2 = 'world' #为了和其他语言统一，尽量不使用单引号#当需要字符串中包含引号时str3 = "my name is "dgs"" #错误str4 = 'my name is "dgs"' #正确#取值str = "abcdefabcbac"str[2] #第三个字符str[-1] #倒数第一个字符#迭代遍历for temp in str: print(temp)len(str) #统计长度str.index(”e“) #获取索引str.count(”a“) #统计a出现的次数# 字符串切片 字符串[开始索引:结束索引:步长]，不包含结尾处索引的内容str[2:6] #截取第二个到第六个str[2:] #从第二个到末尾str[2:-1] #从第二个到倒数第一个str[:6] #从开头到第六个str[::2] #每隔一个截取一个str[-1::-1] #获得字符串倒序 公共方法 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式del(temp[1]) /del(temp) max(item) 返回容器元素最大值 字典只比较key min(item) 返回容器元素最小值 字典只比较key cmp(item1, item2) 比较两个值，-1 小于，0 等于，1 大于 python3取消了cmp 字符串比较遵循：0 &lt;A &lt;a 切片123l1 = [1, 2, 3, 4, 5][::2]t1 = ("s", 2, "hello", 4, 5)[::2]# 字典不能切片 运算符 运算符 演示 结果 描述 支持类型 + [1, 2]+[3, 4] [1, 2, 3, 4] 合并 字符串，列表，元组 * (“hi”)*3 (“hi”,”hi”,”hi”) 重复 同上 in 3 in (1, 2, 3) True 是否存在，字典判断key 字符串，列表，元组，字典 not in 4 not in (1, 2, 3) True 是否不存在，字典判断key 同上 &lt; &gt; 等 (1, 2, 3)&lt;(2, 3, 4) True 比较 字符串，列表，元组 + 与entend() 方法的区别：前者生成一个新的变量，后者追加到调用该方法的变量 append()与extend()区别 12345678l2 = [1, 2, 3]l2.append(4)print(l2)# 不能l2.extend(5)，extend()只能传入容器l2.append([6, 7])print(l2)l2.extend([8, 9])print(l2) 输出结果 123[1, 2, 3, 4][1, 2, 3, 4, [6, 7]] # 将append([6, 7])当成了一个元素[1, 2, 3, 4, [6, 7], 8, 9] # 将extend([8, 9])追加 完整的for循环1234for 变量 in 集合: 循环体代码else: 没有通过break退出循环，遍历结束后就会执行 应用遍历完成后，如果没有查询的就提示 其他 对变量使用自身的方法进行增删改不会改变id，而重新赋值会改变，这时它的指针指向了另一个地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的一些基础知识]]></title>
    <url>%2F2019%2F09%2F03%2Fpython%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[python的运算符 与C,java等不同 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 and 与 a &gt;= 1 and a &lt;= 4 or 或 a &gt; 1 or a &lt; 10 not 非 not a &lt; 1 += -= *= /= %= //= **= 赋值运算 a+=1等同于a=a+1 查看关键字12import keywordprint(keyword.kwlist) 语法if123456if a==1: print("aaa")elif a==2: print("bbb")else: print("ccc") if后面可以接布尔运算，数字，字符串，列表，元组，字典等，为真的条件是这些元素为True，非0，非None 条件分行1234# 使用()将条件括起来，在布尔运算符前可分行if((a == 1 and b == 2) or (a ==2 and b ==3)): print("test") while12while 条件: 执行代码 定义函数12345# 定义的函数要在使用前声明def 函数名(param1,param2): 封装代码 ... return res 注释12345678910111213141516# 单行注释"""这是多行注释"""# 在函数下方缩进后使用连续的三个'或“可以给函数编辑注释# 如果此时直接按回车会生成带参数描述的文档注释# 并且之后调用时可以使用Ctrl+Q快速查看def test(): '''this is a test example''' print("hello") # TODO(作者/邮件) 这是TODO注释，提醒接下来要做的工作，可以在pycharm左下角找到所有TODO项 print 数字和字符串输出 12age = 10print("you are %d" % age) 多个数字和字符串输出 1234num1 = 10num2 = 20num3 = 10.5print("the number is %d , %d and %f" % (num1,num2,num3)) #实际上这是元组的应用 %d是以十进制输出，可用%x以十六进制输出 使print不换行 123456# print()方法默认是在尾部添加了换行符，而如果不想换行可以加,end=""print("hello",end="")print("world")# 其他使用print("hellp",end="***") 连续输出相同内容 1print("*" * 50) #连续输出50个* 控制台输入1input("请输入：") 控制台输入的内容是字符串，如果需要用于判断，则 1a = int(input("请输入")) 生成随机数12import randomrandom.randint(10, 20) #生成10-20间的随机整数 导包 使用import关键字导入模块，所有以.py结尾的文件都可以看作一个模块 模块不能使用数字开头 pyc文件 当使用import导入模块并编译后，会在编译文件夹中生成.pyc文件，这是使用cpython编译出的二进制文件，使得每次使用模块不需要反复解释，以提高执行性能 跳过 如果写了判断或其他情况暂时不写某些代码时，可以使用pass 充当占位符，使编译器不报错 123456my_list = ["1", "2", "3"]num = input("please input:")if num in my_list: passelse: pass shebang符号 #! 是shebang符号，他后面加上解释器的路径即可在终端下通过输入文件地址而直接运行，且不影响在pycharm中运行1#! /usr/bin/python3 id id(变量/数据) 查看其内存地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这一年--在武大智能车]]></title>
    <url>%2F2019%2F09%2F01%2F%E8%BF%99%E4%B8%80%E5%B9%B4-%E5%9C%A8%E6%AD%A6%E5%A4%A7%E6%99%BA%E8%83%BD%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[此刻 坐在电脑前，也许应该点燃一支烟，吸一口，神清气爽，念天地之悠悠，吐一口，烟云缭绕，独怆然而涕下。于烟云之端，闭上双眼，追古溯今，回味这身于其中恨其长，蓦然回首已惘然的一年。 可是，我不会抽烟。 所以，我不能在烟云中幻想，只能在现实中回望。 回忆起来，尽管最终结果平平，但它仍旧不同以往，给大学生活添上了不寻常的一笔。 一 冬天的枝叶败落后，又在春天绿意盎然，如是想想，我也应该走出决赛失利的阴霾中，好好记录下这一年的高兴与惆怅，开怀与彷徨。 从大一的那个暑假走来，转眼一年多过去了，校内赛前能装实验室汗流夹背的景象回想起来，仿佛就在昨天，那个时候想必是这一年最难熬的吧。周围都是陌生的面孔，大家都为了入队而不断学习。两个月的时间里，很多人坚持不下去走了，但更多的坚持了下来，走过11月的校内赛，成功进入智能车这个大家庭。 那段时间应当感谢与我同行的两个同学，赵富强和雷飞，不如就合称赵雷吧，哈哈，感谢“赵雷“的陪伴，和赵雷的歌曲，陪我一步一步迈过那两个月的时光。 二 校内赛后，我选择了节能组，并负责软件部分，但由于组别的特殊性，我们组所有人都负责结构设计，华南赛前我花在结构设计上的时间甚至多于调试程序的时间。 也许那个时候方向真是错了，也因此，每次开会，我们组都是被点名的那个。 前后花了几个月，多方咨询，多次改稿，最终还真的设计出了一款机械能的车模。 然而，由于零件难以找到合适的，且直观感觉它并不会节省能量，最终在四月份刚拼起来就被舍弃，前功尽弃–想想有些可惜。 这样，我们开始专心搭纯电履带车，我专心负责程序编写。 之前只是大概写了个框架，没有几个月就要比赛了，那时候我有些慌了，尤其是在圆环的处理上，由于车身晃动太大和程序鲁棒性太差，总是出现各种问题，要不识别不到，要不识别过早，或者进去出不来，总之，问题百出。 即使是华南赛就要来临，即使我们天天熬夜，但成功率仍旧不高，那个时候甚至一度怀疑是否能挺过华南赛，是不是拿个华二就结束了… 然而，我也不敢大改程序，怕这一改便成仁了… 三 七月，空气中弥漫着潮湿的味道，智能车队整装出发。我们组内调侃：去旅个游就放假啦，好开心。 不过我心里其实还存有一丝侥幸，10多分钟，总能成功的吧。 试车：路障过不去，有些慌了 预赛：电感坏了，心想凉了，还好临时修好，一次成功 决赛：一次成功 结果如我所愿，成功狗过华南赛，还拿了个第二名的成绩，但可以看出来，不论结构和程序都很不稳定。 华南赛后合照 那几天的长沙天气不错，我们三五成群，晚上就出去逛街，喝过了网红饮品茶颜悦色，吃过了毛主席都爱吃的长沙臭豆腐，也算不虚此行。 和帅哥茶颜悦色打卡 哦，对了，张老师摔得那下有点惨0.0当时都吓到我们了 四 华南赛回来后，我决定重写程序，花了差不多十天左右的时间写完，调试。改完之后感觉良好，比之前的稳定很多，速度也从1.5提高到了1.68左右，用电池跑的时候，经常可以一次性跑五六圈都没有问题。 但是不知道为什么，每辆车刚搭出来表现不错，越跑就越变的不尽如人意了，只能降低速度，但我想这不应该是程序的问题，试了试其他样式的履带，结果一般，最终没有改动车体结构，也没有去深究这个问题。 剩下的二十天我调车的时间就下降了，和队里大部分人一样开始了养老生活。 转眼间，就从珞珈山下踏到了渤海之边。 五 我们走过了沙滩，趟过了海浪，挖过了拖鞋，埋过了雷飞…然而我只想问：海边为什么都是中年油腻大爷大妈，和我想象的不太一样啊… 我们在海滩 快乐的玩耍 比赛时，唉不想说了，一上场就发现和在实验室的差异了，实验室赛道较光滑，而威海的赛道摩擦力太大，以至于每次转弯车都要跳两下，出环岛时也不像在实验室那样顺滑，我在旁边胆战心惊。 而预赛的下午场和决赛，又出现了莫名其妙的问题，好几次在直道弯道处就撞上路障夭折了…这种情况在实验室从未出现过，还有一次刚到路障直接停车了，不明所以，事后我们组觉得可能是车硬件有问题，但那块板子自从按上以后我每天只是稍微跑跑，所以没有暴露出来，而当在国赛时显露出来，也来不及补救了。 于是最终拖了十四届的后腿，成为了唯一一个二等奖项。 嘤嘤嘤 … 总结 这一年无论结果如何，也伴着专老师的点拨，张老师的关怀，杨老师的鸡汤和整个车队的陪伴走过去了。这一年终将永久存留于每位十四届智能车队员的心中，并在未来珍藏，回味，历久弥新… 最后，盛年不重来，我们JinMaMen见吧！(滑稽)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>智能车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2019%2F08%2F30%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法 标题123# 一级标题## 二级标题### 三级标题 n#+文字 n级标题 字体1234567**粗体***斜体*==高亮==***斜体加粗***~~删除线~~^上标^~下标~ 列表无序标题 使用”*”或者”+”后面跟空格，按一下回车会自动加标题，按两下会消失 eg： 12345- 一二三四五- 上山打老虎 - 下一级为空心圆 - 再下一级是实心方块 - 之后都是实心方块 效果 一二三四五 上山打老虎 下一级为空心圆 再下一级是实心方块 之后都是实心方块 有序标题与word类似 121. 一级2. 二级 效果 一级 二级 表格第二行要有连字符 123| 姓名 | 学号 | 专业 | 班级 ||------|------|------|------|| 张三 | 037 | 机械 | 四班 | 效果 姓名 学号 专业 班级 张三 037 机械 四班 引用12&gt; 大于号加引用内容&gt;&gt; 二级引用，可多级 效果 大于号加引用内容 二级引用，可多级 分割线使用连字符，上一行不能有字符 12345 上文------ 下文 效果 上文 下文 代码单行代码使用``将代码括起来 1`print("hello") ` 多行代码123System.out.println("hello");System.out.println("hello");System.out.println("hello"); 链接1234561. &lt;http://www.baidu.com&gt;2. [百度](http://www.baidu.com)3. 我经常用[百度][1]搜索，很少用[必应][2][1]:http://www.baidu.com/ &quot;Baidu&quot;[2]:http://www.bing.com/ &quot;Bing&quot; 效果 http://www.baidu.com 百度 我经常用百度搜索，很少用必应 图片1![狮子](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=435466660,1319228756&amp;fm=26&amp;gp=0.jpg &quot;this is a lion&quot;) 百度地图 网址http://api.map.baidu.com/lbsapi/creatmap/index.html 注意要在html文件中加&lt;meta charset=&quot;UTF-8&quot;&gt;限定编码格式，否则可能乱码 1&lt;iframe src=&quot;~/Markdown/map.html&quot; width=&quot;600&quot; height=&quot;300&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; html,body{margin:0;padding:0;} .iw_poi_title {color:#CC5522;font-size:14px;font-weight:bold;overflow:hidden;padding-right:13px;white-space:nowrap} .iw_poi_content {font:12px arial,sans-serif;overflow:visible;padding-top:4px;white-space:-moz-pre-wrap;word-wrap:break-word} L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":175,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"log":false}); //创建和初始化地图函数： function initMap(){ createMap();//创建地图 setMapEvent();//设置地图事件 addMapControl();//向地图添加控件 addMarker();//向地图中添加marker addPolyline();//向地图中添加线 addRemark();//向地图中添加文字标注 } //创建地图函数： function createMap(){ var map = new BMap.Map("dituContent");//在百度地图容器中创建一个地图 var point = new BMap.Point(114.368076,30.543335);//定义一个中心点坐标 map.centerAndZoom(point,17);//设定地图的中心点和坐标并将地图显示在地图容器中 window.map = map;//将map变量存储在全局 } //地图事件设置函数： function setMapEvent(){ map.enableDragging();//启用地图拖拽事件，默认启用(可不写) map.enableScrollWheelZoom();//启用地图滚轮放大缩小 map.enableDoubleClickZoom();//启用鼠标双击放大，默认启用(可不写) map.enableKeyboard();//启用键盘上下左右键移动地图 } //地图控件添加函数： function addMapControl(){ //向地图中添加缩放控件 var ctrl_nav = new BMap.NavigationControl({anchor:BMAP_ANCHOR_TOP_LEFT,type:BMAP_NAVIGATION_CONTROL_LARGE}); map.addControl(ctrl_nav); //向地图中添加缩略图控件 var ctrl_ove = new BMap.OverviewMapControl({anchor:BMAP_ANCHOR_BOTTOM_RIGHT,isOpen:1}); map.addControl(ctrl_ove); //向地图中添加比例尺控件 var ctrl_sca = new BMap.ScaleControl({anchor:BMAP_ANCHOR_BOTTOM_LEFT}); map.addControl(ctrl_sca); } //标注点数组 var markerArr = [{title:"终点",content:"come",point:"114.371444|30.545357",isOpen:1,icon:{w:21,h:21,l:46,t:46,x:1,lb:10}} ]; //创建marker function addMarker(){ for(var i=0;i]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F08%2F30%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git版本创建 1234git init //初始化git仓库git add . //添加全部修改git add 文件名 //添加指定文件的修改git commit -m "说明信息" //提交并添加备注 查看信息1git log //查看版本信息 1git status //查看修改信息 版本回退 HEAD指针会指向最新的版本 HEAD^指向上一个版本 HEAD^^指向上上个版本… 或者使用HEAD~n代表前n个版本 12git reset --hard HEAD^ //回退到上一个版本git reset --hard HEAD~3 //回退到之前3个版本]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git快速入门]]></title>
    <url>%2F2019%2F08%2F29%2Fgit%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git init 将当前文件下变为git仓库 git status 查看git仓库的状态 git add 12git add 文件 #添加指定文件的修改git add . #添加所有文件的修改 git diff 显示文件修改信息 git reset 退回追踪 git config 1234git config --global user.name "zhangsan" #配置用户名git config --global user.email "example@qq.com" #配置邮箱git config --global core.editor vim #配置默认编辑器git config credential.helper store #在执行`push`前输入这段命令，会使git记住用户名和密码，之后就不用再输入 git commit 12git commit #会打开编辑器，可输入描述信息git commit -m "some text" #提交更改并添加描述信息 让git忽略管理某些文件 1vim .gitignore #创建此文件，并在其中编辑要忽略的文件名即可 在该列表中添加的文件必须是从未被追踪过的，否则git将继续追踪该文件 git rm 1git rm --cached 文件 #让git停止追踪该文件 分支 123456git branch #显示分支列表git branch test #创建一个名为test的分支git checkout test #切换到test分支git merge test #将test分支添加到mastergit branch -d test #删除test分支，未添加的分支不可删除git branch -D test #强制删除test分支 推到github 首先去github创建一个新的仓库，并复制链接，假设为https://.../abc.git 12git remote add origin https://.../abc.git #告诉git你在网上的仓库位置git push --set-upstream origin master #将master提交到github（需要输入用户名和密码） 发送合作邀请 在github的仓库中setting–&gt;Collaborators–&gt;搜索用户–&gt;点击发送邀请至邮箱 复制文件 1git clone https://.../abc.git #复制仓库至本地，`.gitignore`中的文件不会被下载 git pull将github上更改过的文件下载到本地]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端指令]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%BB%88%E7%AB%AF%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[some tips Tab can auto compelete command Ctrl+c can stop the command or clear your input(终止命令或清空刚才的输入–命令较长时backspace太慢) the command formatcommand [-options] [parameter] instructions command: command name [-options]: control the command, it can be omited [parameter]: maybe only one, or two, or three… []: means optional basic command command word function ls list view the contents of the current folder pwd print work directory view current position cd [directory] change directory move to the specified directory touch [file name] touch create new file(s) mkdir [directory] make directory create new directory rm [file name] remove remove empty file(s) clear clear clean the screen view help information command --help man command(means manual) files and directory commands hidden files if the file begin with a dot . it is a hidden file . and.. . means this level directory.. means upper level directory ls options word function -a all display all files(including hidden files) -l list list display files (first letter isd:dir; -: file) -h display file size(Kb), it must be used with -l (ls -lh) wildcard character(通配符) symbol meaning * represents any number of characters(任意个数字符) ？ represents one character [] give some choices examples * ls a* display files begin with als *a.txt display files end with a.txtls *a* display files contains a ** ? ls ?a?.txt display files like 1a1.txt ** [] ls [abcde]ab.txt display files like aab.txt orbab.txt and so onls [a-f]ab.txt display files begin with abcdef like eab.txt cd absolute path specific path from the root directory or home directory(从根目录或家目录开始的具体路径)example:/home/duguosheng/Desktop/ relative path the path from current directory examples:../Desktop/ command function cd go back to the current user home directory cd ~ just likecd cd . keep in the current directory cd .. go to the parent directory cd - switch back and forth between the last two directory touch (file)if the file doesn’t exist, the file will be createdotherwise, the last modification time of the file will be modified(否则会更改文件的末次修改时间) mkdircreate a new file mkdir -p a/b/c/d recursively create directories(递归创建目录) the directory name can’t be same as existing file or directory rm delete file or directory (can not be restore)(不可恢复) option function -r recursively delete directory(递归删除目录) -f forced deletion(强制删除) copy and move files or directoriestree [directory]display directories and files in a tree view tree ~ display files form home directory tree -d only display directories cp cp src dest copy file example: cp ~/Documents/test.txt . copy test.txt to current directory,if you want to change file name, you can writecp ~/a.txt ./b.txt option function -i promat before overwritting files(覆盖文件前提示) -r copy directory mvmove file or directory format: mv src dest example:mv test ~/Documents/ move test to Documents/ change file or directory name if src and dest are under the same directory, then it can be renamed overwrite file iftest1.txtandtest2have been existed, then input cp test1.txt test2.txt, after that, test1.txt will be renamed astest2.txt and original filetest2.txt will be deleted, this operation is unsafe cp -i src dest prompt before overwriting files view file contentcat(concatenate连接合并)format: cat (file) view all content of the file option function -b show line number(except blank lines) -n show line number(including blank lines) moreformat: more (file) view the beginning of the file operation function display next page display next row b go back f go forward q quit grepa text search tool(文本搜索工具) option function -n show line number(行号) -v show lines which don’t match(不匹配的所有行) -i ignore case(忽略大小写) example: grep as test.txt look for the letter as in the test.txt grep -n as test.txt look for the letter as in the test.txt and show the line number grep -v as test.txt look for lines that don’t contain the letter as in the test.txt param function ^a look for lines start with the letter a ke$ looke for lines end with ke other commandecho (some words) the words will show in the terminal, it is always used with redirect command echo hello &gt; a if a doesn’t exist, a will be created, and write hello inside file.(创建文件并指定内容) redirect &gt;and&gt;&gt; linux allows to redirect command execution results to a file(linux允许将命令执行结果重定向到一个文件) output/append the content that should be displayed on the terminal to the specified file(将本应显示在终端的内容输出/追加到文件中) &gt;: output, overwrite the file &gt;&gt;: append, append content to the file examples: echo helloworld &gt; a.txt echo ls -lh &gt; a.txt write the file list and their information to a.txt echo goodbye &gt;&gt; a.txt pipe | (管道) the output of a command can be input to another with pipe(一个命令的输出可以通过管道作为另一个命令的输入) | divides commands into left and right, left to write, right to read common commands more: spilt screen display content grep: search for the specified content in the command execution result(在命令执行结果中搜索指定内容) example: ls -lha ~ | more spilt screen view files and directories ls -lha ~ | grep aa display files with letter aa in its name shutdown/restartshutdown shutdown command can safely shut down or restart the system option function -r restart if the command has no options and parameters, it will turn off after 1 minute by default(默认一分钟后关机)when remotely maintaining the serve, you’d better restart rather than shut down. examples: shutdown -r now –&gt;restart now shut down now –&gt;shut down now shutdown 20:30 –&gt;shut down at 8:30pm shutdown +10 –&gt;shut down 10 minutes later shutdown -c –&gt;cancel last command with shutdown view and configure network card information(查看和配置网卡信息) command word function ifconfig configure a network interface view/configure the network card information ping (ip address) ping check the connection with target IP address is normal or not ifconfig in manjaro, use command ip addr instead of ifconfig a computer may have a physical network card and multiple virtual network cards (一台计算机中可能有一个物理网卡和多个虚拟网卡) view ip address: ifconfig | grep inet (ip addr | grep inet in mangaro ) ping ping (IP) ‘s working principle just like sonar(声纳), it sends out a packet, and the target IP addr returns a packet, the shorter the time, the faster the network speed(指令发出数据包，目标IP收到后返回一个数据包，这段时间越短，则网速越快) ping (IP) can check the target computer is open or not Romote login and copy files(远程登录和复制文件)Basics of SSH Based on the SSH Client and SSH Serve SSH Client is a software program connected to a remote computer with protocol Secure Shell(SSH) (SSH客户端是一种使用SSH协议连接到远程计算机的软件程序) Transmitted data is Encrypted(加密) –Prevent information from being leaked Compressed(压缩) –Increase transmission speed Port number(端口号) and Domain name(域名) Port number: IP address: just like 172.168.12.13 use it can find computer on internet Port number: can find application running on the computer SSH Client default port number is 22, if it’s default port number, you can omit the port number when connecting(默认端口号连接时可以省略) services port number SSH Serve 22 Web Serve 80 HTTPS 443 FTP Serve 21 Domain name: just like www.baidu.com , it use aliases for easy memory(使用别名，方便记忆) As shown in figure, www.baidu.com is 180.97.33.107 aliases, if you type 180.97.33.107 in the browser, also can visit Baidu Also, you can input 180.97.33.107:80 to visit Baidu, IP addr180.97.33.107 to find the computer, and port number 80 to find its application program (web serve) SSH Serve format:ssh [-p port] user@romote user default current user romote IP addr, Alias Or Domain name of remote computer port the port of SSH Serve to listen, default22 exp: ssh -p 22 duguosheng@172.16.140.138 Tips: exit: Log out of the current user(退出当前账户登录) Linux and Mac can use SSH without doing anything, but in Windows, you have to install some software for free Putty XShell scp scp is secure copy, it be used to remote copy file example: If the path after: isn’t an absolute path, the user’s home directory is used as the reference path(: 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径) copy 01.py from your local current directory toDesktop/01.py in your remote home directory(把本地当前目录下的 01.py 文件复制到远程家目录下的 Desktop/01.py) scp -P port 01.py user@remote:Desktop/01.py P is capital(大写) scp -P 22 01.py duguosheng@172.16.139.122:Desktop/ &lt;++&gt; copy Desktop/01.py from remote home directory to 01.py in local current directory scp -P port user@remote:Desktop/01.py 01.py use -r can copy directory demo under current local dir –&gt; remote Desktop/ scp -r demo user@remote:Desktop scp -P 22 -r demo duguosheng@212.134.23.123:Desktop/ Desktop under remote home dir –&gt; demo/ in local current dir scp -r user user@remote:Desktop demo Attention: scp only can use in linux or unix in Windows, you can install Putty, use pscp OR install FileZilla, use FTP FTP use Ftp instead of Ssh, so its port number is 21 SSH advanced All SSH ci=onfiguration information is stroed in the /home/user/.ssh Password free login(免密码登录) Steps: Configure the public key(配置公钥) Execute ssh-keygen to generate a public key(生成公钥), you can see id_rsa(private key) and id_rsa.pub(public key) under ~/.ssh/ upload public key to Serve Execute ssh-copy-id -p port user@remote can let the Serve remember our pulic key, in fact, this command copy id_rsa.pub to Serve’s ~/.ssh/ Asymmetric encryption algorithm(非对称加密算法) Data encrypted using the public key needs to be decrypted using the private key(使用公钥加密的数据，需要使用私钥解密) Data encrypted using the private key needs to be decrypted using the public key(使用私钥加密的数据，需要使用公钥解密) Configure an alias Steps: cd ~/.ssh/ touch config vi config edit config for example, ssh -p 22 example@100.100.100.100 can be changed to ssh exp by edit config like this Also, you can use scp -r ~/Desktop exp:Desktop/demo to copy a directory Commands about User Premissions(用户权限)User and Premission In Linux, you can specify different permissions for different files or directories for each user the permissions contains: permission abbreviation number read r 4 write w 2 executive x 1 ls -l extended execute ls -lh get some infomation like this dor- rwx r-x r– 2 duguosheng duguosheng 4.0K Aug 2 23:04 桌面/ d directory - file user permission group permission other people permission Number of hard links user name group name size last version time file or directory name Number of hard links(硬链接数) how many ways to access the current directory/file if it is a file, the number is 1, through the path if it is a directory without subdirectories(没有子目录), the number is 2, through the path orcd . if it is a directory with n subdirectories(有n个子目录), the number is 2+n, through the path, cd . or cd .. chmod chmod can change permission of user/group format: chmod +/- rwx fileName/dirName this usage will permission of both change user and group sudo su is substitute user, default is root Group To facilitate user management, you can group users and then assign permissions to groups(分组，为组分配权限) command function groupadd (name) add a group groupdel (name) delete a group cat /etc/group view group chgrp -R (group_name) (dir) change the group to which the dir belongs User managementcreate/delete user And change password command function tips useraddd -m -g (groupName) (userName) add a user -m auto create home directory, -g specify user’s group, otherwise a group with the same name as the user will be created passwd (user) set user’s password normal user can set set password by passwd userdel -r (user) delete user -r will delete user’s home dir if you foget to add -m, you can delete user and recreate it the user information is stored in the /etc/passwd view user information command function id (user) view uid and gid who View a list of all currently logged in users(查看当前所有登录的用户列表) whoami view current user id duguosheng cat -n /etc/passwd cat -n /etc/group duguosheng x 1000 1000 duguosheng /home/duguosheng /usr/bin/fish user encrypted password user id group id group home dir shell usermod usermod can be used to set the user’s primary/additional group and login shell(设置主组/附加组，和登录shell) command function usermod -g (group) (user) change user’s primary group usermod -G (group) (user) change user’s additional group usermod -s /bin/bash (user) change user’s shell Users added by default with useradd do not have permission to use sudo to execute commands as root. Users can be added to sudo additional groups by using the following commands(默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中)usermod -G sudo (user) whichwhich (command) see the path of command which ls result: /bin/ls bin and sbin change user command func su change to root(not safe) su (user) change user su - (user) change user and go his home dir exit log out Modify File Permissions(修改文件权限) command func chown (user) (file/dir) change ower chgrp -R (user) (file/dir) change group chmod -R 755 (file/dir) change permission systemtime command func date view system time cal view calendar cal -y view calendar of a year disk information(磁盘信息) command word func df -h disk free show free space of disk(剩余空间) du -h [dir] disk usage display the file size in the dir(目录下的文件大小) process information(进程信息) command word func ps (aux) process status view process top Display running processes dynamically and sort them(动态显示运行中的进程并且排序) kill [-9] (process) process can be a name or its pid, stop the process, -9 :force to stop option of ps a :Display all processes on the terminal, including those of other users(显示终端上的所有进程，包括其他用户的进程) u :display details of process x :Display processes without control terminals(显示没有控制终端的进程) Other commandfind format: find [path] -name &quot;*.png&quot; if no path, default in current directory Softlink(软链接) format: ln -s src destfile use absolute path, don’t use relative path Hardlink(硬链接) format: ln src destfile Packing and Compression(打包压缩)Pack/unpack(打包/解包) different OS has different mode of pack and compression windows : rar mac : zip linux : tar tar can pack a series of files into a large file or restore a packaged large file into a series of files(此命令可以把一系列文件打包到 一个大文件中，也可以把一个打包的大文件恢复成一系列文件) command func tar -cvf 打包文件.tar 被打包文件/路径… pack tar -xvf 打包文件.tar unpack options of tar option func c 生成档案文件，创建打包文件 x 解开档案文件 v 列出详细过程，显示进度 f 指定档案文件，f后面一定是.tar文件，所以必须放选项最后 attention: f 必须放在选项最后，其他随意tar 只负责打包，不负责压缩 compression/decompression(压缩/解压)gzip tar 与gzip 结合可实现打包压缩 用gzip 压缩tar 打包后的文件，扩展名一般用xxx.tar.gz 在tar 命令中，有一个-z 选项可以调用gzip 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径...# 解压缩tar -zxvf 打包文件.tar.gz# 解压缩到指定路径,该指定路径必须已存在tar -zxvf 打包文件.tar.gz -C 指定路径 bzip2 tar 与bzip2 结合可实现打包压缩 用bzip2 压缩tar 打包后的文件，扩展名一般用xxx.tar.bz2 在tar 命令中，有一个-j 选项可以调用bzip2 12345678# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径...# 解压缩tar -jxvf 打包文件.tar.bz2# 解压缩到指定路径,该指定路径必须已存在tar -jxvf 打包文件.tar.bz2 -C 指定路径]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux包管理工具pacman]]></title>
    <url>%2F2019%2F08%2F29%2Farchlinux%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pacman%2F</url>
    <content type="text"><![CDATA[pacman的基本命令分为三大类S,R,Q command with S (means synchronized&lt;同步的&gt;) command function example sudo pacman -S (some apps) install software sudo pacman -S vlc sudo pacman -Sy only synchronize source(仅同步源) sudo pacman -Syy force to refresh for updates(强制刷新一遍更新信息) sudo pacman -Su update the system sudo pacman -Syu synchronize source and update sudo pacman -Syyu force to refresh imformation for updates and update system sudo pacman -Ss (some apps) search for the software from internet sudo pacman -Ss vim sudo pacman -Sc delete software installation packages command with R (means remove) command function example sudo pacman -R (app) delete the software sudo pacman -R vim sudo pacman -Rs (app) delete the software and the packages it rely on(删除软件及其依赖的包) sudo pacman -Rs vim *sudo pacman -Rns (app) delete software, packages, and global profile sudo pacman -Rns vim command with Q (means query&lt;查询&gt;) command function example sudo pacman -Q list all softwares be installed sudo pacman -Qe list the software have been installed by user sudo pacman -Q &#124; wc -l show total number of softwares sudo pacman -Qe &#124; wc -l show number of personal softwares sudo pacman -Qeq list pesonal softwares without version sudo pacman -Qs (app) query the softwares which contains letters sudo pacman -Qs vim sudo pacman -Qdt query unrequired packages sudo pacman -Qdtq query unrequired packages(不需要的包) combination commands command function example sudo pacman -R $(pacman -Qdtq) delete unrequired packages]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>pacman</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端下文件管理器Ranger使用]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8Ranger%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[选择/打开文件 命令 功能 left或h 上一级 right或l 下一级/打开文件 up或k 上一个 down或j 下一个 gg 最上方 G 最下方 r 选择打开方式 [ 移动至上一个父文件夹 ] 移动至下一个父文件夹 H 退回上一个位置 L 撤销退回 &lt;Space&gt; 选择该文件，可多选 v 反转选择 V 进入可视模式，结合移动键进行选择 打开文件默认使用nano或者gedit，如果想要修改， 查看默认编辑器 1echo $EDITOR 修改默认编辑器(如改为vim) 如果使用bash 1export EDITOR="/usr/bin/vim" 如果使用fish 1set -g -x EDITOR "/usr/bin/vim" 复制粘贴 命令 功能 y 按照提示选择复制的内容，如文件，文件路径等 yy 复制一个文件 p 按照提示招贴 pp 复制刚才粘贴的，不覆盖 po 复制并覆盖重名文件 dd 剪切 dD 删除 dU 查看文件大小 复制一个很大的文件进行粘贴时，可使用w进入进度管理 在进度管理中，dd取消当前任务 其他操作 命令 功能 /搜索内容 查找文件,n下一个,N上一个 f 搜索内容 查找文件，并直接指向该文件 zh / &lt;BackSpace&gt; / &lt;C-h&gt; 显示/隐藏隐藏文件 cw / a / i / A / I 重命名文件 o 按照提示选择排序方式 生成Ranger配置文件 在终端下执行 1ranger --copy-config=all 就会在.config/ranger/下看到相关配置文件，更多配置信息可以去ranger的github下的wiki栏目下查看]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
</search>
